import "System.spap"
import "ctobj.spap"
import "util.spap"
import System.Algorithm.*
import System.Console.*
import Util.*
import Ctobj.*

//////////////////////////////////////
//tokenization
module CharSet
	auto charset(string e)
		ok=new u32[8]
		for i=0:7
			ok[i]=0
		inv=0
		s=0
		if e[0]=='^':
			inv=1;s++
		for(;s<e.n;s++)
			if s+1<e.n&&e[s+1]=='-':
				for(i=u32(u8(e[s]));i<=u32(u8(e[s+2]));i++)
					ok[i>>5]|=(1u<<int(i&31u));
				s+=2
			else
				ok[e[s]>>5]|=(1u<<int(u32(u8(e[s]))&31u));
		if inv:
			for i=0:7
				ok[i]=~ok[i]
		return ok
	digits=charset("0-9")
	digdot=charset("0-9.")
	hexdigit=charset("0-9a-fA-F")
	idhead=charset("_A-Za-z\200-\377")
	idbody=charset("_0-9A-Za-z\200-\377")
	spaces=charset("\r\t ")
	spaces_newline=charset("\r\n\t ")
	newlines=charset("\r\n")
	inline has(u32[] ok,int c)
		return !(c&0xffffff00)&&((ok[c>>5]>>(c&31))&1u);

TOK_TYPE=0x20000000
TOK_TYPE_MASK=-TOK_TYPE
TOK_CONST=1*TOK_TYPE
TOK_ID=2*TOK_TYPE
TOK_STRING=3*TOK_TYPE
TOK_EOF=4*TOK_TYPE
TOK_AA=int('e')
TOK_OO=int('f')
TOK_ADD_EQ=int('i')
TOK_SUB_EQ=int('j')
TOK_MUL_EQ=int('k')
TOK_DIV_EQ=int('l')
TOK_ADD_ADD=int('m')
TOK_SUB_SUB=int('n')
////////////////
TOK_MOD_EQ=int('o')
TOK_OR_EQ=int('p')
TOK_AND_EQ=int('q')
TOK_XOR_EQ=int('r')
TOK_LSHIFT_EQ=int('s')
TOK_RSHIFT_EQ=int('t')
g_sta_tr0=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,-1,-1,-1,4,10,-1,3,-1,4,5,-1,6,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,9,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
struct TToken
	int tok
	int epos0,epos1
auto tokenize(iptr ptr_start,int g_ignore_indents)
	//we want feed to be zero-terminated
	//merge all files to one big vector, add zeroes, and pass in the starting location
	feed=g_feed
	ptr=ptr_start
	inline skipchars(u32[] cs)
		while ptr<feed.n
			ch=int(u8(feed[ptr]))
			if !CharSet.has(cs,ch):return
			ptr++
	inline parseOperator()
		ptr0=ptr
		state=int(g_sta_tr0[int(feed[ptr])]);ptr++
		switch state{
		default:
			ptr=ptr0
			return
		case 1:
			ch=int(feed[ptr]);ptr++
			if ch==']':return
			ptr=ptr0
			return
		case 2:
			return;
		case 3:
			//operator() should be allowed
			ch=int(feed[ptr]);ptr++
			if ch==')':return
			ptr=ptr0
			return
		case 4:
			ch=int(feed[ptr]);ptr++
			if ch=='=':return
			ptr--;return;
		case 5:
			ch=int(feed[ptr]);ptr++
			if ch=='+':return
			if ch=='=':return
			ptr--;return;
		case 6:
			ch=int(feed[ptr]);ptr++
			if ch=='-':return
			if ch=='=':return
			ptr--;return;
		case 7:
			ch=int(feed[ptr]);ptr++
			if ch=='<':{state=4;break}
			if ch=='=':return
			ptr--;return;
		case 8:
			ch=int(feed[ptr]);ptr++
			if ch=='=':return
			if ch=='>':{state=4;break}
			ptr--;return;
		case 9:
			ch=int(feed[ptr]);ptr++
			if ch=='=':return
			ptr--;return;
		case 10:
			ch=int(feed[ptr]);ptr++
			if ch=='&':return
			if ch=='=':return
			ptr--;return;
		case 11:
			ch=int(feed[ptr]);ptr++
			if ch=='=':return
			if ch=='|':return
			ptr--;return;
		}
		assert(state==4)
		ch=int(feed[ptr]);ptr++
		if ch=='=':return
		ptr--;
		return;
	//////////////////////////
	struct TBracket
		int ch
		iptr pos
	inds=new int[]
	brastk=new TBracket[]
	toks=new TToken[]
	ignore_indents=g_ignore_indents
	last_significant_newline_position=-1L
	last_line_comment_position=-1L
	inline left_bracket(int ch0)
		brastk.push(TBracket(){ch:ch0,pos:ptr})
		if ch0=='{':
			ignore_indents=g_ignore_indents
			if !ignore_indents:
				if inds.n:
					ind0=inds.back()
				else
					ind0=0
				inds.push(ind0|0x80000000)
		else
			ignore_indents=1
	inline pop_indents()
		//add } accordingly
		//ignore the last dedent
		while inds.n&&!(inds.back()&0x80000000)
			if !(inds.back()&0x40000000):
				toks.push(TToken(){tok:int('}'),epos0:int(ptr),epos1:int(ptr)})
			inds.pop()
		if inds.n:
			inds.pop()
	auto right_bracket(int ch0)
		matcher=int(ch0==')'?'(':(ch0=='}'?'{':(ch0==']'?'[':'{')))
		errored=0
		err_pos=0
		estr=string.NULL
		while brastk.n&&brastk.back().ch!=matcher:
			//compensate for the unmatching bracket
			if !errored:
				if ch0==0:
					//EOF
					error(ETYPE_ERROR,ptr,ptr,"the opening '@1' is not properly closed".Replace(["@1",string(char(brastk.back().ch))]))
				else
					error(ETYPE_ERROR,ptr,ptr+1,"the opening '@1' doesn't match the closing '@2'".Replace(["@1",string(char(brastk.back().ch)),"@2",string(char(ch0))]))
				err_pos=int(brastk.back().pos)
				estr=new string
				errored=1
			ch_poped=brastk.back().ch
			matcher_ch_poped=char(ch_poped=='('?')':(ch_poped=='{'?'}':']'))
			estr.push(matcher_ch_poped)
			toks.push(TToken(){'tok':int(matcher_ch_poped),'epos0':int(ptr),'epos1':int(ptr)+1})
			brastk.pop()
			if ch_poped=='{'&&!g_ignore_indents:
				pop_indents()
		if errored:
			if brastk.n:
				epos_pop_to=brastk.back().pos+1
			else
				epos_pop_to=ptr_start
			error(ETYPE_NOTE,ptr,ptr,"inserting '@1'".Replace(["@1",estr]))
			if brastk.n:
				error(ETYPE_NOTE,err_pos,err_pos+1,"the opening '@1' was here".Replace(["@1",string(char(brastk.back().ch))]))
			else
				error(ETYPE_NOTE,err_pos,err_pos+1,"the opening bracket was not found")
			//error(ETYPE_NOTE,epos_pop_to,epos_pop_to,FormatAsText("automatically matching dangling opening brackets until here"))
		if brastk.n:
			ch_poped=brastk.back().ch
			brastk.pop()
			if ch_poped=='{'&&!g_ignore_indents:
				pop_indents()
		else
			if !errored&&ch0:
				error(ETYPE_ERROR,ptr,ptr+1,"the closing '@1' does not close any opening bracket".Replace(["@1",string(char(ch0))]))
				return 0
		if brastk.n&&brastk.back().ch!='{':
			ignore_indents=1
		else
			ignore_indents=g_ignore_indents
		return 1
	for(;;)
		skipchars(ignore_indents?CharSet.spaces_newline:CharSet.spaces)
		ch=int(feed[ptr])
		//numbers
		if CharSet.has(CharSet.digits,ch):
			//get the string representation
			efeed0=ptr
			efeed0_real=ptr
			skipchars(CharSet.digits)
			ch=int(feed[ptr])
			isfloat=0
			ishex=0
			if ch=='x':
				ptr++;ch=int(feed[ptr])
				efeed0=ptr
				skipchars(CharSet.hexdigit)
				ishex=1
				ch=int(feed[ptr])
			else
				if ch=='.':
					isfloat=1;
					ptr++;
					skipchars(CharSet.digdot);
					ch=int(feed[ptr])
				if ch=='e'||ch=='E':
					isfloat=1;
					ptr++;ch=int(feed[ptr])
					if ch=='-':
						ptr++
					skipchars(CharSet.digits)
			ch=int(feed[ptr])
			if isfloat:
				if ch=='f':
					val=i64(__float_as_int(feed[efeed0:ptr-1].ConvertToAsBinary(char).as(float)))
					cid=getid_const(const_type(CTYPE_FLOAT,32),val)
					ptr++
				else
					val=__double_as_longlong(feed[efeed0:ptr-1].ConvertToAsBinary(char).as(double))
					cid=getid_const(const_type(CTYPE_FLOAT,64),val)
			else
				if ishex:
					val=feed[efeed0:ptr-1].ConvertToAsBinary(char).asHex(i64)
				else
					val=feed[efeed0:ptr-1].ConvertToAsBinary(char).as(i64)
				//actually parse the number, as double
				t=const_type(CTYPE_INT,32)
				if ch=='u':
					ptr++
					ch=int(feed[ptr])
					t=(t&~CTYPE_MASK)|CTYPE_UINT
				if ch=='L':
					ptr++
					ch=int(feed[ptr])
					if ch=='L':
						ptr++
						ch=int(feed[ptr])
						t=const_type(t&CTYPE_MASK,64)
					else
						t=const_type(t&CTYPE_MASK,Util.bitSize())
				if ch=='u':
					ptr++
					ch=int(feed[ptr])
					t=(t&~CTYPE_MASK)|CTYPE_UINT
				val_represented=val
				if t==const_type(CTYPE_UINT,32):
					val_represented=i64(u32(val_represented))
				else if t==const_type(CTYPE_INT,32):
					val_represented=i64(u32(val_represented))
				if val_represented!=val:
					if (val_represented^val)!=0xFFFFFFFF00000000LL||!ishex:
						//we ignore sign-only difference for hex values
						error(ETYPE_WARNING,efeed0_real,ptr,"the number '"+cite_raw(efeed0_real,ptr)+"' has been clamped to value "+string(val_represented))
				cid=getid_const(t,val)
			toks.push(TToken(){'tok':TOK_CONST+cid,'epos0':int(efeed0),'epos1':int(ptr)})
			continue
		//id
		if CharSet.has(CharSet.idhead,ch):
			s=ptr
			ptr++
			skipchars(CharSet.idbody)
			if ptr-s>=8&&cite_raw(ptr-8,ptr)=="operator":
				//operator state machine
				parseOperator()
			id=getid(cite_raw(s,ptr))
			toks.push(TToken(){'tok':TOK_ID+id,'epos0':int(s),'epos1':int(ptr)})
			continue
		ch0=ch
		epos0_ch0=ptr
		ptr++;ch=int(feed[ptr])
		//is_at_str=0
		if !ch0:break
		switch ch0{
		default:
			break;//nothing
		case '[','(','{':
			left_bracket(ch0)
			break;
		case ')',']','}':
			if !right_bracket(ch0):
				//we shouldn't put it in
				continue
			break;
		case '=':
			if(ch=='=')
				ptr++
				ch0=TOK_EQ;
			break;
		case '+':
			if(ch=='='){ptr++;ch0=TOK_ADD_EQ;}else
			if(ch=='+'){ptr++;ch0=TOK_ADD_ADD;}
			break
		case '-':
			if(ch=='='){ptr++;ch0=TOK_SUB_EQ;}else
			if(ch=='-'){ptr++;ch0=TOK_SUB_SUB;}
			break
		case '*':
			if(ch=='='){ptr++;ch0=TOK_MUL_EQ;}
			break
		case '<':
			if(ch=='='){ptr++;ch0=TOK_LE;}else
			if(ch=='<')
				ptr++;ch0=TOK_LL;
				if feed[ptr]==u8('='):
					ptr++;ch0=TOK_LSHIFT_EQ;
			break;
		case '>':
			if(ch=='='){ptr++;ch0=TOK_GE;}else\
			if(ch=='>')
				ptr++;ch0=TOK_GG;
				if feed[ptr]==u8('='):
					ptr++;ch0=TOK_RSHIFT_EQ;
			break;
		case '!':{if(ch=='='){ptr++;ch0=TOK_NE;}break;}
		case '&':
			if(ch=='&'){ptr++;ch0=TOK_AA;}
			if(ch=='='){ptr++;ch0=TOK_AND_EQ;}
			break;
		case '|':
			if(ch=='|'){ptr++;ch0=TOK_OO;}
			if(ch=='='){ptr++;ch0=TOK_OR_EQ;}
			break;
		case '%':
			if(ch=='='){ptr++;ch0=TOK_MOD_EQ;}
			break
		case '^':
			if(ch=='='){ptr++;ch0=TOK_XOR_EQ;}
			break
		//indent stuff
		case '\\':
			//line-escape
			if(ch=='\n'||ch=='\r')
				skipchars(CharSet.newlines)
				continue
			break;
		case '\n':
			//just a normal space when gettext AND no indent
			assert(!ignore_indents)
			epos0=ptr
			app=0
			ind=0
			for(ind=0;;)
				ch=int(feed[ptr]);
				if !CharSet.has(CharSet.spaces_newline,ch):break
				ptr++
				if ch=='\r':
					//nothing
				else if ch=='\n':
					ind=0;app=0
				else
					if ch=='\t':{app|=1}else app|=2;
					ind++;
				if app==3:
					app=7
					error(ETYPE_ERROR,int(epos0),ptr,"space and tab can't be mixed in indentation")
			if !feed[ptr]:
				ind=0
			if int(feed[ptr])=='}':
				//auto-pop to 0x80000000 during the latter }
				//pop_indents()
				continue
			else
				ind0=(inds.n?(inds.back()&0x3fffffff):0)
				if ind0!=ind:
					if ind0<ind:
						if inds.n&&(inds.back()&0x80000000)&&toks.back().tok==int('{'):
							//ignore the first indent immediately following a {
							inds.push(ind|0x40000000)
							last_significant_newline_position=toks.n
							continue
						inds.push(ind)
						ch0=int('{')
					else
						//don't pop past the {
						while inds.n&&(inds.back()&0xbfffffff)>ind:
							inds.pop();
							toks.push(TToken(){'tok':int('}'),'epos0':int(ptr),'epos1':int(ptr)})
						if !inds.n:
							if ind:
								error(ETYPE_ERROR,epos0_ch0,ptr,FormatAsText("indentation mismatch - this line is indented less than the first line in the file"))
						else if (inds.back()&0x3fffffff)!=ind:
							//indentation mismatch
							error(ETYPE_ERROR,epos0_ch0,ptr,FormatAsText("indentation mismatch - @1 expected but @2 provided").Replace(["@1",string(inds.back()),"@2",string(ind)]))
						last_significant_newline_position=toks.n
						continue
				else
					ch0=int(';')
					last_significant_newline_position=toks.n
					if toks.n:
						ch_lastline=toks.back().tok
						if ch_lastline==int(';')||ch_lastline==int(',')||ch_lastline==int('{'):
							continue
					if toks.n==last_line_comment_position:
						//line comments shouldn't generate ;, but they should generate {}
						continue
			last_significant_newline_position=toks.n+1
			break
		//char/string literal
		case '"','\'':
			//is_python_str=0
			//if ch==ch0:
			//	if ptr<feed.n-1&&(int)feed[ptr+1]==(int)ch0:
			//		//python string
			//		is_python_str=1
			//		ptr+=2
			efeed0=ptr
			c0=ch0
			isrecover=0
			str=new string
			for(;;)
				c=int(feed[ptr]);ptr++
				if c==0:
					if isrecover:
						ptr--
						break
					ptr--
					error(ETYPE_ERROR,int(efeed0),ptr,"this string is not properly enclosed")
					ptr=efeed0
					isrecover=1
					str.clear()
					continue
				if c=='\\'://&&!is_at_str:
					ch=int(feed[ptr])
					if ch=='\r'||ch=='\n':
						ptr++;ch=int(feed[ptr])
						if ch=='\r'||ch=='\n':
							ptr++;ch=int(feed[ptr])
						continue
					c=ch;ptr++;
					switch c{
					case 'n':
						c=int('\n');break;
					case 'r':
						c=int('\r');break;
					case 't':
						c=int('\t');break;
					case 'b':
						c=int('\b');break;
					case 'e':
						c=27;
						break;
					case 'x','u':
						chu=0
						for j=0:(ch0=='u'?3:1)
							chj=int(feed[ptr])
							if chj:ptr++
							si=((chj-'0')&0x1f)
							if si>=0x10:si-=7
							chu=chu*16+(si&0xf)
						if ch0=='x':
							str.push(char(chu))
						else
							if chu>=2048:
								str.push(char(((chu>>12)&0xf)+0xe0))
								str.push(char(0x80+((chu>>6)&63)))
								str.push(char(0x80+(chu&63)))
							else if chu>=128:
								str.push(char((chu>>6)+0xc0))
								str.push(char(0x80+(chu&63)))
							else
								str.push(char(chu))
						continue
					default:
						if CharSet.has(CharSet.digits,c):
							ptr--
							s=ptr
							skipchars(CharSet.digits)
							c=0
							for(;s!=ptr;s++)
								si=int(feed[s])
								c=c*8+(si-'0')
						break
					}
				else
					if c==c0:
						//if is_python_str:
						//	if ptr<=feed.n-2&&feed[ptr]==c0&&feed[ptr+1]==c0:
						//		ptr+=2
						//		break
						//	else
						//		goto goodchar0
						break;
					if isrecover&&(c=='\r'||c=='\n'):break
				//:goodchar0
				str.push(char(c))
			if ch0=='\''&&str.n==1:
				//char
				toks.push(TToken(){'tok':TOK_CONST+getid_const(const_type(CTYPE_INT,8),i64(str[0])),'epos0':int(efeed0)-1,'epos1':int(ptr)})
			else
				toks.push(TToken(){'tok':TOK_STRING+getid(str),'epos0':int(efeed0)-1,'epos1':int(ptr)})
			continue
		//comments
		case '/':
			if(ch=='='){ptr++;ch0=TOK_DIV_EQ;break;}
			if ch=='/':
				ptr++
				for(;;)
					ch=int(feed[ptr])
					if ch==0||ch=='\n':break
					ptr++
				if last_significant_newline_position==toks.n:
					last_line_comment_position=toks.n
				continue
			if ch=='*':{
				ptr++
				auto c=0;
				for(;;)
					ch=int(feed[ptr])
					if ch==0:break
					ptr++
					if ch=='/'&&c=='*':break;
					c=ch;
				continue
			}
			break;
		}
		toks.push(TToken(){'tok':ch0,'epos0':int(epos0_ch0),'epos1':int(ptr)})
	//////////////////
	while brastk.n:
		right_bracket(0)
	pop_indents()
	toks.push(TToken(){'tok':TOK_EOF,'epos0':int(ptr),'epos1':int(ptr)})
	return toks

auto dumpToken(int tok)
	assert(tok!='\n')
	switch(tok&TOK_TYPE_MASK){
	case TOK_CONST:
		val=Util.g_const_values[tok&~TOK_TYPE_MASK]
		return dumpConst(val)
	case TOK_ID:
		return new(getIdString(tok&~TOK_TYPE_MASK))
	case TOK_STRING:
		s0=getIdString(tok&~TOK_TYPE_MASK)
		return "\""+genString(s0)+"\""
	}
	switch tok{
	case 0:return "<EOF>"
	case TOK_EQ:return "=="
	case TOK_NE:return "!="
	case TOK_LE:return "<="
	case TOK_GE:return ">="
	case TOK_AA:return "&&"
	case TOK_OO:return "||"
	case TOK_LL:return "<<"
	case TOK_GG:return ">>"
	case TOK_ADD_EQ:return "+="
	case TOK_SUB_EQ:return "-="
	case TOK_MUL_EQ:return "*="
	case TOK_DIV_EQ:return "/="
	case TOK_ADD_ADD:return "++"
	case TOK_SUB_SUB:return "--"
	case TOK_MOD_EQ:return "%="
	case TOK_OR_EQ:return "|="
	case TOK_AND_EQ:return "&="
	case TOK_XOR_EQ:return "^="
	case TOK_LSHIFT_EQ:return "<<="
	case TOK_RSHIFT_EQ:return ">>="
	}
	return string(char(tok))

auto dumpTokenArray(TToken[] toks)
	ret=new string
	ind=0
	foreach toki in toks
		s2=dumpToken(toki.tok)
		if ret.n&&s2.n&&CharSet.has(CharSet.idbody,int(u8(s2[0]))):
			if CharSet.has(CharSet.idbody,int(u8(ret.back()))):
				ret.push(' ')
			else if ret.back()=='}':
				ret.push('\n')
				for j=0:ind-1
					ret.push('  ')
		if toki.tok=='}':
			if ind>0:ind--
			if ret.n&&ret.back()==' '&&ret[ret.n-2]==' ':
				ret.pop()
				ret.pop()
			else
				ret.push('\n')
				for j=0:ind-1
					ret.push('  ')
		ret.push(s2)
		if toki.tok=='{'||toki.tok==';':
			if toki.tok=='{':
				ind++
			ret.push('\n')
			for j=0:ind-1
				ret.push('  ')
	return ret

auto test_tokenizer()
	//Write(dumpTokenArray(tokenize(loadSourceFile("test\\ttokenizer.spap"),0)))
	Write(dumpTokenArray(tokenize(loadSourceFile(getid("test\\tparser.spap")),0)))

//////////////////////////////////////
//canonical form parser, always returns a statement list
struct TOperator
	int id,id2
	int priority
g_operators=new TOperator[128]
g_inited=0
auto initParser()
	if g_inited:return
	g_inited=1
	/////////////////////
	g_operators[TOK_EQ]=TOperator(){'id':getid("operator"+dumpToken(TOK_EQ)),'priority':60}
	g_operators[TOK_NE]=TOperator(){'id':getid("operator"+dumpToken(TOK_NE)),'priority':60}
	g_operators[TOK_LE]=TOperator(){'id':getid("operator"+dumpToken(TOK_LE)),'priority':60}
	g_operators[TOK_GE]=TOperator(){'id':getid("operator"+dumpToken(TOK_GE)),'priority':60}
	g_operators[TOK_AA]=TOperator(){'id':getid("operator"+dumpToken(TOK_AA)),'priority':70}
	g_operators[TOK_OO]=TOperator(){'id':getid("operator"+dumpToken(TOK_OO)),'priority':75}
	g_operators[TOK_LL]=TOperator(){'id':getid("operator"+dumpToken(TOK_LL)),'priority':52}
	g_operators[TOK_GG]=TOperator(){'id':getid("operator"+dumpToken(TOK_GG)),'priority':52}
	s="operator"+dumpToken(TOK_ADD_EQ);g_operators[TOK_ADD_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_SUB_EQ);g_operators[TOK_SUB_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_MUL_EQ);g_operators[TOK_MUL_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_DIV_EQ);g_operators[TOK_DIV_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_MOD_EQ);g_operators[TOK_MOD_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_OR_EQ);g_operators[TOK_OR_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_AND_EQ);g_operators[TOK_AND_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_XOR_EQ);g_operators[TOK_XOR_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_LSHIFT_EQ);g_operators[TOK_LSHIFT_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	s="operator"+dumpToken(TOK_RSHIFT_EQ);g_operators[TOK_RSHIFT_EQ]=TOperator(){'id':getid(s),'id2':getid(s[:s.n-2]),'priority':LEVEL_ASSIGNMENT}
	g_operators[TOK_ADD_ADD]=TOperator(){'id':getid("operator"+dumpToken(TOK_ADD_ADD)),'priority':LEVEL_POSTFIX}
	g_operators[TOK_SUB_SUB]=TOperator(){'id':getid("operator"+dumpToken(TOK_SUB_SUB)),'priority':LEVEL_POSTFIX}
	g_operators[(int('+'))]=TOperator(){'id':getid("operator+"),'priority':50}
	g_operators[(int('-'))]=TOperator(){'id':getid("operator-"),'priority':50}
	g_operators[(int('*'))]=TOperator(){'id':getid("operator*"),'priority':40}
	g_operators[(int('/'))]=TOperator(){'id':getid("operator/"),'priority':40}
	g_operators[(int('%'))]=TOperator(){'id':getid("operator%"),'priority':40}
	g_operators[(int('&'))]=TOperator(){'id':getid("operator&"),'priority':54}
	g_operators[(int('|'))]=TOperator(){'id':getid("operator|"),'priority':56}
	g_operators[(int('^'))]=TOperator(){'id':getid("operator^"),'priority':55}
	g_operators[(int('['))]=TOperator(){'id':getid("operator[]"),'priority':LEVEL_POSTFIX}
	g_operators[(int('~'))]=TOperator(){'id':getid("operator~"),'priority':LEVEL_PREFIX}
	g_operators[(int('!'))]=TOperator(){'id':getid("operator!"),'priority':LEVEL_PREFIX}
	g_operators[(int('<'))]=TOperator(){'id':getid("operator<"),'priority':60}
	g_operators[(int('>'))]=TOperator(){'id':getid("operator>"),'priority':60}
	g_operators[(int('?'))]=TOperator(){'id':getid("__select"),'priority':LEVEL_SELECT}
	g_operators[(int('='))]=TOperator(){'id':g_id_store,'priority':LEVEL_ASSIGNMENT}

g_system_unit_path=System.Env.GetExecutablePath()+"../../units/"
auto scanForSystemUnit(int id_namespace)
	s0=getIdString(id_namespace)
	s=new string
	foreach ch0 in s0
		ch=int(u8(ch0))
		if ch>='A'&&ch<='Z':
			if s.n&&(s.back()>='a'&&s.back()<='z'||s.back()>='A'&&s.back()<='Z'):
				s.push('-')
			s.push(char(ch+0x20))
		else
			s.push(ch0)
	fn=g_system_unit_path+s+".spap"
	if System.IO.FileExists(fn):
		return getid(fn)
	return 0
	
auto addSourceFile(int id_fn0)
	id_fn=getid(System.Env.NormalizeFileName(getIdString(id_fn0)))
	if !g_parsed_files[id_fn]:
		g_parsed_files[id_fn]=1
		g_files_to_parse.push(id_fn)
	return id_fn

auto parseC0(int id_fn_current,TToken[] toks)
	if !toks.n:return expriptr(0)
	if g_enable_dump:
		Writeln('============raw tokens')
		Writeln(dumpTokenArray(toks))
	initParser()
	fn=getIdString(id_fn_current)
	fn=fn.Replace(["\\","/"])
	sunit_name_default=new string
	need_to_capitalize=0
	p_slash=fn.LastIndexOf('/')
	if p_slash>=0:
		fn=fn[p_slash+1:]
	p_last_dot=fn.LastIndexOf('.')
	if p_last_dot>=0:
		fn=fn[:p_last_dot-1]
	foreach ch,I in fn
		chi=int(ch)
		if g_c_id_allowed[chi]:
			if chi>='A'&&ch<='Z':
				chi+=0x20
			if chi>='a'&&ch<='z':
				if need_to_capitalize:
					chi-=0x20
				need_to_capitalize=0
			else
				need_to_capitalize=(chi!='_')
			sunit_name_default.push(char(chi))
		else
			need_to_capitalize=1
	if sunit_name_default[0]>='0'&&sunit_name_default[0]<='9':
		sunit_name_default="_"+sunit_name_default
	//sunit_name_default=sunit_name_default.ToLower()
	if sunit_name_default[0]>='a'&&sunit_name_default[0]<='z':
		sunit_name_default[0]-=i8(0x20)
	id_unit=getid(sunit_name_default)
	//even keyworded statements could use function syntax
	//we should parse it into the code structures here
	ptr=0L
	g_current_function_ccnv=0
	inline peek()
		return toks[ptr].tok
	//the inlines were a bit excessive...
	auto wantid()
		auto tok=peek()
		if ((tok&TOK_TYPE_MASK)==TOK_ID)
			ptr++
			return tok&~TOK_TYPE_MASK
		else
			return 0
	auto want(int tok)
		if peek()==tok:
			ptr++
			return 1
		else
			return 0
	auto eof()
		return peek()==TOK_EOF
	//////////////////////////////////
	auto parseMap(PExpression pe0,int epos0)
		as_member_setter=new PExpression[]
		vtemp=gettempid(0)
		if !pe0:
			as_tuple_maker=new PExpression[]
			as_member_setter.push(exprstr(g_id_tuple))
			as_member_setter.push(0)
		else
			as_member_setter.push(call(g_id_store,fillepos(exprvar(vtemp),readPool(pe0+1),readPool(pe0+2)),pe0))
		while !want(int('}'))&&!eof()
			auto tok=peek()
			ep0_id=toks[ptr].epos0
			ep1_id=toks[ptr].epos1
			if ((tok&TOK_TYPE_MASK)==TOK_ID)
				id_name=(tok&~TOK_TYPE_MASK)
				ptr++
			else if ((tok&TOK_TYPE_MASK)==TOK_STRING)
				id_name=(tok&~TOK_TYPE_MASK)
				ptr++
			else
				id_name=0
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"a member name is expected")
			if !want(int(':'))
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"':' is expected")
			pe_value=expr(LEVEL_MAX)
			if id_name&&pe_value:
				if !pe0:as_tuple_maker.push(exprstr(id_name))
			ep1_value=toks[ptr-1].epos1
			as_member_setter.push(fillepos(call(g_id_store,fillepos(call(g_id_dot,exprvar(vtemp),exprstr(id_name)),ep0_id,ep1_id),pe_value),ep0_id,ep1_value))
			if peek()!='}'&&!want(int(',')):
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"',' is expected")
		epos1=toks[max(ptr-1,0L)].epos1
		if !pe0:
			as_member_setter[1]=call(g_id_store,exprvar(vtemp),vcall(g_id_tuple,as_tuple_maker))
		as_member_setter.push(exprvar(vtemp))
		pe_map=fillepos(vcall(g_id_block,as_member_setter),epos0,epos1)
		return pe_map
	auto parseTuple(PExpression pe0,int epos0)
		as_member_setter=new PExpression[]
		as_tuple_maker=new PExpression[]
		as_member_setter.push(exprstr(g_id_tuple))
		as_member_setter.push(0)
		vtemp=gettempid(0)
		n=0
		id=getTupleId(n)
		as_tuple_maker.push(exprstr(id))
		as_member_setter.push(call(g_id_store,call(g_id_dot,exprvar(vtemp),exprstr(id)),pe0))
		n++
		while want(int(','))
			if peek()==int(')'):break
			pe_value=expr(LEVEL_MAX)
			id=getTupleId(n)
			as_tuple_maker.push(exprstr(id))
			as_member_setter.push(call(g_id_store,call(g_id_dot,exprvar(vtemp),exprstr(id)),pe_value))
			n++
		if !want(int(')')):
			error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"')' is expected")
		epos1=toks[ptr-1].epos1
		as_member_setter[1]=call(g_id_store,exprvar(vtemp),vcall(g_id_tuple,as_tuple_maker))
		as_member_setter.push(exprvar(vtemp))
		pe_tuple=fillepos(vcall(g_id_block,as_member_setter),epos0,epos1)
		return pe_tuple
	//////////////////////////////////
	auto parseFunction(int id0)
		//function
		epos0=toks[ptr-1].epos0
		ccnv=id0
		//ptr0=ptr
		id_name=wantid()
		pe=0
		es_args=[exprstr(ccnv)]
		if !want(int('('))
			//error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos1,"( expected after function")
			//ptr=ptr0
			//pe=expr(LEVEL_MAX)
			//no parameter
		else
			while !want(int(')'))&&!eof():
				ptr_bk=ptr
				//class / struct cannot take params
				if ((toks[ptr].tok&TOK_TYPE_MASK)==TOK_ID&&ptr+1<toks.n&&(toks[ptr+1].tok==','||toks[ptr+1].tok==')'))||(id0==g_id_class||id0==g_id_struct):
					pe_type=exprstr(id0==g_id_class||id0==g_id_struct?g_id_const:g_id_auto)
					id_param=wantid()
				else if toks[ptr].tok==TOK_ID+g_id_auto||toks[ptr].tok==TOK_ID+g_id_const:
					pe_type=exprstr(wantid())
					id_param=wantid()
				else
					pe_type=expr(LEVEL_MAX)
					id_param=wantid()
				if !id_param:
					id_param=g_empty_id
					epos0_id_param=toks[ptr].epos0
					epos1_id_param=toks[ptr].epos0
				else
					epos0_id_param=toks[ptr-1].epos0
					epos1_id_param=toks[ptr-1].epos1
				if !want(int(','))&&!peek()==int(')'):
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"unknown things after function parameter")
				es_args.push(pe_type)
				es_args.push(fillepos(exprstr(id_param),epos0_id_param,epos1_id_param))
				if ptr<=ptr_bk:
					//error...
					if toks[ptr].tok!=TOK_EOF:ptr++
		if peek()==int('{')||id0==g_id_class||id0==g_id_struct:
			bk=g_current_function_ccnv
			g_current_function_ccnv=id0
			pe_fbody=statement()
			g_current_function_ccnv=bk
			epos1=toks[ptr-1].epos1
			if id0==g_id_class||id0==g_id_struct:
				pe_fbody=call(g_id_block,
					fillepos(call(g_id_store,exprvar(g_id_this),call(g_id_get_lambda_context,expriptr(0)),expriptr(0)),epos0,epos1),
					pe_fbody,
					fillepos(call(g_id_store,exprvar(g_id_return),exprvar(g_id_this),expriptr(0)),epos0,epos1))
			es_args.push(pe_fbody)
			id_call=g_id_function
		else
			id_call=g_id_function_type
			//the 'auto' guys are actually types!
			for i=1:2:es_args.n-2
				if readPool(es_args[i])==EFLAG_STRING+g_id_auto:
					assert(isExpr(es_args[i+1],EFLAG_STRING))
					es_args[i]=exprvar(readPool(es_args[i+1])&~EFLAG_MASK)
					writePool(es_args[i+1],EFLAG_STRING+g_empty_id)
			if want(int(':')):
				//return type
				es_args.push(expr(LEVEL_PREFIX))
			else
				es_args.push(expriptr(0))
		epos1=toks[ptr-1].epos1
		pe=fillepos(vcall(id_call,es_args),epos0,epos1)
		if id_name:
			pe=fillepos(call(g_id_store,exprvar(id_name),pe,expriptr(0)),epos0,epos1)
		return pe
	auto atom()
		auto lex=peek()
		if (lex&TOK_TYPE_MASK)==TOK_CONST:
			ret=fillepos(exprcns(lex&~TOK_TYPE_MASK),toks[ptr].epos0,toks[ptr].epos1)
			ptr++
			return ret
		else if (lex&TOK_TYPE_MASK)==TOK_STRING:
			ret=fillepos(exprstr(lex&~TOK_TYPE_MASK),toks[ptr].epos0,toks[ptr].epos1)
			ptr++
			return ret
		else if (lex&TOK_TYPE_MASK)==TOK_ID:
			id0=wantid()
			if id0==g_id_function||id0==g_id_inline||id0==g_id_class||id0==g_id_struct:
				return parseFunction(id0)
			else if id0==g_id_module:
				epos0=toks[ptr-1].epos0
				id_namespace=wantid()
				if !id_namespace:
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"module must be followed by a name")
					return expriptr(0)
				pe_codeblock=statement()
				//pe_codeblock=call(g_id_block,
				//	call(g_id_store,exprvar(g_id_this),call(g_id_get_lambda_context,expriptr(0)),expriptr(0)),
				//	pe_codeblock,
				//	call(g_id_store,exprvar(g_id_return),exprvar(g_id_this),expriptr(0)))
				epos1=toks[ptr-1].epos1
				pe=fillepos(makeNamespace(id_namespace,pe_codeblock),epos0,epos1)
				return pe
			else if id0==g_id_new:
				epos0=toks[ptr-1].epos0
				pe=postexpr()
				if isBuiltinR(pe,g_id_block):
					//new (){}, ignore the new
					return pe
				else
					return fillepos(call(g_id_new,pe),epos0,readPool(pe+2))
			ret=fillepos(exprvar(id0),toks[ptr-1].epos0,toks[ptr-1].epos1)
			return ret
		else if lex=='(':
			ep0=toks[ptr].epos0
			ptr++
			//ret=expr(LEVEL_MAX)
			ep0_post_bracket=toks[ptr].epos0
			ret=expr(LEVEL_SELECT)
			if peek()==',':
				ep1=toks[ptr-1].epos1
				writePool(ret+1,ep0_post_bracket)
				writePool(ret+2,ep1)
				return parseTuple(ret,ep0)
			ep1=toks[ptr].epos1
			writePool(ret+1,ep0)
			writePool(ret+2,ep1)
			if !want(int(')')):
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"need a ')' here")
			return ret
		else if lex=='[':
			epos0=toks[ptr].epos0
			ptr++
			es=new int[]
			while !want(int(']'))&&!eof():
				//auto er=
				//tok0=peek()
				//pe=expr(LEVEL_MAX)
				pe=expr(LEVEL_SELECT)
				if !want(int(','))&&!peek()==int(']'):
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"a ',' is expected between list/map elements")
					ptr++
					continue
				es.push(pe)
				ep1=toks[ptr].epos1
			//list construction
			ret=fillepos(vcall(g_id_list,es),epos0,ep1)
			return ret
		else if lex=='{':
			//statement list
			ep0=toks[ptr].epos0
			ptr++
			tid=(toks[ptr].tok&TOK_TYPE_MASK)
			if tid==TOK_ID||tid==TOK_STRING:
				if toks[ptr+1].tok==':'&&toks[ptr].tok!=TOK_ID+g_id_default:
					return parseMap(0,ep0)
			auto code=statementList(0)
			//ret=poolCode(TCnsExpression{.flags_cid=EFLAG_CODEBLOCK+code;'epos0':toks[ptr].epos0;'epos1':toks[ptr].epos1})
			if !want(int('}')):
				//assert(0)
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"need a '}' here")
			return code
		error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos1,"invalid token '@1'".Replace(["@1",dumpToken(toks[ptr].tok)]))
		if toks[ptr].tok!=TOK_EOF:ptr++
		ret=expriptr(0)
		writePool(ret+1,toks[ptr].epos0)
		writePool(ret+2,toks[ptr].epos1)
		return ret
	inline isvar(PExpression pe_var)
		return (readPool(pe_var)&EFLAG_MASK)==EFLAG_VARIABLE
	auto modify(int is_before,PExpression pe_var,function(PExpression):PExpression fupdater)
		if isvar(pe_var)&&is_before:
			code_update=call(g_id_store,cloneExpr(pe_var),fupdater(cloneExpr(pe_var)))
			if is_before==2:
				return code_update
			else
				return call(g_id_block,code_update,pe_var)
		else if isvar(pe_var)||(readPool(pe_var)&EFLAG_MASK)==EFLAG_FCALL:
			vtemp=gettempid(0)
			//todo: modify should only clone the topmost level
			pe_clone=cloneExpr(pe_var)
			if is_before==2:
				return call(g_id_block,
					call(g_id_store,exprvar(vtemp),pe_clone),
					call(g_id_store,exprvar(vtemp),fupdater(exprvar(vtemp))),
					call(g_id_store,pe_var,exprvar(vtemp)))
			else if is_before:
				return call(g_id_block,
					call(g_id_store,exprvar(vtemp),pe_clone),
					call(g_id_store,exprvar(vtemp),fupdater(exprvar(vtemp))),
					call(g_id_store,pe_var,exprvar(vtemp)),
					exprvar(vtemp))
			else
				return call(g_id_block,
					call(g_id_store,exprvar(vtemp),pe_clone),
					call(g_id_store,pe_var,fupdater(exprvar(vtemp))),
					exprvar(vtemp))
		error(ETYPE_ERROR,readPool(pe_var+1),readPool(pe_var+2),"cannot modify constant expression '@1'".Replace(["@1",cite_raw(readPool(pe_var+1),readPool(pe_var+2))]))
		return pe_var
	auto postexpr()
		//Write('+')
		ea=atom()
		for(;;)
			if want(TOK_ADD_ADD)||want(TOK_SUB_SUB):
				epos0=readPool(ea+1)
				tok=(toks[ptr-1].tok)
				ea=fillepos(modify(0,ea,function(PExpression eparam){return call(g_id_operator_add_generic_int,eparam,expriptr(tok==TOK_ADD_ADD?1:-1))}),epos0,toks[ptr-1].epos1)
				continue
			if want(int('[')):
				if want(int(']')):
					//it's an array
					epos0=readPool(ea+1)
					ea=call(g_id_array_type,ea)
					writePool(ea+1,epos0)
					writePool(ea+2,toks[ptr-1].epos1)
					continue
				epos0=readPool(ea+1)
				ec=PExpression(0)
				if want(int(':')):
					eb=expriptr(0)
					ec=expr(LEVEL_SELECT)
				else
					eb=expr(LEVEL_SELECT)
					if want(int(':')):
						if peek()==int(']'):
							ec=-1
						else
							ec=expr(LEVEL_SELECT)
				if ec:
					ea=call(g_id_dot,ea,exprstr(g_id_slice))
					writePool(ea+1,epos0)
					writePool(ea+2,toks[ptr].epos1)
					if ec==-1:
						ea=indcall([ea,eb])
					else
						ea=indcall([ea,eb,ec])
				else
					ea=call(g_id_dot,ea,exprstr(g_id_operator_bracket))
					writePool(ea+1,epos0)
					writePool(ea+2,toks[ptr].epos1)
					ea=indcall([ea,eb])
				writePool(ea+1,epos0)
				writePool(ea+2,toks[ptr].epos1)
				if !want(int(']')):
					writePool(ea+2,toks[ptr].epos0)
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos1,"'[' - ']' mismatch: need a ']' here")
					break
				continue
			if !isBuiltinR(ea,g_id_block)&&!isBuiltinR(ea,g_id_store)&&want(int('(')):
				epos0=readPool(ea+1)
				epos1=readPool(ea+2)
				es=new int[]
				es.push(ea)
				while !want(int(')'))&&!eof():
					//Write('.')
					//pe=expr(LEVEL_MAX)
					pe=expr(LEVEL_SELECT)
					if !want(int(','))&&peek()!=int(')'):
						//error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"a ',' is expected between function parameters")
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"this function parameter expression has terminated prematurely")
						//ptr++
						continue
					es.push(pe)
				epos1=toks[ptr-1].epos1
				ea=indcall(es)
				writePool(ea+1,epos0)
				writePool(ea+2,epos1)
				if want(int('{')):
					tid=(toks[ptr].tok&TOK_TYPE_MASK)
					if tid==TOK_ID||tid==TOK_STRING:
						if toks[ptr+1].tok==':'&&toks[ptr].tok!=TOK_ID+g_id_default:
							ea=parseMap(ea,toks[ptr-1].epos0)
							continue
					ptr--
				continue
			if want(int('.')):
				epos0=readPool(ea+1)
				epos1=toks[ptr].epos1
				id=wantid()
				if !id:
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"we need an identifier after that dot")
					continue
				if id==g_id_null:
					//typed NULL case
					ea=call(g_id_cast,ea,exprcns(getid_const(CTYPE_POINTER,0LL)))
				else
					ea=call(g_id_dot,ea,exprstr(id))
				writePool(ea+1,epos0)
				writePool(ea+2,epos1)
				continue
			break
		return ea
	auto preexpr()
		//-~!
		tok=peek()
		switch tok{
		case '-','~','!','&':
			epos0=toks[ptr].epos0
			ptr++
			ea=preexpr()
			epos1=readPool(ea+2)
			if tok=='&':
				ea0=cloneExpr(ea)
				ea0x=cloneExpr(ea)
			ea=call(tok=='-'?g_id_operator_neg:g_operators[tok].id,ea)
			writePool(ea+1,epos0)
			writePool(ea+2,epos1)
			if tok=='&':
				ea=fillepos(call(g_id_block,call(g_id_store,ea0,call(g_id_aliased,ea0x)),ea),epos0,epos1)
			return ea
		case TOK_ADD_ADD,TOK_SUB_SUB:
			epos0=toks[ptr].epos0
			ptr++
			tok=(toks[ptr-1].tok)
			ea=preexpr()
			//epos0=readPool(ea+1)
			epos1=readPool(ea+2)
			ea=fillepos(modify(1,ea,function(PExpression eparam){return call(g_id_operator_add_generic_int,eparam,expriptr(tok==TOK_ADD_ADD?1:-1))}),epos0,epos1)
			return ea;
		}
		return postexpr()
	auto expr(int lv0)
		ea=preexpr();lv=-1
		for(;;)
			//Write('e')
			op=peek()
			if u32(op)>=128u:break
			fop=g_operators[op]
			f=fop.id
			lv2=fop.priority
			if lv2==LEVEL_PREFIX:break
			if !f||lv2>lv0:break
			if lv<=lv2:
				lv=lv2
			else
				assert(0)
				break
			ptr++
			epos0=readPool(ea+1)
			//eb=(lv>=LEVEL_SELECT?expr(LEVEL_ASSIGNMENT):expr(lv-1))
			eb=(lv>=LEVEL_SELECT?expr(LEVEL_SELECT):expr(lv-1))
			epos1=readPool(eb+2)
			if lv==LEVEL_SELECT:
				if !want(int(':')):
					error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos1,"'?' must be used with ':'")
					ea=eb
					continue
				epos0=readPool(ea+1)
				ec=expr(LEVEL_SELECT)
				epos1=readPool(ec+2)
				ea=call(f,ea,eb,ec)
				writePool(ea+1,epos0)
				writePool(ea+2,epos1)
				continue
			if lv==LEVEL_ASSIGNMENT&&f!=g_id_store:
				f=fop.id2
				ea=fillepos(modify(2,ea,function(PExpression eparam){return call(fop.id2,eparam,eb)}),epos0,epos1)
			else
				if lv==LEVEL_ASSIGNMENT&&readPool(ea)==EFLAG_VARIABLE+g_id_this:
					error(ETYPE_ERROR,readPool(ea+1),readPool(ea+2),"'this' can't be modified")
				if f==g_id_store&&(g_current_function_ccnv==g_id_class||g_current_function_ccnv==g_id_struct):
					ea=call(f,ea,eb,expriptr(0))
				else
					ea=call(f,ea,eb)
			writePool(ea+1,epos0)
			writePool(ea+2,epos1)
			if lv==LEVEL_ASSIGNMENT:break
		return ea
	//////////////////////////////////
	auto statement_end()
		if ptr>0&&toks[ptr-1].tok=='}':
			//a {} ender shouldn't go any further
			return
		if !want(int(';')):
			if peek()!=TOK_EOF&&peek()!='}':
				//if ptr>0&&toks[ptr-1].tok==')':
				//	error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,'C-style cast is not allowed, please use type(value)')
				//else
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,'unexpected end of statement')
	auto statement()
		//code_before=0
		//code_after=0
		epos0_statement=toks[ptr].epos0
		skip_statement_end=0
		auto id=wantid()
		if id==g_id_if:
			pecond=expr(LEVEL_MAX)
			want(int(':'))
			pethen=statement()
			if !isBuiltinR(pethen,g_id_block):pethen=call(g_id_block,pethen)
			if want(TOK_ID+g_id_else):
				peelse=statement()
				if !isBuiltinR(peelse,g_id_block):peelse=call(g_id_block,peelse)
			else
				peelse=expriptr(0)
			pe=call(g_id_if,pecond,pethen,expriptr(0),peelse)
			epos1_statement=toks[max(ptr-1,0L)].epos1
			pe=fillepos(pe,epos0_statement,epos1_statement)
			return pe
		else if id==g_id_for||id==g_id_foreach_lang||id==g_id_while:
			if id!=g_id_foreach_lang&&(id==g_id_while||want(int('('))):
				//C-style
				erred=0
				if id==g_id_while:
					pe_init=0
					pe_cond=expr(LEVEL_MAX)
					pe_inc=0
					want(int(':'))
				else
					if want(int(';')):
						pe_init=0
					else
						pe_init=statement()
					if want(TOK_ID+g_id_in):
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,FormatAsText("for ... in ... must not be enclosed in brackets"))
						erred=1
					if peek()==int(';'):
						pe_cond=0
					else
						pe_cond=expr(LEVEL_MAX)
					if !want(int(';'))&&!erred:
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,FormatAsText("a C-like for(;;) needs at least two ';'s, but the second ';' is missing"))
						erred=1
					if peek()==int(')'):
						pe_inc=0
					else
						pe_inc=expr(LEVEL_MAX)
					if !want(int(')')):
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,FormatAsText("too much stuff after the last ';' in for(;;)"))
				pe_body=statement()
				//init()
				//__blockex(BREAK|LOOP,{
				//	__if(cond,__blockex(END_BREAK),0,{});
				//	__blockex(CONTINUE,{
				//		body();
				//	});
				//	inc();
				//})
				es_loopbody=new PExpression[]
				if pe_inc:
					if pe_cond:
						es_loopbody.push(call(g_id_if,pe_cond,call(g_id_block),expriptr(0),call(g_id_block,call(g_id_blockex,exprstr(g_id_break)))))
					es_loopbody.push(call(g_id_blockex,exprstr(g_id_blockex),exprstr(g_id_continue),call(g_id_block,exprstr(g_id_block),pe_body)))
					es_loopbody.push(pe_inc)
					pe=call(g_id_blockex,exprstr(g_id_for),exprstr(g_id_blockex),exprstr(g_id_break),vcall(g_id_block,es_loopbody))
				else
					if pe_cond:
						es_loopbody.push(call(g_id_if,pe_cond,call(g_id_block),expriptr(0),call(g_id_block,call(g_id_blockex,exprstr(g_id_break)))))
					es_loopbody.push(pe_body)
					pe=call(g_id_blockex,exprstr(g_id_for),exprstr(g_id_blockex),exprstr(g_id_break),exprstr(g_id_continue),vcall(g_id_block,es_loopbody))
				if pe_init:
					pe=call(g_id_block,pe_init,pe)
			else
				//for in
				vars=new int[]
				for(;;)
					id_var=wantid()
					if !id_var:break
					vars.push(id_var)
					if !want(int(',')):break
				if vars.n==1&&id==g_id_for&&want(int('=')):
					//intslice for
					pe_a=expr(LEVEL_MAX)
					if !want(int(':')):
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"':' expected here")
						return expriptr(0)
					pe_b=expr(LEVEL_MAX)
					if want(int(':')):
						pe_c=expr(LEVEL_MAX)
					else
						pe_c=pe_b
						pe_b=expriptr(1)
					pe_container=call(g_id_int_range,pe_a,pe_b,pe_c)
				else
					if !want(TOK_ID+g_id_in):
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"'in' expected after 'for var'")
						return expriptr(0)
					pe_container=expr(LEVEL_MAX)
				want(int(':'))
				pe_body=statement()
				as=new PExpression[]
				as.push(exprstr(g_id_inline_loopbody))
				foreach id_var in vars
					as.push(exprstr(g_id_auto))
					as.push(exprstr(id_var))
				as.push(pe_body)
				pe_inline_body=vcall(g_id_function,as)
				pe=indcall([call(g_id_dot,pe_container,exprstr(g_id_foreach)),pe_inline_body])
			return pe
		else if id==g_id_break:
			pe=call(g_id_blockex,exprstr(g_id_break))
		else if id==g_id_continue:
			pe=call(g_id_blockex,exprstr(g_id_continue))
		else if id==g_id_return:
			//the return variable should be always new, but it should have been at the function level
			if peek()==';'||peek()=='}'
				pe=call(g_id_blockex,exprstr(g_id_return))
			else
				pe=expr(LEVEL_MAX)
				pe=call(g_id_block,call(g_id_store,exprvar(g_id_return),pe),call(g_id_blockex,exprstr(g_id_return)))
		else if id==g_id_auto:
			if peek()!=TOK_EOF&&toks[ptr+1].tok=='(':
				//function-like
				ptr--
				toks[ptr].tok=TOK_ID+g_id_function
				pe=expr(LEVEL_MAX)
			else
				//C-declaration-like
				as=new PExpression[]
				epos0_all=toks[ptr].epos0
				for(;;)
					epos0=toks[ptr].epos0
					epos1_id=toks[ptr].epos1
					id_var=wantid()
					if !id_var:
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"identifier expected after auto")
						break
					if want(int('=')):
						pe=expr(LEVEL_SELECT)
					else
						pe=call(g_id_uninit)
					pe=call(g_id_store,exprvar(id_var),pe,expriptr(0))
					epos1=toks[ptr-1].epos1
					fillepos(pe,epos0,epos1)
					if id_var==g_id_this:
						error(ETYPE_ERROR,epos0,epos1_id,"'this' can't be redeclared")
					else
						as.push(pe)
					if !want(int(',')):break
				epos1_all=toks[ptr-1].epos1
				pe=fillepos(vcall(g_id_block,as),epos0_all,epos1_all)
		else if id==g_id_import:
			tid=(toks[ptr].tok&TOK_TYPE_MASK)
			if tid==TOK_ID:
				id0=toks[ptr].tok&~TOK_TYPE_MASK
				epos0=toks[ptr].epos0
				if toks[ptr+1].tok!=int('.'):
					//importing a system unit without using
					id_fn=scanForSystemUnit(id0)
					ptr++
					if id_fn:
						g_dependency_edges.push(int2(id_fn_current,addSourceFile(id_fn)))
					else
						error(ETYPE_ERROR,toks[ptr-1].epos0,toks[ptr-1].epos1,"can't find system unit @1".Replace(["@1",getIdString(id0)]))
					pe=expriptr(0)
				else
					as=new PExpression[]
					for(;;)
						id=wantid()
						if !id:break
						if !want(int('.')):
							error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"'.' is expected after anamespace being imported")
						pe_id=exprstr(id)
						writePool(pe_id+1,toks[ptr-1].epos0)
						writePool(pe_id+2,toks[ptr-1].epos1)
						as.push(pe_id)
					if !want(int('*')):
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"import namespace.* has to end with .*")
					if !as.n:
						error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"import must be followed by a namespace or a filename")
						pe=expriptr(0)
					else
						assert(as.n>0)
						pe=vcall(g_id_import,as)
						epos1=toks[ptr].epos0
						writePool(pe+1,epos0)
						writePool(pe+2,epos1)
						id_fn=scanForSystemUnit(id0)
						if id_fn:
							g_dependency_edges.push(int2(id_fn_current,addSourceFile(id_fn)))
			else if tid==TOK_STRING:
				//add the file to the parsing queue
				id_fn=(toks[ptr].tok&~TOK_TYPE_MASK)
				ptr++
				fn_current=getIdString(id_fn_current).Replace(["\\","/"])
				fn_unit=getIdString(id_fn).Replace(["\\","/"])
				if !(fn_unit.StartsWith("/")||fn_unit.n>=2&&fn_unit[1]==':')
					//test in the relative path
					pslash=fn_current.LastIndexOf('/')
					fn_test=fn_current[:pslash]+fn_unit
					if System.IO.FileExists(fn_test):
						id_fn=getid(fn_test)
					else
						//test for system unit
						fn_test=g_system_unit_path+fn_unit
						if System.IO.FileExists(fn_test):
							id_fn=getid(fn_test)
				g_dependency_edges.push(int2(id_fn_current,addSourceFile(id_fn)))
				pe=expriptr(0)
		else if id==g_id_switch:
			pecond=expr(LEVEL_SELECT)
			want(int(':'))
			if !want(int('{')):
				error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"'{' expected after 'switch'")
				pe=expriptr(0)
			else
				as_if=new PExpression[]
				as_if.push(exprvar(g_id_if))
				as_if.push(pecond)
				as_if.push(0)
				as_cases=new PExpression[]
				as_default_group=PExpression[].NULL
				is_current_batch_default=0
				got_default=0
				while peek()!=TOK_EOF&&!want(int('}')):
					if want(int(';')):continue
					if want(TOK_ID+g_id_case):
						//Writeln('case ')
						if as_cases.n:
							as_cases.push(exprstr(g_id_case))
						as_cases.push(expr(LEVEL_SELECT))
						while want(int(','))
							as_cases.push(exprstr(g_id_case))
							as_cases.push(expr(LEVEL_SELECT))
						want(int(':'))
					else if want(TOK_ID+g_id_default):
						//Writeln('default ')
						want(int(':'))
						if got_default:
							error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"only one 'default' is allowed inside each 'switch'")
						is_current_batch_default=1
						got_default=1
					else
						//Writeln('body ',dumpToken(peek()))
						pe_body=statement()
						if !as_cases.n&&!is_current_batch_default:
							error(ETYPE_ERROR,toks[ptr].epos0,toks[ptr].epos0,"'case' or 'default' expected inside 'switch'")
							is_current_batch_default=1
						if is_current_batch_default:
							if as_cases.n:
								as_cases.push(exprstr(g_id_case))
							as_default_group=as_cases
							as_if[2]=pe_body
							as_cases=new PExpression[]
						else
							as_if.push(as_cases)
							as_if.push(pe_body)
							as_cases.clear()
						is_current_batch_default=0
				if as_default_group:
					as_if.push(as_default_group)
				else
					as_if[2]=expriptr(0)
				pe=call(g_id_blockex,exprstr(g_id_blockex),exprstr(g_id_break),call(g_id_block,exprstr(g_id_block),indcall(as_if)))
				epos1_statement=toks[max(ptr-1,0L)].epos1
				pe=fillepos(pe,epos0_statement,epos1_statement)
				return pe
		else
			if id:ptr--
			if want(int(';')):
				return expriptr(0)
			if peek()==int('{'):
				pe=atom()//avoid {}| stupidness
				skip_statement_end=1
			else
				pe=expr(LEVEL_MAX)
				//C-like declaration, assign to typed zeroes
				if ptr&&toks[ptr-1].tok!='}':
					id_var=wantid()
					if id_var:
						pe_type=pe
						as=new PExpression[]
						epos0_all=toks[ptr].epos0
						while id_var:
							epos0=toks[ptr-1].epos0
							epos1_id=toks[ptr-1].epos1
							if want(int('=')):
								pe=expr(LEVEL_SELECT)
							else
								pe=call(g_id_default_value,cloneExpr(pe_type))
							pe=call(g_id_store,exprvar(id_var),pe,expriptr(0))
							epos1=toks[ptr-1].epos1
							fillepos(pe,epos0,epos1)
							if id_var==g_id_this:
								error(ETYPE_ERROR,epos0,epos1_id,"'this' can't be redeclared")
							else
								as.push(pe)
							if want(int(','))
								id_var=wantid()
							else
								break
						epos1_all=toks[ptr-1].epos1
						pe=fillepos(vcall(g_id_block,as),epos0_all,epos1_all)
		//the terminating ;
		//pe=fillepos()
		if !skip_statement_end:
			statement_end()
		epos1_statement=toks[max(ptr-1,0L)].epos1
		pe=fillepos(pe,epos0_statement,epos1_statement)
		//return cat(cat(code_before,poolCode(TExprStatement{'flags_expr':pe|STATEMENT_EXPR})),code_after)
		return pe
	auto statementList(int is_top)
		epos0_statement=toks[ptr].epos0
		as=new int[]
		if is_top:
			//as.push(exprstr(getid("__block")))
			//as.push(call(g_id_store,exprvar(g_id_this),call(g_id_get_lambda_context,expriptr(0)),expriptr(0)))
			if id_unit!=g_id_builtin_unit:
				//always import __builtin
				assert(g_files_to_parse.n>1)
				as.push(call(g_id_import,exprstr(g_id_builtin_unit)))
				g_dependency_edges.push(int2(id_fn_current,g_files_to_parse[0]))
		while peek()!=TOK_EOF&&peek()!='}':
			as.push(statement())
		epos1_statement=toks[max(ptr-1,0L)].epos1
		//if is_top:
		//	//as.push(exprstr(getid("__block")))
		//	as.push(call(g_id_store,exprvar(g_id_return),exprvar(g_id_this),expriptr(0)))
		return fillepos(vcall(g_id_block,as),epos0_statement,epos1_statement)
	auto makeNamespace(int id_unit,PExpression pe_codeblock)
		//return call(g_id_store,exprvar(id_unit),indcall([call(g_id_function,exprstr(g_id_class),pe_codeblock)]),exprstr(g_id_namespace))
		return call(g_id_namespace,exprstr(id_unit),pe_codeblock,expriptr(0))
	pe_codeblock=statementList(1)
	//g_global_namespaces[id_unit]=pe_codeblock
	pe_file=makeNamespace(id_unit,pe_codeblock)
	return pe_file

auto parseAll()
	head=0L
	while head<g_files_to_parse.n
		assert(g_top_level_exprs.n==head)
		id_fn=g_files_to_parse[head]
		ptr_src=loadSourceFile(id_fn)
		//Writeln(ptr_src,' ',getIdString(id_fn))
		if ptr_src<0:
			Writeln("fatal error: cannot open '@1'".Replace(["@1",getIdString(id_fn)]))
			return 0
		g_top_level_exprs.push(parseC0(id_fn,tokenize(ptr_src,0)))
		head++
	n=g_files_to_parse.n
	fn_to_seq=new int[int]
	foreach id,I in g_files_to_parse
		fn_to_seq[id]=int(I+1)
	degs=new int[n]
	new_edges=new int2[]
	foreach ei in g_dependency_edges
		if ei.x!=ei.y:
			new_edges.push(ei)
	g_dependency_edges=new_edges
	for i=0:g_dependency_edges.n-1
		g_dependency_edges[i].x=fn_to_seq[g_dependency_edges[i].x]-1
		g_dependency_edges[i].y=fn_to_seq[g_dependency_edges[i].y]-1
		degs[g_dependency_edges[i].x]++
	g_dependency_edges.Sort(inline(a,b){return a.y<b.y})
	pedges=new int2[n]
	foreach ei,I in g_dependency_edges
		if !I||ei.y!=g_dependency_edges[I-1].y:
			pedges[ei.y].x=int(I)
		if I==g_dependency_edges.n-1||ei.y!=g_dependency_edges[I+1].y:
			pedges[ei.y].y=int(I+1)
	top_level_exprs_sorted=new PExpression[]
	for fid=0:n-1
		best=0x7fffffff
		best_i=0
		for i=0:n-1
			if best>degs[i]&&degs[i]>=0:
				best=degs[i]
				best_i=int(i)
				if !best:break
		//remove the edges
		//Writeln(degs,' ',best_i,' ',getIdString(g_files_to_parse[best_i]))
		degs[best_i]=-1
		for i=pedges[best_i].x:pedges[best_i].y-1
			degs[g_dependency_edges[i].x]--
			//Writeln('-- ',getIdString(g_files_to_parse[g_dependency_edges[i].x]),' ',degs[g_dependency_edges[i].x])
		top_level_exprs_sorted.push(g_top_level_exprs[best_i])
	g_top_level_exprs=top_level_exprs_sorted
	return 1

auto test_parser()
	toks=tokenize(loadSourceFile(getid("test\\tcanonical.spap")),0)
	//Writeln(dumpTokenArray(toks))
	code=parseC0(g_empty_id,toks)
	Writeln(dumpCode(code))

//import "system.jc"
import "util.jc"
import System.Algorithm.*
import System.Console.*
import Util.*

//the layouts of int stuff are significant, DO NOT TOUCH THEM!
PExpression=int
PCTObject=int
DEBUG_TRAP_VARIABLE=0
////////
EFLAG_MULTIPLIER=0x20000000
EFLAG_MASK=-EFLAG_MULTIPLIER
EFLAG_FCALL=0*EFLAG_MULTIPLIER
EFLAG_VARIABLE=1*EFLAG_MULTIPLIER
EFLAG_CONST=2*EFLAG_MULTIPLIER
EFLAG_STRING=3*EFLAG_MULTIPLIER
EFLAG_CTVAL=4*EFLAG_MULTIPLIER
//EFLAG_PLACEHOLDER=5*EFLAG_MULTIPLIER
//////////
//user flags are shared by vars / exprs
USER_FLAG_ACTIVATED=0x04000000
USER_FLAG_MASK=0x07ffffff
QUEUE_FLAG_REACH=0x80000000
QUEUE_FLAG_EVAL=0x40000000
QUEUE_FLAG_USERS=0x20000000
QUEUE_FLAG_DOT=QUEUE_FLAG_USERS//0x10000000
QUEUE_FLAG_ONREACH_CALLED=0x10000000
//EXPR_FLAG_IS_STACK_ALLOC=0x08000000
VAR_USER_FLAG_MASK=0x07ffffff
VAR_FLAG_LAMBDAED=0x80000000
VAR_FLAG_PARAM=0x40000000
VAR_FLAG_FLATTENED_STRUCT_MEMBER=0x20000000
VAR_FLAG_STRUCT_SLOT_ALLOCATED=0x10000000
VAR_FLAG_CLASS_IS_STACK_ALLOCED=VAR_FLAG_STRUCT_SLOT_ALLOCATED
VAR_FLAG_CLASS_STACK_STYLE_RC=0x08000000
//VAR_FLAG_FLATTENED=0x20000000
//USER_FLAG_IN_EXPR=0x08000000
//EFLAG_CODEBLOCK=4*EFLAG_MULTIPLIER
//////////
//operator levels
LEVEL_STORE_HACK=-1
LEVEL_FUNCTION_HACK=-2
LEVEL_MAX=100
LEVEL_PREFIX=15
LEVEL_POSTFIX=10
LEVEL_ASSIGNMENT=90
LEVEL_SELECT=80
//////////
//operator names
TOK_EQ=int('a')
TOK_NE=int('b')
TOK_LE=int('c')
TOK_GE=int('d')
TOK_LL=int('g')
TOK_GG=int('h')
//////////
//block flags
//BFLAG_LOOP=1
//BFLAG_BREAK=2
//BFLAG_CONTINUE=4
//BFLAG_END_BREAK=8
//BFLAG_END_CONTINUE=16
//struct TResolvedName
//	//PCTObject owner
//	int key
//	PCTObject v
//		%get{return .key}
//		%set{'key':value}
struct TExpression
	int flags_n_args
	int epos0,epos1,caller,user_flags
	PExpression next_v_user
	int v_tid
	PCTObject v_val
	//then it's a list of args
g_desc_TExpression=('flags_n_args','epos0','epos1','caller','user_flags','next_v_user','v_tid','v_val')
//dotting is a function
struct TVarExpression
	int flags_var
	int epos0,epos1,caller,user_flags
	PExpression next_v_user
g_desc_TVarExpression=('flags_var','epos0','epos1','caller','user_flags','next_v_user')
struct TCnsExpression
	int flags_cid
	int epos0,epos1,caller,user_flags
g_desc_TCnsExpression=('flags_cid','epos0','epos1','caller','user_flags')
struct TExprHeader
	int flags
	int epos0,epos1,flags2_caller,user_flags
g_desc_TExprHeader=('flags','epos0','epos1','caller','user_flags')

//EXPR_OFS_VAR=(sizeof(TExprHeader))/sizeof(int)
//EXPR_OFS_NEXT_V_USER=EXPR_OFS_VAR+(sizeof(TResolvedName))/sizeof(int)
EXPR_OFS_NEXT_V_USER=int(g_desc_TExprHeader.length)
EXPR_OFS_VALUE=EXPR_OFS_NEXT_V_USER+1//(sizeof(TExprHeader))/sizeof(int)+1
EXPR_OFS_CALLER=3
EXPR_OFS_USER_FLAGS=4
EXPR_OFS_FUNCTION=int(g_desc_TExpression.length)
EXPR_OFS_ARGS=EXPR_OFS_FUNCTION+1
EXPR_OFS_EPOS=1
VAR_OFS_USER_QUEUE=int(g_desc_TSCCPValue.length)+0
VAR_OFS_STORE_QUEUE=int(g_desc_TSCCPValue.length)+1
VAR_OFS_USER_FLAGS=int(g_desc_TSCCPValue.length)+2
VAR_OFS_VALUE_TIME=int(g_desc_TSCCPValue.length)+3
VAR_OFS_ID=int(g_desc_TSCCPValue.length)+4
VAR_OFS_OWNER=int(g_desc_TSCCPValue.length)+5
VAR_OFS_DEFINING_STORE=int(g_desc_TSCCPValue.length)+6
VAR_OFS_FLATTENING_OWNER=int(g_desc_TSCCPValue.length)+7

//safety space for NULL lisp access
g_ctobject_pool=[0,0,0,0]

inline poolCode(auto a)
	T=typeof(a)
	ret=int(g_ctobject_pool.n)
	if T==TExpression:
		a.v_tid=g_vtid_UNINIT
	else if T==TCnsExpression||T==TVarExpression:
		//nothing
	else
		__error("unsupported expression type @1",T)
	desc=getTypeDescription(T)
	g_ctobject_pool.resize(ret+desc.length)
	for i in crange(desc.length)
		g_ctobject_pool[ret+i]=__dot(a,desc[i])
	return ret

inline poolObject(auto a0)
	a=a0
	T=typeof(a)
	ret=int(g_ctobject_pool.n)
	if T==TDynamicObject:
		a.tid=g_tid_TDynamicObject
	else if T==TFunction:
		a.tid=g_tid_TFunction
	else if T==TCtUniqueEvalQueue:
		a.tid=g_tid_TCtUniqueEvalQueue
	else if T==TSCCPValue:
		//nothing
	else if T==TVariable:
		//nothing
	else if T==TBuiltinType:
		a.tid=g_tid_TBuiltinType
	else if T==TFunctionType:
		a.tid=g_tid_TFunctionType
	else if T==TNameSpace:
		a.tid=g_tid_TNameSpace
	else if T==TAdvancedEpos:
		a.tid=g_tid_TAdvancedEpos
	else
		__error("unsupported object type @1",T)
	desc=getTypeDescription(T)
	g_ctobject_pool.resize(ret+desc.length)
	for i in crange(desc.length)
		g_ctobject_pool[ret+i]=__dot(a,desc[i])
	return ret

inline getTypeDescription(const T)
	if T==TExpression:return g_desc_TExpression
	else if T==TVarExpression:return g_desc_TVarExpression
	else if T==TCnsExpression:return g_desc_TCnsExpression
	else if T==TExprHeader:return g_desc_TExprHeader
	else if T==TFunction:return g_desc_TFunction
	else if T==TSCCPValue:return g_desc_TSCCPValue
	else if T==TVariable:return g_desc_TVariable
	else if T==TCtUniqueEvalQueue:return g_desc_TCtUniqueEvalQueue
	else if T==TFunctionType:return g_desc_TFunctionType
	else if T==TNameSpace:return g_desc_TNameSpace
	else if T==TAdvancedEpos:return g_desc_TAdvancedEpos
	else if T==TBuiltinType:return g_desc_TBuiltinType
	else
		__error("type @1 doesn't have a description",T)

//coulddo: pre-fetched pointer in release mode
inline readPool(iptr p)
	//if g_const_values.n>2:
	//	assert(g_const_values[2].val_bin==1LL)
	return g_ctobject_pool[p]

inline readPoolTyped(iptr p,const T)
	desc=getTypeDescription(T)
	a=T()
	for i in crange(desc.length)
		__dot(a,desc[i])=readPool(p+i)
	return a

inline writePool(iptr p,int a)
	//if g_ctobject_pool.n>241000:
	//	//Writeln(readPool(readPool(240089+EXPR_OFS_ARGS+0)),' ')
	//	if p==readPool(240089+EXPR_OFS_ARGS+0)||p==240089+EXPR_OFS_ARGS+0:
	//		assert(0)
	g_ctobject_pool[p]=a
	//if g_ctobject_pool.n>371:
	//	assert(!!g_ctobject_pool[371])

inline writePoolTyped(iptr p,auto a)
	desc=getTypeDescription(typeof(a))
	for i in crange(desc.length)
		writePool(p+i,__dot(a,desc[i]))
	
g_names_resolved=0
inline call(int id)
	if g_names_resolved:
		id_or_pobj=g_symbols[id].user_slot
		assert(!!id_or_pobj)
	else
		id_or_pobj=id
	pe_func=exprvar(id_or_pobj)
	n0=poolCode(TExpression(){'flags_n_args':int(arguments.length-1)|EFLAG_FCALL})
	g_ctobject_pool.push(pe_func)
	arguments0=arguments
	for i in crange(arguments0.length)
		if i>=1:
			T=typeof(arguments0[i])
			if T!=int:
				__error("call can only take ints, not the @1-th argument, which is @2",i,T)
			else
				g_ctobject_pool.push(arguments0[i])
				assert(!!arguments0[i])
				writePool(arguments0[i]+EXPR_OFS_CALLER,n0)
	writePool(pe_func+EXPR_OFS_CALLER,n0)
	//if Platform.BUILD=="debug":
	//	if g_names_resolved&&id==g_id_store&&va_count==3:
	//		pe_value=readPool(int(n0)+EXPR_OFS_ARGS+1)
	//		assert(0)
	//		if isExpr(pe_value,EFLAG_CTVAL):
	//			if isVariable(readPool(pe_value)&~EFLAG_MASK):
	//				//dot name should never get pulled
	//				assert(0)
	return int(n0)

auto vcall(int id, int[] as)
	if g_names_resolved:
		id_or_pobj=g_symbols[id].user_slot
		assert(!!id_or_pobj)
	else
		id_or_pobj=id
	pe_func=exprvar(id_or_pobj)
	n0=poolCode(TExpression(){'flags_n_args':int(as.n)|EFLAG_FCALL})
	g_ctobject_pool.push(pe_func)
	g_ctobject_pool.push(as)
	foreach pa in as
		assert(!!pa)
		writePool(pa+EXPR_OFS_CALLER,n0)
	writePool(pe_func+EXPR_OFS_CALLER,n0)
	return int(n0)

auto indcall(int[] as)
	assert(as.n>0)
	n0=poolCode(TExpression(){'flags_n_args':int(as.n-1)|EFLAG_FCALL})
	g_ctobject_pool.push(as)
	foreach pa in as
		assert(!!pa)
		writePool(pa+EXPR_OFS_CALLER,n0)
	return int(n0)

inline exprcns(int cid)
	//n0=g_ctobject_pool.n
	//g_ctobject_pool.push(EFLAG_CONST+cid)
	return int(poolCode(TCnsExpression(){'flags_cid':EFLAG_CONST+cid}))

inline exprctval(PCTObject ctval)
	assert(!!ctval)
	return int(poolCode(TCnsExpression(){'flags_cid':EFLAG_CTVAL+ctval}))

inline exprstr(int id)
	return int(poolCode(TCnsExpression(){'flags_cid':EFLAG_STRING+id}))

inline exprvar(int vid)
	return int(poolCode(TVarExpression(){'flags_var':EFLAG_VARIABLE|vid}))

inline expriptr(iptr val)
	assert(iptr(int(val))==val)
	return exprcns(getid_const(const_type(CTYPE_INT,Util.bitSize()),i64(val)))

auto fillepos(PExpression pe,int ep0,int ep1)
	if !readPool(pe+1):
		flags=readPool(pe)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			n_args=flags&~EFLAG_MASK
			for i=-1:n_args-1
				fillepos(readPool(pe+EXPR_OFS_ARGS+i),ep0,ep1)
		writePool(pe+1,ep0)
		writePool(pe+2,ep1)
	return pe

auto wipeepos(PExpression pe)
	flags=readPool(pe)
	if (flags&EFLAG_MASK)==EFLAG_FCALL:
		n_args=flags&~EFLAG_MASK
		for i=-1:n_args-1
			wipeepos(readPool(pe+EXPR_OFS_ARGS+i))
	writePool(pe+1,0)
	writePool(pe+2,0)
	return pe

auto makevar(PCTObject pf_owner)
	assert(!!pf_owner)
	ret=poolObject(TVariable(){'tid':g_vtid_UNINIT,'owner_function':pf_owner,'id':g_tempvar_id})
	if DEBUG_TRAP_VARIABLE:
		assert(ret!=DEBUG_TRAP_VARIABLE)
	return ret

inline isExpr(PExpression pe,int flag)
	return (readPool(pe)&EFLAG_MASK)==flag

auto getAsFunction(PCTObject pobj0)
	pobj=pobj0
	if !pobj:return 0
	if readPool(pobj)==g_vtid_CTVAL:
		pobj=readPool(pobj+1)
		if !pobj:return 0
		if readPool(pobj)==g_tid_TFunction:
			return pobj
	if readPool(pobj)==g_tid_TFunction:
		return pobj
	return 0
	
auto getExprFunction(PExpression pe)
	assert(isExpr(pe,EFLAG_FCALL))
	return getAsFunction(getExprValueAs(readPool(pe+EXPR_OFS_FUNCTION),g_vtid_CTVAL))

inline getBuiltin(int fid)
	return readPool(g_symbols[fid].user_slot+1)

inline getVariable(PExpression pe)
	pobj=readPool(pe)
	assert((pobj&EFLAG_MASK)==EFLAG_VARIABLE)
	pobj&=~EFLAG_MASK
	//pobj=readPool(pe+EXPR_OFS_VAR)
	//if pobj&&isVariable(pobj):
	//	return pobj
	//return 0
	return pobj

auto getExprValue(PExpression pe)
	flags=readPool(pe)
	switch flags&EFLAG_MASK{
	case EFLAG_CONST:
		return TSCCPValue(){'tid':g_vtid_CNS,'val':(flags&~EFLAG_MASK)}
	case EFLAG_CTVAL:
		//if !(flags&~EFLAG_MASK):
		//	Writeln('<<<!!!>>>')
		//	g_id_errored=1
		return TSCCPValue(){'tid':g_vtid_CTVAL,'val':(flags&~EFLAG_MASK)}
	case EFLAG_FCALL:
		return readPoolTyped(pe+EXPR_OFS_VALUE,TSCCPValue)
	case EFLAG_STRING:
		return TSCCPValue(){'tid':g_vtid_STR,'val':(flags&~EFLAG_MASK)}
	case EFLAG_VARIABLE:
		pobj=getVariable(pe)
		//if isVariable(pobj):
		return readPoolTyped(pobj,TSCCPValue)
		//return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	assert(0)
	return TSCCPValue(){'tid':g_vtid_UNINIT}

auto getExprValueAs(PExpression pe,int vtid)
	val0=getExprValue(pe)
	if val0.tid==g_vtid_UNINIT:return 0
	if val0.tid==vtid:
		if vtid==g_vtid_CNS:
			cns=Util.ctNumber(val0.val)
			if (cns.type&CTYPE_MASK)==CTYPE_INT||(cns.type&CTYPE_MASK)==CTYPE_UINT:
				return int(cns.val_bin)
		if vtid==g_vtid_STR:
			return val0.val
		if vtid==g_vtid_CTVAL:
			return val0.val
		assert(0)
	return 0

auto getCcnv(PCTObject pobjfn)
	pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	return getExprValueAs(readPool(pe_decl+(EXPR_OFS_ARGS)+0),g_vtid_STR)

//tm_insertCallAt=tnew("insertCallAt")
auto insertCallAt(PExpression pecall,PExpression pesrc,function(PExpression):PExpression fmakecall)
	//coulddo: more efficient arg searching
	//tbegin(tm_insertCallAt)
	nargs_caller=readPool(pecall)
	assert((nargs_caller&EFLAG_MASK)==EFLAG_FCALL)
	nargs_caller&=~EFLAG_MASK
	if pesrc<=0:
		arg_id=~pesrc
	else
		arg_id=-2
		for i=-1:nargs_caller-1
			if readPool(pecall+EXPR_OFS_ARGS+i)==pesrc:
				arg_id=i
				break
		if arg_id<-1:
			assert(0)
			//tend(tm_insertCallAt)
			return 0
	assert(u32(arg_id)<u32(nargs_caller)||arg_id==-1)
	peold=readPool(pecall+EXPR_OFS_ARGS+arg_id)
	epos0=readPool(peold+1)
	epos1=readPool(peold+2)
	writePool(peold+EXPR_OFS_CALLER,0)
	penew=fmakecall(peold)
	writePool(penew+EXPR_OFS_CALLER,pecall)
	fillepos(penew,epos0,epos1)
	//writePool(penew+1,epos0)
	//writePool(penew+2,epos1)
	//Writeln(penew,' ',arg_id)
	writePool(pecall+EXPR_OFS_ARGS+arg_id,penew)
	//tend(tm_insertCallAt)
	return penew
	
CLONE_WIPE_TO_UNREACHED=1
//CLONE_WIPE_TO_RESOLVED=2
//CLONE_UNRESOLVED=2
//CLONE_REBIND_CONTEXT=2
CLONE_VARS=4
CLONE_KEEP_VAR_IDS=8
CLONE_EXPR_IS_CALLED_BY_CLONE_FUNCTION=16
auto cloneExprEx(PExpression pe,PCTObject[PCTObject] var_map,int flags)
	n=0
	as=int[].NULL
	pe_flags=g_ctobject_pool[pe]
	switch(pe_flags&EFLAG_MASK){
	case EFLAG_CONST,EFLAG_STRING,EFLAG_CTVAL:
		n=int(g_desc_TCnsExpression.length)
		break
	case EFLAG_VARIABLE:
		n=int(g_desc_TVarExpression.length)
		assert(n>1)
		break
	case EFLAG_FCALL:
		n=int(g_desc_TExpression.length)
		if isBuiltin(pe,g_id_function)&&!(flags&CLONE_EXPR_IS_CALLED_BY_CLONE_FUNCTION):
			if readPool(pe+EXPR_OFS_VALUE)==g_vtid_CTVAL:
				pobjfn_cloned=cloneFunctionEx(readPool(pe+EXPR_OFS_VALUE+1),var_map,flags)
				return readPool(pobjfn_cloned+FUNCTION_OFS_PEDECL)
		nargs=g_ctobject_pool[pe]
		as=new PExpression[nargs+1]
		for i=-1:nargs-1
			as[i+1]=cloneExprEx(g_ctobject_pool[pe+EXPR_OFS_ARGS+i],var_map,flags&~CLONE_EXPR_IS_CALLED_BY_CLONE_FUNCTION)
		//as=[cloneExprEx(g_ctobject_pool[pe+EXPR_OFS_ARGS+i],var_map,flags&~CLONE_EXPR_IS_CALLED_BY_CLONE_FUNCTION) for i=-1:nargs-1]
		break
	}
	n0=int(g_ctobject_pool.n)
	g_ctobject_pool.resize(n0+n)
	for i=0:n-1
		g_ctobject_pool[n0+i]=g_ctobject_pool[pe+i]
	if as:
		g_ctobject_pool.push(as)
		//caller fix
		foreach pearg in as
			writePool(pearg+EXPR_OFS_CALLER,n0)
	if flags&CLONE_VARS:
		if (pe_flags&EFLAG_MASK)==EFLAG_VARIABLE:
			//coulddo: when cloning nested function, pf_only_clone_under should cover all nested levels
			pv_original=getVariable(pe)
			pf_owner_original=readPool(pv_original+VAR_OFS_OWNER)
			pf_owner_new=var_map[pf_owner_original]
			if pf_owner_new>0:
				//only clone the owner-known variables
				pv_cloned=var_map[pv_original]
				if !pv_cloned:
					if DEBUG_TRAP_VARIABLE:
						if int(g_ctobject_pool.n)==DEBUG_TRAP_VARIABLE:
							Writeln(dumpExpr(readPool(pe+EXPR_OFS_CALLER),__zero(fcolorer_callback)))
							Writeln(pv_original)
							assert(0)
					pv_cloned=makevar(pf_owner_new)
					vid0=readPool(pv_original+VAR_OFS_ID)
					if !(flags&CLONE_KEEP_VAR_IDS):
						vid0=gettempid(vid0)
					writePool(pv_cloned+VAR_OFS_ID,vid0)
					writePool(pv_cloned+VAR_OFS_USER_FLAGS,readPool(pv_original+VAR_OFS_USER_FLAGS))
					var_map[pv_original]=pv_cloned
				//writePool(n0+EXPR_OFS_VAR,pv_cloned)
				writePool(n0,EFLAG_VARIABLE+pv_cloned)
		else if isBuiltin(pe,g_id_store):
			pevar=readPool(pe+EXPR_OFS_ARGS)
			if isExpr(pevar,EFLAG_VARIABLE):
				pv=getVariable(pevar)
				if pv&&readPool(pv+VAR_OFS_DEFINING_STORE)==pe:
					pv_cloned=var_map[pv]
					if pv_cloned:
						writePool(pv_cloned+VAR_OFS_DEFINING_STORE,n0)
	if flags&CLONE_WIPE_TO_UNREACHED:
		switch(pe_flags&EFLAG_MASK){
		case EFLAG_VARIABLE:
			writePool(n0+EXPR_OFS_NEXT_V_USER,0)
			writePool(n0+EXPR_OFS_USER_FLAGS,0)
			break
		case EFLAG_FCALL:
			writePool(n0+EXPR_OFS_NEXT_V_USER,0)
			writePool(n0+EXPR_OFS_USER_FLAGS,0)
			writePoolTyped(n0+EXPR_OFS_VALUE,TSCCPValue(){'tid':g_vtid_UNINIT})
			break
		}
	//linked list stuff has to be cleared
	return n0

auto dfsExprEx(PExpression pe,PCTObject pf_owner,function(PExpression,PCTObject):int fcallback)
	if !fcallback(pe,pf_owner):return
	flags=readPool(pe)
	if (flags&EFLAG_MASK)==EFLAG_FCALL:
		pf_owner_recurse=pf_owner
		if isBuiltin(pe,g_id_function):
			pf_owner_recurse=getExprValueAs(pe,g_vtid_CTVAL)
		nargs=(flags&~EFLAG_MASK)
		for i=-1:nargs-1
			dfsExprEx(readPool(pe+EXPR_OFS_ARGS+i),pf_owner_recurse,fcallback)

auto dfsExpr(PExpression pe,function(PExpression):int fcallback)
	if !fcallback(pe):return
	flags=readPool(pe)
	if (flags&EFLAG_MASK)==EFLAG_FCALL:
		nargs=(flags&~EFLAG_MASK)
		for i=-1:nargs-1
			dfsExpr(readPool(pe+EXPR_OFS_ARGS+i),fcallback)

inline setUserFlag(PExpression pe,int flag)
	if EXPR_OFS_USER_FLAGS!=VAR_OFS_USER_FLAGS:
		__error("EXPR_OFS_USER_FLAGS and VAR_OFS_USER_FLAGS have to be equal, but @1!=@2",EXPR_OFS_USER_FLAGS,VAR_OFS_USER_FLAGS)
	writePool(pe+EXPR_OFS_USER_FLAGS,readPool(pe+EXPR_OFS_USER_FLAGS)|flag)

inline unsetUserFlag(PExpression pe,int flag)
	if EXPR_OFS_USER_FLAGS!=VAR_OFS_USER_FLAGS:
		__error("EXPR_OFS_USER_FLAGS and VAR_OFS_USER_FLAGS have to be equal, but @1!=@2",EXPR_OFS_USER_FLAGS,VAR_OFS_USER_FLAGS)
	writePool(pe+EXPR_OFS_USER_FLAGS,readPool(pe+EXPR_OFS_USER_FLAGS)&~flag)

inline testUserFlag(PExpression pe,int flag)
	if EXPR_OFS_USER_FLAGS!=VAR_OFS_USER_FLAGS:
		__error("EXPR_OFS_USER_FLAGS and VAR_OFS_USER_FLAGS have to be equal, but @1!=@2",EXPR_OFS_USER_FLAGS,VAR_OFS_USER_FLAGS)
	return (readPool(pe+EXPR_OFS_USER_FLAGS)&flag)

auto cloneFunctionEx(PCTObject pobjfn,PCTObject[PCTObject] var_map,int flags)
	//we're assuming that the cloned function is unreached
	fn=readPoolTyped(pobjfn,TFunction)
	//Writeln('fn.pe_decl before cloning: ',dumpExpr(fn.pe_decl,fcolor_numerical))
	//Writeln('***** ',readPool(240089+EXPR_OFS_ARGS+0),' ',readPool(readPool(240089+EXPR_OFS_ARGS+0)),' ',g_const_values)
	ret=poolObject(fn)
	fn.first_function_user=0
	fn.value_time=0
	//pe_decl_caller=readPool(fn.pe_decl+EXPR_OFS_CALLER)
	var_map[pobjfn]=ret
	pe_decl_cloned=cloneExprEx(fn.pe_decl,var_map,flags|CLONE_EXPR_IS_CALLED_BY_CLONE_FUNCTION)
	//Writeln('fn.pe_decl: ',dumpExpr(fn.pe_decl,__zero(fcolorer_callback)))
	//Writeln('pe_decl_cloned: ',dumpExpr(pe_decl_cloned,__zero(fcolorer_callback)))
	//pe_decl_old=fn.pe_decl
	//Writeln(parser.Canonical.dumpExpr(pe_decl_cloned,function(){return -1}))
	fn.pe_decl=pe_decl_cloned
	fn.id_name=0
	//if fn.scope:fn.scope=ONew()
	n_args=(readPool(pe_decl_cloned)&~EFLAG_MASK)
	fn.code=readPool(pe_decl_cloned+(EXPR_OFS_ARGS+n_args-1))
	//Writeln(dumpObject(var_map[fn.pvar_return]),' <- ',dumpObject(fn.pvar_return))
	fn.pvar_return=var_map[fn.pvar_return]
	fn.flags&=~(FFLAG_NAME_LOOKUP_READY|FFLAG_CGEN_QUEUED)
	//param slots
	p_param_values=int(g_ctobject_pool.n)
	fn.pparam_value_slots=p_param_values
	assert(g_desc_TSCCPValue.length==2)
	n_funcargs=(n_args-2)>>1
	g_ctobject_pool.resize(p_param_values+n_funcargs*3)
	all_pe_ldparam=new PExpression[n_funcargs]
	n_found=0
	ffind_ldparams=function(PExpression pe){
		if n_found>=n_funcargs:return 0
		if isBuiltin(pe,g_id_ldparam):
			paramid=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_CNS)
			if all_pe_ldparam[paramid]:
				//_deriv case
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if !isBuiltin(pecaller,g_id_store):return 1
			if Platform.BUILD=="debug":
				if all_pe_ldparam[paramid]:
					Writeln("it was: "+dumpExpr(all_pe_ldparam[paramid],fcolor_abbrv_blocks),' ',all_pe_ldparam[paramid])
					Writeln("it is : "+dumpExpr(pe,fcolor_abbrv_blocks),' ',pe)
					Writeln("function: "+dumpExpr(pe_decl_cloned,fcolor_reach_eval))
			assert(!all_pe_ldparam[paramid])
			all_pe_ldparam[paramid]=pe
			n_found++
			return 1
		return 1
	}
	dfsExpr(pe_decl_cloned,ffind_ldparams)
	for i=0:n_funcargs-1
		if Platform.BUILD=="debug":
			if !all_pe_ldparam[i]:
				Writeln("param id: "+string(i))
				Writeln("function: "+dumpExpr(pe_decl_cloned,fcolor_reach_eval))
		assert(!!all_pe_ldparam[i])
		writePool(p_param_values+i*3,g_vtid_UNINIT)
		writePool(p_param_values+i*3+2,all_pe_ldparam[i])
	writePoolTyped(ret,fn)
	writePoolTyped(pe_decl_cloned+EXPR_OFS_VALUE,TSCCPValue(){'tid':g_vtid_CTVAL,'val':ret})
	//__block the two versions of declaration
	//Writeln(parser.Canonical.dumpExpr(pe_decl_caller,function(){return -1}))
	//Writeln(parser.Canonical.dumpExpr(pe_decl_caller,function(){return -1}))
	//nargs_caller=readPool(pe_decl_caller)
	//assert((nargs_caller&EFLAG_MASK)==EFLAG_FCALL)
	//nargs_caller&=~EFLAG_MASK
	//for i=0:nargs_caller-1
	//	if readPool(pe_decl_caller+EXPR_OFS_ARGS+i)==fn.pe_decl:
	//		writePool(pe_decl_caller+EXPR_OFS_ARGS+i,pe_block)
	//Writeln(parser.Canonical.dumpExpr(pe_block,function(){return -1}))
	return ret

auto cloneExpr(PExpression pe)
	return cloneExprEx(pe,new PCTObject[PCTObject], g_names_resolved?CLONE_WIPE_TO_UNREACHED:0)

g_in_code_gen=0
auto setnop(PExpression pe)
	//this one is safer in that pe args remain enumerable
	assert(!g_in_code_gen)
	insertCallAt(pe,0,function(PExpression pe){return exprvar(g_symbols[g_id_nop].user_slot)})
	writePool(pe,EFLAG_FCALL)

/////////////////////////////////////////////
//compile-time values
//todo: improve the memory layout later
CTOBJ_NUMBER=0x40000000
CTOBJ_STRING=0x80000000
CTOBJ_TYPE_MASK=0xC0000000
struct TDynamicObject
	int tid,oid
g_tid_TDynamicObject=getid("TDynamicObject")

g_shared_hash=new CSharedMemberHash
inline readGlobalI2Hash(int2 key)
	return g_shared_hash[key]

inline writeGlobalI2Hash(int2 key,PCTObject value)
	g_shared_hash[key]=value

g_epos_hash=new CSharedMemberHash
inline readEPosHash(int2 key)
	return g_epos_hash[key]

inline writeEPosHash(int2 key,PCTObject value)
	g_epos_hash[key]=value

/////////////////////////////////////////////////////////////
//CCNV_NORMAL=0
//CCNV_INLINE=1
//CCNV_IMPORTED=2
//CCNV_CLASS=3
//CCNV_STRUCT=4
FFLAG_SPECIAL=1
FFLAG_BUILTIN_HACK=2
//FFLAG_TYPE=2
FFLAG_C_HEADER_INCLUDED=4
FFLAG_STATEMENT_HOST=8
FFLAG_ARITHMETIC=16
FFLAG_EXPORTED=32
FFLAG_NAME_LOOKUP_READY=64
FFLAG_LAMBDA_NEEDS_CONTEXT=128
FFLAG_LAMBDA_NEEDS_PARENT_POINTER=256
FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG=512
FFLAG_RC_HAS_SIDE_EFFECT=1024
FFLAG_IMPORTED=2048
FFLAG_IS_TUPLE=4096
FFLAG_IS_SYMDERIV_TEMP=8192
FFLAG_IS_SYMDERIV=16384
FFLAG_DEPENDS_ON_OTHER_CODE=32768//these are only evaled at the end of each main sccp iteration
FFLAG_LAMBDA_NEEDS_RTTI=1<<16
FFLAG_IS_FUNCTION=1<<17
FFLAG_HAS_FPTR_TAKEN=1<<18
FFLAG_IS_PURE=1<<19
FFLAG_IS_PRELIVE=1<<20
FFLAG_IS_PARALLEL=1<<21
FFLAG_IS_EMPTY_CTOR=1<<22
FFLAG_IS_EMPTY_CTOR_TESTED=1<<23
FFLAG_LAMBDA_LEAKED=1<<24
FFLAG_IS_ARRAY_CLASS=1<<25
FFLAG_TEMP_IMPURE=0x80000000
FFLAG_TEMP_UNFLATTENABLE=0x80000000
FFLAG_CGEN_QUEUED=0x80000000
//////////
FFLAG_BUILTIN=FFLAG_SPECIAL|FFLAG_ARITHMETIC|FFLAG_BUILTIN_HACK
FFLAG_NOT_USER_DEFINED=FFLAG_BUILTIN|FFLAG_IMPORTED
//////////
FUNCTION_OFS_FLAGS=1
FUNCTION_OFS_FUSER=2
FUNCTION_OFS_VALUE_TIME=3
FUNCTION_OFS_PVAR_RETURN=4
FUNCTION_OFS_PLAMBDA_VARS=5
FUNCTION_OFS_NLAMBDA_VARS=6
FUNCTION_OFS_PCALL_GRAPH_EDGES=7
FUNCTION_OFS_NCALL_GRAPH_EDGES=8
FUNCTION_OFS_PINV_CALL_GRAPH_EDGES=9
FUNCTION_OFS_NINV_CALL_GRAPH_EDGES=10
FUNCTION_OFS_FINALIZER=11
FUNCTION_OFS_PEDECL=12
FUNCTION_OFS_CODE=13
FUNCTION_OFS_NEST_DEPTH=14
FUNCTION_OFS_NAME=15
FUNCTION_OFS_PPARAM_VALUE_SLOTS=16
FUNCTION_OFS_ONREACH=17
FUNCTION_OFS_ONEVAL=18
FUNCTION_OFS_ONCGEN=19
FUNCTION_OFS_TEMP_SLOT=20
FUNCTION_OFS_PMEMBER_LIST=21
FUNCTION_OFS_NMEMBER_LIST=22
FUNCTION_OFS_T_RAW_FUNCTION_TYPE=23
FUNCTION_OFS_RETURN_LABEL_CACHE=24
FUNCTION_OFS_TEMPLATE=25
FUNCTION_OFS_TEMPLATE_EPOS0=26
FUNCTION_OFS_TEMPLATE_EPOS1=27
FUNCTION_OFS_P_FULL_CALLER_LIST=28
struct TFunction
	int tid
	int flags
	int first_function_user
	int value_time
	PCTObject pvar_return
	int plambda_vars,nlambda_vars
	int pcall_graph_edges,ncall_graph_edges
	int pinv_call_graph_edges,ninv_call_graph_edges
	PCTObject fn_finalizer
	PExpression pe_decl
	PExpression code
	int nest_depth
	int id_name
	int pparam_value_slots
	PCTObject obj_onreach,obj_oneval,obj_oncgen
	int temp_slot
	int pmember_list,nmember_list
	PCTObject t_raw_function_type
	int return_label_cache
	PCTObject pf_template
	int template_epos0,template_epos1
	int p_full_caller_list //this is transient
g_tid_TFunction=getid("TFunction")
g_desc_TFunction=('tid','flags','first_function_user','value_time','pvar_return','plambda_vars','nlambda_vars','pcall_graph_edges','ncall_graph_edges','pinv_call_graph_edges','ninv_call_graph_edges','fn_finalizer','pe_decl','code','nest_depth','id_name','pparam_value_slots','obj_onreach','obj_oneval','obj_oncgen','temp_slot','pmember_list','nmember_list','t_raw_function_type','return_label_cache','pf_template','template_epos0','template_epos1','p_full_caller_list')
g_value_time=1
//struct TCompilerFunction
//	int tid
//	int cbid
//g_tid_TCompilerFunction=getid("TCompilerFunction")
struct TBuiltinType
	int tid
	int t
g_tid_TBuiltinType=getid("TBuiltinType")
g_desc_TBuiltinType=('tid',"t")
struct TFunctionType
	int tid
	int t_ret
	int n_args
	int p_arg_types
	//////////////
	int flags
g_tid_TFunctionType=getid("TFunctionType")
g_desc_TFunctionType=('tid','t_ret','n_args','p_arg_types','flags')
struct TCtUniqueEvalQueue
	int tid
	PExpression pe
	PCTObject next
g_tid_TCtUniqueEvalQueue=getid("TCtUniqueEvalQueue")
g_desc_TCtUniqueEvalQueue=('tid','pe','next')
struct TNameSpace
	int tid
	int n_members
g_tid_TNameSpace=getid("TNameSpace")
g_desc_TNameSpace=('tid','n_members')
struct TAdvancedEpos
	int tid
	//mode 1
	int epos0,epos1
	//mode 2, with 0x80000000 tag
	//PCTObject epos_function
	//PCTObject epos_line
	//mode 3, same 0x80000000 tag
	//PCTObject epos_parent//the original calling line
	//PCTObject pobj_inline_function//the function
	//could merge 2 and 3
g_tid_TAdvancedEpos=getid("TAdvancedEpos")
g_desc_TAdvancedEpos=('tid','epos0','epos1')
//struct TEposCallstack
//	int tid
//g_tid_TEposCallstack=getid("TEposCallstack")
//create variables as bots get created
//a multi-state class
struct TSCCPValue
	int tid
	PCTObject val
g_desc_TSCCPValue=('tid','val')
struct TVariable
	//TSCCPValue current_value
	int tid
	PCTObject val
	PExpression first_v_user
	PExpression first_v_store
	int user_flags
	int value_time
	int id
	PCTObject owner_function
	PExpression pe_defining_store
	////////////////////
	PCTObject pv_flattening_owner
g_desc_TVariable=('tid','val','first_v_user','first_v_store','user_flags','value_time','id','owner_function','pe_defining_store','pv_flattening_owner')

//g_vtid_UNREACHED=getid("TSCCPValue_UNREACHED") //where val is 0
g_vtid_UNINIT=getid("TSCCPValue_UNINIT") //where val is 0
g_vtid_RTVAR=getid("TSCCPValue_RTVAR") //where val is the type
g_vtid_CNS=getid("TSCCPValue_CNS") //where val is a const id
g_vtid_STR=getid("TSCCPValue_STR") //where val is an id
g_vtid_CTVAL=getid("TSCCPValue_CTVAL") //where val is a PCTObject
g_expr_errored=new int[PExpression]

inline isVariable(PCTObject pobj)
	if !pobj:return 0
	vtid=readPool(pobj)
	return vtid>=g_vtid_UNINIT&&vtid<=g_vtid_CTVAL

inline isFunction(PCTObject pobj)
	if !pobj:return 0
	vtid=readPool(pobj)
	return vtid==g_tid_TFunction

/////////////////////////////////////////////////
struct TCTUniqueItem
	int[] key
	iptr hash
	PCTObject value

class TTraitCTUnique
	TKey=int[]
	inline getHash(int id)
		return g_ctunique_items[id].hash
	inline computeHash(int[] key)
		return iptr(key.__hash__())
	inline isKeyEqual(int id,int[] key)
		key0=g_ctunique_items[id].key
		return key0.__compare__(key)==0
	inline createNew(int[] key,iptr hash)
		ret=int(g_ctunique_items.n)
		g_ctunique_items.push(TCTUniqueItem(){'key':key,'hash':hash})
		return ret

g_ctunique_items=[TCTUniqueItem()]
g_ctunique_provider=new CUniqueIDProvider(TTraitCTUnique)

auto ctUnique(int[] key)
	return g_ctunique_items[g_ctunique_provider._find(1,key)].value

auto set_ctUnique(int[] key,int value)
	g_ctunique_items[g_ctunique_provider._find(1,key)].value=value

STDTYPE_BOX=0
STDTYPE_ARRAY=1
STDTYPE_STRING=2
STDTYPE_VARIANT=3
STDFN_FUNCTIONAL_OR=4
STDTYPE_FUNCTION_IMPL=5
STDFN_MAKE_FUNCTION=6
STDFN_MAKE_STRING=7
STDTYPE_MAP=8
STDFN_CLONE=9
g_builtin_types=new PCTObject[CTYPE_COUNT]
//g_string_type=(PCTObject)0
//g_variant_type=(PCTObject)0

auto getBuiltinType(int ctype)
	ret=g_builtin_types[ctype]
	if !ret:
		ret=poolObject(TBuiltinType(){"t":ctype})
		g_builtin_types[ctype]=ret
	return ret

inline getFFlag(PCTObject pobjfn)
	return readPool(pobjfn+FUNCTION_OFS_FLAGS)

auto setFFlag(PCTObject pobjfn,int flag)
	//if flag&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
	//if flag&FFLAG_LAMBDA_NEEDS_CONTEXT:
	//	if readPool(pobjfn+FUNCTION_OFS_NAME)==getid("glClear"):
	//		assert(0)
	writePool(pobjfn+FUNCTION_OFS_FLAGS,readPool(pobjfn+FUNCTION_OFS_FLAGS)|flag)

///////////////////////////////
inline tisbuiltin(PCTObject t)
	return t&&readPool(t)==g_tid_TBuiltinType

inline tisclass(PCTObject t)
	if t&&readPool(t)==g_tid_TFunction:
		id=getCcnv(t)
		if id==g_id_class||id==g_id_struct:
			return 1
	return 0

inline tisrealclass(PCTObject t)
	return t&&readPool(t)==g_tid_TFunction&&getCcnv(t)==g_id_class

inline tisstruct(PCTObject t)
	return t&&readPool(t)==g_tid_TFunction&&getCcnv(t)==g_id_struct

inline tistuple(PCTObject t)
	return tisstruct(t)&&(getFFlag(t)&FFLAG_IS_TUPLE)

inline tisrawfunction(PCTObject t)
	return t&&readPool(t)==g_tid_TFunctionType

inline tisfunction(PCTObject t)
	return tisstruct(t)&&(getFFlag(t)&FFLAG_IS_FUNCTION)

inline tisarray(PCTObject t)
	return tisstruct(t)&&(getFFlag(t)&FFLAG_IS_ARRAY_CLASS)

inline objistype(PCTObject t)
	return tisbuiltin(t)||tisclass(t)

auto tisctype(PCTObject t,int std_mask)
	if !t||readPool(t)!=g_tid_TBuiltinType:return 0
	ct=readPool(t+1)
	ct_mask=ct&CTYPE_MASK
	return ct_mask==std_mask

auto isBuiltinR(PExpression pe,int id_builtin)
	if (readPool(pe)&EFLAG_MASK)!=EFLAG_FCALL:return 0
	auto pe_func=readPool(pe+EXPR_OFS_FUNCTION)
	auto fid=0
	if isExpr(pe_func,EFLAG_VARIABLE):
		fid=getVariable(pe_func)
	return fid==id_builtin

inline getRawFunctionType(PCTObject pobj_ftype)
	assert(tisfunction(pobj_ftype))
	return readPool(pobj_ftype+FUNCTION_OFS_T_RAW_FUNCTION_TYPE)
	
auto dumpType(PCTObject t)
	if t&&tisbuiltin(t):
		ct=readPool(t+1)
		if ct==CTYPE_POINTER:
			return "__pointer"
		if ct==CTYPE_TYPED_NULL:
			assert(0)
			return "NULL"
		sret=""
		switch ct&CTYPE_MASK{
		case CTYPE_INT:
			sret="i"
			break
		case CTYPE_UINT:
			sret="u"
			break
		case CTYPE_FLOAT:
			sret="f"
			break
		}
		return sret+string(((ct&~CTYPE_MASK)+1)*8)
	if tisfunction(t):
		ft=readPoolTyped(getRawFunctionType(t),TFunctionType)
		s=new string
		s.push("function(")
		for i=0:ft.n_args-1
			if i:s.push(',')
			s.push(dumpType(readPool(ft.p_arg_types+i)))
		s.push(')')
		if ft.t_ret:
			s.push(':')
			s.push(dumpType(ft.t_ret))
		return s
	if tisclass(t):
		id_name=readPool(t+FUNCTION_OFS_NAME)
		if id_name:
			return getIdString(id_name)
		else
			return dumpFunction(t)
	//assert(0)
	return "<invalid-type-"+formatNumber(t,{base:16,align:8})+">"

auto dumpFunction(PCTObject pobjfn)
	pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	n_args=(readPool(pe_decl)&~EFLAG_MASK)
	id_ccnv=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+0),g_vtid_STR)
	assert(!!id_ccnv)
	s=new string
	s.push(getIdString(id_ccnv))
	id_name=readPool(pobjfn+FUNCTION_OFS_NAME)
	if id_name:
		s.push(' ')
		s.push(getIdString(id_name))
	s.push('(')
	for i=1:2:n_args-2
		if i>1:
			s.push(',')
		pe_type=readPool(pe_decl+EXPR_OFS_ARGS+i+0)
		id_arg=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+i+1),g_vtid_STR)
		val=getExprValue(pe_type)
		if val.tid==g_vtid_CTVAL:
			if val.val==pobjfn:
				s.push("__this_type__")
			else
				s.push(dumpType(val.val))
		else if val.tid==g_vtid_STR:
			s.push(getIdString(val.val))
		if id_arg:
			s.push(' ')
			s.push(getIdString(id_arg))
	s.push(')')
	return s
	
//g_hex="0123456789ABCDEF"
auto genChar(string s,int ch)
	if ch=='\\':
		s.push('\\')
		s.push('\\')
	else if ch=='\r':
		s.push('\\')
		s.push('r')
	else if ch=='\n':
		s.push('\\')
		s.push('n')
	else if ch=='\t':
		s.push('\\')
		s.push('t')
	else if ch=='"':
		s.push('\\')
		s.push('"')
	else if ch>=32&&ch<127:
		s.push(char(ch))
	else
		s.push('\\')
		//s.push('x')
		//s.push(g_hex[(ch>>4)&15])
		//s.push(g_hex[ch&15])
		s.push(char('0'+(ch>>6)))
		s.push(char('0'+((ch>>3)&7)))
		s.push(char('0'+(ch&7)))

auto genString(string s0)
	s=new string
	foreach ch0 in s0
		ch=int(u8(ch0))
		//if ch>=0:
		genChar(s,ch)
	return s

auto dumpConst(TConstValue val)
	if val.type==CTYPE_TYPED_NULL:
		return "NULL:"+dumpType(PCTObject(val.val_bin))
	if val.type==CTYPE_POINTER&&!val.val_bin:
		return "NULL"
	if (val.type&CTYPE_MASK)==CTYPE_FLOAT:
		if (val.type&~CTYPE_MASK)==(32>>3)-1:
			return string(__int_as_float(int(val.val_bin)))+"f"
		else
			return string(__longlong_as_double(val.val_bin))
	if (val.type&~CTYPE_MASK)<=(32>>3)-1:
		if int(val.val_bin)<32768&&int(val.val_bin)>=-32768&&((val.type&CTYPE_MASK)==CTYPE_INT)||u32(int(val.val_bin))<32768u&&((val.type&CTYPE_MASK)==CTYPE_UINT):
			sret=string(int(val.val_bin))
		else
			sret="0x"+formatNumber(u32(int(val.val_bin)),{align:8,base:16})
	else
		sret="0x"+formatNumber(u64(val.val_bin),{align:16,base:16})+"LL"
	if (val.type&CTYPE_MASK)==CTYPE_UINT:
		return sret+"u"
	return sret

auto dump_getObjectName(PCTObject pobj0)
	pobj=pobj0
	for(;;)
		if !pobj:return getid("<NULL>")
		if isVariable(pobj):
			vid=readPool(pobj+VAR_OFS_ID)
			if vid:return vid
			if readPool(pobj)==g_vtid_CTVAL:
				pobj=readPool(pobj+1)
				continue
		tid=readPool(pobj)
		if tid==g_tid_TFunction:
			fid=readPoolTyped(pobj,TFunction).id_name
			if fid:return fid
		if tid==g_tid_TBuiltinType:
			return getid(dumpType(pobj))
		return getid("<"+getIdString(readPool(pobj))+"-"+string(pobj)+">")

g_id_ldparam=getid("__ldparam")
g_id_store=getid("__store")
g_id_block=getid("__block")
g_id_blockex=getid("__blockex")
g_id_cast=getid("__cast")
g_id_return=getid("return")
g_id_return_=getid("$return_")//the $ is significant - it's used in tests
//g_id_extra_return=getid("__extra_return")
//g_id_get_extra_return=getid("__get_extra_return")
g_id_function=getid("function")
g_id_function_type=getid("__function_type")
g_id_dtor_hack_ccnv=getid("__destructor")
g_id_ftype_raw=getid("__ftype_raw")
g_id_ptr_fn=getid("ptr_fn")
g_id_ptr_this=getid("ptr_this")
g_id_c_function=getid("__c_function")
g_id_C_return=getid("__c_return")
g_id_assert_ctval=getid("__assert_ctval")
g_id_nop=getid("__nop")
g_id_keep_alive=getid("__keep_alive")
g_id_export=getid("__export")
//g_id_parent_scope=gettempid(getid("__parent_scope"))
g_id_aliased=getid("__aliased")
g_id_operator_add=getid("operator+")
g_id_operator_sub=getid("operator-")
g_id_operator_mul=getid("operator*")
g_id_operator_div=getid("operator/")
g_id_operator_mod=getid("operator%")
g_id_operator_and=getid("operator&")
g_id_operator_or =getid("operator|")
g_id_operator_xor=getid("operator^")
g_id_operator_shl=getid("operator<<")
g_id_operator_shr=getid("operator>>")
g_id_array_type=getid("__array_type")
g_id_array_template=getid("__array_template")
g_id_resize=getid("resize")
////////////////////
g_id_if=getid("if")//switch also goes here
g_id_else=getid("else")
g_id_for=getid("for")
g_id_foreach_lang=getid("foreach")
g_id_while=getid("while")
g_id_foreach=getid("forEach")
g_id_int_range=getid("__int_range")
g_id_slice=getid("__slice")
g_id_in=getid("in")
g_id_break=getid("break")
g_id_continue=getid("continue")
g_id_inline=getid("inline")
g_id_inline_loopbody=getid("__inline_loop_body")
g_id_import=getid("import")
g_id_namespace=getid("namespace")
g_id_new=getid("new")
g_id_switch=getid("switch")
g_id_case=getid("case")
g_id_default=getid("default")
g_empty_id=getid("")
g_tempvar_id=getid("$")
/////////////////////
g_id_dot=getid("__dot")
g_id_stdot=getid("set___dot")
g_id_set_=getid("set_")
g_id_list=getid("__list")
g_id_tuple=getid("__tuple")
g_id_store=getid("__store")
//g_id_call=getid("__call")
g_id_aliased=getid("__aliased")
g_id_uninit=getid("__uninit")
g_id_nop=getid("__nop")
g_id_C_autocast=getid("__C_autocast")
g_id_C_wrap=getid("__C")
g_id_C_wrap_pure=getid("__C_pure")
g_id_reduce_=getid("__reduce_")
g_id_n=getid("n")
g_id_map_callback=getid("__map_callback")
/////////////////////
//context, target var ctobj
g_id_ldlambda=getid("__ldlambda")
g_id_stlambda=getid("__stlambda")
g_id_struct_copy=getid("__struct_copy")
g_id_get_lambda_context=getid("__get_lambda_context")
g_id_this=getid("this")
g_id_class=getid("class")
g_id_struct=getid("struct")
g_id_module=getid("module")
g_id_C_union=getid("__C_union")
g_id_C_declare_struct_slots=getid("__C_declare_struct_slots")
g_id_C_get_struct_slot=getid("__C_get_struct_slot")
g_id_C_rezero_struct_slot=getid("__C_rezero_struct_slot")
/////////////////////
//rc
g_id_addref=getid("__rc_addref")
g_id_release=getid("__rc_release")
//g_id_rc_local_holder=getid("__rc_local_holder")
g_id_explicit_rc=getid("__explicit_rc")
g_id_rc_barrier=getid("__rc_barrier")
g_id_C_free=getid("__C_free")
g_id_init=getid("__init__")
g_id_finalizer=getid("__done__")
g_id_destructor_name=getid("__destructor__")
/////////////////////
//raw functionality
g_id_sizeof=getid("sizeof")
g_id_memory=getid("__memory")
g_id_set_memory=getid("set___memory")
/////////////////////
//template
g_id_var=getid("var")
g_id_auto=getid("auto")
g_id_const=getid("const")
g_id_is_type=getid("__is_type")
g_id_typeof=getid("typeof")
g_id_int=getid("int")
g_id_float=getid("float")
g_id_builtin=getid("builtin")
g_id_builtin_unit=getid("__builtin")
g_id_inline_clone=getid("__inline_clone")
g_id_null=getid("NULL")
g_id_default_value=getid("__zero")
g_id_parameter_count=getid("__parameter_count")
g_id_call=getid("call")
g_id_length=getid("length")
g_id_arguments=getid("arguments")
g_id_tuple_call=getid("__tuple_call")
g_id_tuple_bracket=getid("__tuple_bracket")
g_id_prototype_matches=getid("__prototype_matches")
g_id_has_member=getid("__has_member")
g_id_member_list=getid("__member_list")
g_id_is_variable=getid("__is_variable")
g_id_get_rtti=getid("__get_rtti")
g_id_variant=getid("variant")
g_id_reach=getid("__reach")
g_id_force_alive=getid("__force_alive")
g_id_force_var=getid("__force_var")
g_id_report_error=getid("__error")
g_id_array_or_map=getid("__array_or_map")
g_id_set_fflag=getid("set___fflag")
g_id_cite_param=getid("__cite_param")
g_id_global_string_cns=getid("__global_string_cns")
/////////////////////
//meta state
g_id_meta_state=getid("__meta_state")
g_id_set_meta_state=getid("set___meta_state")
g_id_generate_json=getid("__generate_json")
/////////////////////
//operators
g_id_operator_logic_not=getid("operator!")
g_id_operator_select=getid("operator?")
g_id_operator_aa=getid("operator&&")
g_id_operator_oo=getid("operator||")
g_id_operator_bracket=getid("operator[]")
g_id_set_operator_bracket=getid("set_operator[]")
g_id_operator_bit_not=getid("operator~")
g_id_operator_neg=getid("__unary_operator-")
g_id_operator_add_generic_int=getid("__untyped_operator+")
/////////////////////
//debug
g_id_callstack=getid("__callstack")
g_id_set_callstack=getid("__set_callstack")
g_id_FILE=getid("__FILE__")
g_id_LINE=getid("__LINE__")
/////////////////////
//stack allocation
g_id_stackzero=getid('__stack_zero')

g_tuple_ids=new int[]
auto getTupleId(int n)
	while g_tuple_ids.n<=n:
		n0=g_tuple_ids.n
		g_tuple_ids.push(getid("_"+string(int(n0))))
	return g_tuple_ids[n]

auto makeTuple(int n)
	as=new PExpression[n]
	for i=0:n-1
		as[i]=exprstr(getTupleId(i))
	return vcall(g_id_tuple,as)

/////////////////////
g_top_level_exprs=new PExpression[]
//g_global_namespaces=new PExpression[int]
g_parsed_files=new int[int]
g_files_to_parse=new int[]
g_dependency_edges=new int2[]
g_dumpexpr_name_usage=new PCTObject[int]
g_dump_additional_text=new string
fcolorer_callback=function(PExpression pe):int
auto dumpExprEx(PExpression pe, fcolorer_callback fcolorer,int indent)
	if !pe:
		g_id_errored=1
		return "<null-expr>"
	if isExpr(pe,EFLAG_FCALL)&&!readPool(pe+EXPR_OFS_FUNCTION):
		g_id_errored=1
		return "<bad-function>"
	flags=readPool(pe)
	col=fcolorer?fcolorer(pe):-1
	if col==-2:
		return "..."
	else if col==-3:
		sprecolor=g_dump_additional_text
		spostcolor=""
	else if col!=-1:
		//color_tran=[0,4,2,6,1,5,3,7]
		//if col&8:
		//	sprecolor="\x1b["+string(30+color_tran[(col&7)])+";01m"
		//else
		//	sprecolor="\x1b["+string(30+color_tran[(col&7)])+"m"
		//if col&0xf0:
		//	sprecolor="\x1b["+string(40+color_tran[((col>>4)&7)])+"m"
		//spostcolor="\x1b[37m\x1b[00m"
		sprecolor="'"+string(col)+"'"
		spostcolor=""
	else
		sprecolor=""
		spostcolor=""
	switch(flags&EFLAG_MASK){
	default:
		assert(0);
		break
	case EFLAG_FCALL:
		n=(flags&~EFLAG_MASK)
		if g_names_resolved&&isBuiltin(pe,g_id_block)||readPool(readPool(pe+EXPR_OFS_FUNCTION))==EFLAG_VARIABLE+g_id_block:
			sret=new string
			sret.push(sprecolor)
			sret.push('{')
			sret.push(spostcolor)
			sret.push('\n')
			for i=0:n-1
				pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
				if Platform.BUILD=="debug":
					if readPool(pe_argi+EXPR_OFS_CALLER)!=pe:
						sret.push('[bad-caller]')
						g_id_errored=1
				for j=0:indent
					sret.push(' ')
				sret.push(dumpExprEx(pe_argi,fcolorer,min(indent+1,10)))
				sret.push(';\n')
			for j=0:indent-1
				sret.push(' ')
			sret.push(sprecolor)
			sret.push('}')
			sret.push(spostcolor)
		else
			pefunc=readPool(pe+EXPR_OFS_FUNCTION)
			sret=new string
			if !isVariable(pe+EXPR_OFS_VALUE):
				sret.push('[bad-value-'+getIdString(readPool(pe+EXPR_OFS_VALUE))+"]")
			sret.push(sprecolor)
			if Platform.BUILD=="debug":
				if readPool(pefunc+EXPR_OFS_CALLER)!=pe:
					sret.push('[bad-func-caller]')
					g_id_errored=1
			sret.push(dumpExprEx(pefunc,function(PExpression pe_x){if pe_x==pefunc:{return -1;}else{return fcolorer?fcolorer(pe_x):-1}},indent))
			sret.push(spostcolor)
			sret.push('(')
			for i=0:n-1
				if i:sret.push(',')
				pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
				if Platform.BUILD=="debug":
					if readPool(pe_argi+EXPR_OFS_CALLER)!=pe:
						sret.push('[bad-caller]')
						g_id_errored=1
				sret.push(dumpExprEx(pe_argi,fcolorer,indent))
			sret.push(')')
		return sret
	//case EFLAG_CODEBLOCK:
	//	code=flags&~EFLAG_MASK
	//	return "{\n"+dump_indent(dumpCode(code))+"}"
	case EFLAG_CONST:
		cid=flags&~EFLAG_MASK
		return dumpConst(Util.g_const_values[cid])
	case EFLAG_STRING:
		return FormatAsText('"',genString(getIdString(flags&~EFLAG_MASK)),'"')
	case EFLAG_VARIABLE:
		//scopeid=readPool(pe+EXPR_OFS_NAME)
		//if scopeid:
		//	return "\x1b[30;1m("+string.ToHex(scopeid)+")"+sprecolor+getIdString(er.v.key)+spostcolor
		vid0=(flags&~EFLAG_MASK)
		vid=vid0
		if g_names_resolved:
			vid=dump_getObjectName(vid)
			//Writeln(vid,' ',vid0,' ',getIdString(vid))
			pobj_name_user=g_dumpexpr_name_usage[vid]
			if !pobj_name_user:
				pobj_name_user=vid0
				g_dumpexpr_name_usage[vid]=pobj_name_user
			if pobj_name_user!=vid0||isTempId(vid):
				vid=getid(getIdString(vid)+"@"+string(vid0))
		sname=getIdString(vid)
		//if sname[0]=='$':
		//	return sprecolor+sname+string(vid)+spostcolor
		//else
		return sprecolor+sname+spostcolor
		//break
	case EFLAG_CTVAL:
		pobj=flags&~EFLAG_MASK
		//tid=readPool(pobj)
		//if tid==g_tid_TBuiltinType:
		//	return dumpType(pobj)
		if readPool(pobj)==g_tid_TFunction:
			id_name=readPool(pobj+FUNCTION_OFS_NAME)
			if id_name:
				return getIdString(id_name)
		//return "<"+getIdString(tid)+"-"+string(pobj)+">"
		return dumpObject(pobj)
	}
	return ""
tm_dump=tnew("dump")
auto dumpExpr(PExpression pe,fcolorer_callback fcolorer)
	tbegin(tm_dump)
	ret=dumpExprEx(pe,fcolorer,0)
	tend(tm_dump)
	return ret
//string dump_indent(string scode)
//	if !scode.n:return scode
//	ret=new string
//	foreach sline in scode[:scode.n-2].TokenizeIncludingEmpty("\n")
//		ret.push("  "+sline+"\n")
//	return ret
auto dumpCode(PExpression code,fcolorer_callback fcolorer){
	return "=======================================\n"+dumpExpr(code,fcolorer)
}
auto dumpObject(PCTObject pobj)
	if !pobj:
		return "<NULL>"
	tid=readPool(pobj)
	sret="<"+getIdString(tid)+"-"+string(pobj)
	if tid==g_vtid_CTVAL:
		sret.push(':')
		sret.push(dumpObject(readPool(pobj+1)))
	else if tid==g_vtid_RTVAR:
		vid=readPool(pobj+VAR_OFS_ID)
		if vid:
			sret.push(':')
			sret.push(getIdString(vid))
	else if tid==g_tid_TFunction:
		id_name=readPool(pobj+FUNCTION_OFS_NAME)
		//if isFunctionAClass(pobj):
		//	sret="<class-"+string(pobj)
		if id_name:
			sret.push(':')
			sret.push(getIdString(id_name))
		//sret.push(dumpExpr(fn.pe_decl,NULL))
	else if tid==g_tid_TBuiltinType:
		return dumpType(pobj)
	else if tid==g_tid_TAdvancedEpos:
		epos0=readPool(pobj+1)
		epos1=readPool(pobj+2)
		if epos0&0x80000000:
			//it's an inline nested thing
			if readPool(epos1)==g_tid_TAdvancedEpos:
				sret=new("eposi<")
			else
				sret=new("eposf<")
			sret.push(dumpObject(epos0&0x7fffffff))
			sret.push(',')
			sret.push(dumpObject(epos1))
		else
			//it's a normal epos
			(id_fn0,ln0,col0)=getLineInfo(epos0)
			(id_fn1,ln1,col1)=getLineInfo(epos1)
			assert(id_fn0==id_fn1)
			if ln0==ln1:
				sret=FormatAsText('<',getIdString(id_fn0),':',ln0+1,',',col0+1,'-',col1+1)
			else
				sret=FormatAsText('<',getIdString(id_fn0),':',ln0+1,',',col0+1,'-',ln1+1,',',col1+1)
	sret.push('>')
	return sret

auto fcolor_just_reach(PExpression pe)
	val=getExprValue(pe)
	if val.tid==g_vtid_UNINIT:
		if !testUserFlag(pe,QUEUE_FLAG_REACH):
			if isExpr(pe,EFLAG_FCALL)&&!isBuiltin(pe,g_id_ldparam):
				return -2
			else
				return -1
		if isBuiltin(pe,g_id_block):return -1
		return -1
	if !testUserFlag(pe,QUEUE_FLAG_REACH)&&(isExpr(pe,EFLAG_FCALL)||isExpr(pe,EFLAG_VARIABLE)):
		return -1
	return -1

auto fcolor_reach_eval(PExpression pe)
	val=getExprValue(pe)
	//if val.tid==g_vtid_UNREACHED:return -1
	if val.tid==g_vtid_UNINIT:
		if !testUserFlag(pe,QUEUE_FLAG_REACH):
			if isExpr(pe,EFLAG_FCALL)&&!isBuiltin(pe,g_id_ldparam)://isBuiltin(pe,g_id_block):
				return -2
			else
				return -1
		if isBuiltin(pe,g_id_block):return -1
		g_dump_additional_text="'___'"
		return -3
	if !testUserFlag(pe,QUEUE_FLAG_REACH)&&(isExpr(pe,EFLAG_FCALL)||isExpr(pe,EFLAG_VARIABLE)):
		g_dump_additional_text="'XXX'"
		return -3
	if val.tid==g_vtid_CNS||val.tid==g_vtid_STR:
		g_dump_additional_text="'CNS'"
		return -3
	if val.tid==g_vtid_CTVAL:
		g_dump_additional_text="'fnc'"
		return -3
	g_dump_additional_text="'var'"
	return -3

auto fcolor_abbrv_blocks(PExpression pe)
	if isBuiltin(pe,g_id_block):return -2
	return fcolor_reach_eval(pe)

auto fcolor_resolve(PExpression pe)
	if isBuiltinR(pe,g_id_function)||isBuiltinR(pe,g_id_namespace)||isBuiltinR(pe,g_id_block):return -2
	return -1

auto fcolor_epos(PExpression pe)
	epos0=readPool(pe+1)
	//epos1=readPool(pe+2)
	if !epos0:
		g_dump_additional_text="[?]"
		return -3
	return fcolor_reach_eval(pe)

auto fcolor_just_epos(PExpression pe)
	epos0=readPool(pe+1)
	//epos1=readPool(pe+2)
	if !epos0:
		g_dump_additional_text="[?]"
		return -3
	return -1

auto fcolor_numerical(PExpression pe)
	g_dump_additional_text="["+string(pe)+"]"
	return -3

inline isBuiltin(PExpression pe,int id_builtin)
	if u32(readPool(pe))>=u32(EFLAG_MULTIPLIER):
		return 0
	else
		eflag=readPool(readPool(pe+EXPR_OFS_FUNCTION))
		vslot=g_symbols[id_builtin].user_slot
		return eflag==EFLAG_VARIABLE+vslot||eflag==EFLAG_CTVAL+readPool(vslot+1)

import "system.jc"
import System.Console.*

__C(int,"@global:
#define S7_LD_LEAK_DETECTION_ENABLED 0
#define s7_LD_real_free free
")

auto CreateMemorySnapshot()
	if Platform.BUILD=="debug":
		//0: prev, 1: next
		__C(int,"@global:
		extern void* spapGetCallStack();
		
		static void* s7_LD_head[2]={(void*)s7_LD_head,(void*)s7_LD_head};
		static size_t s7_LD_n_ptrs=0;
		
		static void* s7_LD_calloc(size_t sz){
			void* ptr=calloc(1,sz+sizeof(void*)*9);
			void* w=s7_LD_head[0];
			void* x=(void*)s7_LD_head;
			void* stk=spapGetCallStack();
			int p=3;
			if(!ptr){return NULL;}
			((void**)ptr)[0]=w; ((void**)w)[1]=ptr;
			((void**)ptr)[1]=x; ((void**)x)[0]=ptr;
			((void**)ptr)[2]=(void*)sz;
			while(stk&&p<9){
				((void**)ptr)[p+0]=((void**)stk)[1];
				((void**)ptr)[p+1]=((void**)stk)[2];
				stk=((void**)stk)[0];
				p+=2;
			}
			s7_LD_n_ptrs++;
			return (void*)(((void**)ptr)+9);
		}
		
		static void s7_LD_free(void* ptrx){
			void* ptr=(void*)(((void**)ptrx)-9);
			void* w=((void**)ptr)[0];
			void* x=((void**)ptr)[1];
			((void**)w)[1]=x; ((void**)x)[0]=w;
			s7_LD_n_ptrs--;
			free(ptr);
		}
		
		static void* s7_LD_realloc(void* ptrx,size_t sz){
			void* ptr=(void*)(((void**)ptrx)-9);
			void* w=((void**)ptr)[0];
			void* x=((void**)ptr)[1];
			void* stk=spapGetCallStack();
			int p=3;
			ptr=realloc(ptr,sz+sizeof(void*)*9);
			if(!ptr){return NULL;}
			((void**)w)[1]=x; ((void**)x)[0]=w;
			w=s7_LD_head[0];
			x=(void*)s7_LD_head;
			((void**)ptr)[0]=w; ((void**)w)[1]=ptr;
			((void**)ptr)[1]=x; ((void**)x)[0]=ptr;
			((void**)ptr)[2]=(void*)sz;
			while(p<9){
				if(stk){
					((void**)ptr)[p+0]=((void**)stk)[1];
					((void**)ptr)[p+1]=((void**)stk)[2];
					stk=((void**)stk)[0];
				}else{
					((void**)ptr)[p+0]=NULL;
					((void**)ptr)[p+1]=NULL;
				}
				p+=2;
			}
			return (void*)(((void**)ptr)+9);
		}
		
		#undef s7_LD_real_free
		static void s7_LD_real_free(void* p){free(p);} 
		
		#define calloc(a,b) s7_LD_calloc((a)*(b))
		#define malloc(a) s7_LD_calloc(a)
		#define free(a) s7_LD_free(a)
		#define realloc(a,b) s7_LD_realloc(a,b)
		#undef S7_LD_LEAK_DETECTION_ENABLED
		#define S7_LD_LEAK_DETECTION_ENABLED 1
		
		")
		n=__C(iptr,"s7_LD_n_ptrs")
		ret=new iptr[n+2]
		p0=iptr(__C(__pointer,"((void*)s7_LD_head)"))
		p=iptr(__C(__pointer,"(s7_LD_head[1])"))
		i=0L
		while p!=p0
			if i>=ret.n:
				assert(0)
				break
			ret[i]=p
			i++
			p=__memory(iptr,p+sizeof(iptr))
		ret.n=i
		ret.Sort()
		return ret
	else
		return new iptr[]

module detail
	FDumper=function(__variant):string
	struct TRTTIInfo
		string name
		FDumper dump
	g_previous_state0=iptr[].NULL
	g_previous_state1=iptr[].NULL
	g_rtti_map=new TRTTIInfo[iptr]
	printstr=inline(s){
		__C(int,'printf("%s",(char*)@1)',s)
	}

auto CompareLeaks(iptr[] a0,iptr[] a1,int mask)
	leaks=new iptr[]
	p0=0L;p1=0L
	while p0<a0.n||p1<a1.n:
		if p0<a0.n&&(p1>=a1.n||a0[p0]<=a1[p1]):
			//increment p0
			if p1<a1.n&&a0[p0]==a1[p1]:
				if mask==3:
					leaks.push(a0[p0])
				p1++
			else
				if mask==1:
					leaks.push(a0[p0])
			p0++
		else
			//increment p1 - newly allocated pointer
			if mask==2:
				p_leak=a1[p1]+sizeof(iptr)*9
				if p_leak!=__cast(iptr,a1)&&p_leak!=a1.d&&p_leak!=__cast(iptr,a0)&&p_leak!=a0.d:
					leaks.push(a1[p1])
			p1++
	return leaks
	
auto DetectLeaks()
	state_new=CreateMemorySnapshot()
	if detail.g_previous_state0:
		leaks0=CompareLeaks(detail.g_previous_state0,detail.g_previous_state1,2)
		leaks1=CompareLeaks(detail.g_previous_state0,state_new,2)
		leaks=CompareLeaks(leaks0,leaks1,3)
		if leaks.n:
			Writeln('=== ',leaks.n,' leaks, ',state_new.n,' alloced')
			foreach p in leaks
				sz=__memory(iptr,p+sizeof(iptr)*2)
				Write(formatNumber(p,{align:sizeof(iptr)*2,base:16}),' ',sz,': ')
				if sz>=16L:
					for j=0L:15L
						c=__memory(char,p+sizeof(iptr)*9+j)
						if !(c>=32&&c<127):
							c='.'
						Write(c)
				Writeln()
				for si=0:2
					li=__memory(iptr,p+(si*2+4)*sizeof(iptr))
					for(;li;li=__memory(iptr,li+sizeof(iptr)))
						s=__memory(iptr,li)
						if s:detail.printstr(s)
					s=__memory(iptr,p+(si*2+3)*sizeof(iptr))
					if s:detail.printstr(s)
				if sz>=sizeof(iptr)*2:
					Write('  ')
					for j=0L:min(4L,sz/sizeof(iptr))-1L
						word=__memory(iptr,p+(9+j)*sizeof(iptr))
						if j==1L:
							rtti_info=detail.g_rtti_map[word]
							if rtti_info.name:
								obj=__cast(__variant,p+9*sizeof(iptr))
								Write(rtti_info.name,rtti_info.dump(obj),' ')
								continue
						Write(formatNumber(uptr(word),{align:sizeof(iptr)*2,base:16}),' ')
					Writeln()
		else
			Writeln('=== no leak, ',state_new.n,' alloced')
	else
		Writeln('=== still preparing')
	detail.g_previous_state0=detail.g_previous_state1
	detail.g_previous_state1=state_new

inline RegisterRTTI(T)
	rtti=iptr(__get_rtti(T))
	if !detail.g_rtti_map[rtti].name:
		//Writeln('RegisterRTTI ',rtti,' ',__type_name(T))
		detail.g_rtti_map[rtti]=detail.TRTTIInfo(){
			name:__type_name(T),
			dump:function(__variant obj){
				p=obj.as(T)
				if p:
					if readOptionalMember(p,"IS_ARRAY",0):
						return FormatAsText('*',p.n)
					else
						return ""//FormatAsText(p)
				else
					//return "<RTTI-dump-failed>"
					return ""
			}
		}

inline isEnabled()
	return __C(int,"S7_LD_LEAK_DETECTION_ENABLED")

inline realFree(__pointer p)
	__C(int,"s7_LD_real_free(@1)",p)

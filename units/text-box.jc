import "gui2d.jc"
import "leak-detection.jc"
import Gui2D.*
import Gui2D.detail.*
import Javascript.*
import System.Algorithm.*
import System.Math.*
import System.Console.*

auto double2fixed(double a)
	return i64(a*64.0)

auto float2fixed(float a)
	return i64(a*64.0f)

auto fixed2double(i64 a)
	return double(a)*(1.0/64.0)

auto fixed2float(i64 a)
	return float(a)*(1.0f/64.0f)

auto GetStringWidth(TFont m_font,string s)
	w_overlay=0.
	foreach ch,I in Utf8Chars(s)
		w_overlay+=g_renderer.GetCharacterAdvance(m_font,ch)
	return w_overlay

inline isCJK(int ch)
	return ch>=0x2E80&&ch<0xA640||ch>=0xAC00&&ch<0xD7FF||ch>=0xF900&&ch<0xFAFF||ch>=0xFE30&&ch<0xFE4F||ch>=0x20000

module detail{
struct TRenderingInfo
	//double2 bb
	long2 bb
	iptr seek_ret

///////////////////////////////
class ITextStateHandler
	iptr id
	function():string name
	function():int stateSize
	function():int isLineOnly
	function():int contextSize
	//The "add" function must be associative
	//The result should be written to "a"
	//if AddBlock returns anything... it's considered as a per-block cache
	//todo: request context, eof block detection
	function(CEditableText caller,i64[] a,string s):i64[] PreprocessBlock
	function(i64[] a,i64[] pp,string s_context,string s,iptr ofs) AddString
	function(i64[] a,i64[] b) Add
	//For coloring states, we need a colorer
	function(i64[] a,string s_context,string s):u8[] ComputeCharColorID
	//For rendering states, we need a layouter
	function(JSObject obj) SetTextStyle
	function(JSObject obj) BeginRender
	function(CEditableText ed,i64 ccnt0,i64 ccnt1):int IsRangeHidden
	function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scaling) RenderText
	function(JSObject obj,CEditableText ed, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale) EndRender
	function(JSObject obj,CEditableText ed,CHLRange hl, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale) DrawEnhancedHighlight
	function(i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs):i64 GetCharacterHeightAt
	function():TFont GetDefaultFont
	function(CEditableText caller,i64 x,i64 y,JSObject obj):i64 SetCaretOverlay
	function():i64 GetCaretOffset
	function(CEditableText ed,i64[] a):long2 GetXYFromState
	function(i64[] a,i64[] pp,string s,iptr ofs):int IsAtLineWrap
	function(int ch):int IsCharInvisible
	//For bisecting states, we need comparison and in-block linear seeking
	function(CEditableText ed,i64[] a,i64[] b):int Compare
	function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s,i64[] b):iptr SeekInBlock
	//For search-nearest states, we need or-queries and full-block boolean mapping
	//apply to pre-char locations
	function(i64[] a,i64[] da, i64[] b):int hasValidResult
	function(i64[] a,i64[] pp,string s_context,string s, i64[] b):i8[] QueryPerCharValidity
	function():i64 GetWrapWidth
	////////////////////
	//for JS operations
	__variant __this
	//function(JSObject proto) __JS_prototype
	function(JSObject proto) __JS_prototype

auto combineEditorOffset(long2 bb0,long2 bb1)
	bb=bb0
	if bb1.y:
		bb.x=bb1.x
		bb.y+=bb1.y
	else
		bb.x+=bb1.x
	return bb

auto MakeCharSet(string e)
	ok=new u32[8]
	inv=0
	s=0
	if e[0]=='^':
		inv=1;s++
	for(;s<e.n;s++)
		if s+1<e.n&&e[s+1]=='-':
			for(i=u32(u8(e[s]));i<=u32(u8(e[s+2]));i++)
				ok[i>>5]|=(1u<<int(i&31u));
			s+=2
		else
			ok[e[s]>>5]|=(1u<<int(u32(u8(e[s]))&31u));
	if inv:
		for i=0:7
			ok[i]=~ok[i]
	return uint4(ok[0],ok[1],ok[2],ok[3])

//inline epsEqual(a,b)
//	return abs(__double_as_longlong(double(a))-__double_as_longlong(double(b)))<(1LL<<32)
//
//inline epsUp(a)
//	ret=__double_as_longlong(double(a))
//	if ret<<1:ret+=(1LL<<32)^(ret>>63)
//	return __longlong_as_double(ret)
//
//inline epsDown(a)
//	ret=__double_as_longlong(double(a))
//	if ret<<1:ret-=(1LL<<32)^(ret>>63)
//	return __longlong_as_double(ret)

g_ascii_wordchars=MakeCharSet("0-9A-Za-z_")
inline isInCharSet(uint4 cset,int ch)
	slot=(ch>>5)
	for i in crange(4)
		if i==slot:return int(cset[i]>>(ch&31))&1
	return 0
auto isWordChar(int ch)
	if ch>=128:
		return int(g_unicode_wordchars.Bisect(function(int c0){return c0<=ch})&1)
	else
		return isInCharSet(g_ascii_wordchars,ch)

auto GreedyLayoutParagraph(TFont fnt,string s,float w_line, float w_tab)
	//todo: also replace ComputeTextLayout with this
	lbreaks=new int[]
	lbreaks.push(0)
	x=0.f
	auto addWord(iptr a,iptr b)
		x_new=x
		foreach ch,I in Utf8Chars(s[a:b-1])
			if ch=='\t':
				x_new=(floor(x_new/w_tab)+1.f)*w_tab
			else
				x_new+=g_renderer.GetCharacterAdvance(fnt,ch)
		//greedily accept place-able words
		if x_new<=w_line:
			x=x_new
			return
		if (s[a]==' '||s[a]=='\t')&&x<w_line:
			//allow space / tab to go over the board
			x=x_new
			return
		//need to wrap it
		if x_new-x>=w_line||x==0.f:
			//word too long, ditch word-wrap, do not start a new line
		else
			//ordinary word wrap
			x=0.f
			lbreaks.push(a)
		foreach ch,I in Utf8Chars(s[a:b-1])
			if ch=='\t':
				x=(floor(x/w_tab)+1.f)*w_tab
			else
				x+=g_renderer.GetCharacterAdvance(fnt,ch)
			if x>=w_line:
				x=0.f
				lbreaks.push(a+I+1)
	p_last_word=0L
	foreach ch,I,I2 in Utf8Chars(s)
		if !isWordChar(ch)||isCJK(ch):
			if p_last_word<I:
				addWord(p_last_word,I)
			p_last_word=I2
			addWord(I,p_last_word)
	if p_last_word<s.n:
		addWord(p_last_word,s.n)
	return lbreaks

auto GreedyLayoutText(TFont fnt,string s,float w_line, float w_tab)
	lbreaks_ret=new int[]
	foreach sline,I in s.TokenizeEx("\n",s.TOKENIZE_ALLOW_EMPTY|s.TOKENIZE_INCLUDE_SEPARATOR)
		lbreaks_paragraph=GreedyLayoutParagraph(fnt,sline,w_line, w_tab)
		//lbreaks_paragraph.pop()
		foreach d in lbreaks_paragraph
			lbreaks_ret.push(d+int(I))
	lbreaks_ret.push(int(s.n))
	return lbreaks_ret

class CLayouter_baseline
	MODE_BB=0
	MODE_SEEK=1
	MODE_RENDER=2
	/////////
	m_wrap_width=0.f
	m_tab_width=8
	m_font=TFont()
	m_color=0xff000000
	m_bgcolor_selection=0xff800000
	//CHyphenator m_hyphenator
	/////////////////
	name=function(){return "renderer"}
	stateSize=function(){return 2}
	isLineOnly=function(){return 1}
	/////////////////
	PreprocessBlock=function(CEditableText caller,i64[] a,string s){
		line_breaks=new i64[]
		if m_wrap_width>0.f:
			line_breaksi=GreedyLayoutText(m_font,s,m_wrap_width,m_tab_width*fixed2float(charWidth(' ')))
			line_breaks=new i64[line_breaksi.n]
			for i=0:line_breaks.n-1
				line_breaks[i]=i64(line_breaksi[i]&0x7fffffff)|(i64(line_breaksi[i]&0x80000000)<<32)
		else
			//it's the *additional* line_breaks
			line_breaks.push(0LL)
			line_breaks.push(i64(s.n))
		return line_breaks
	}
	AddString=function(i64[] a,i64[] line_breaks,string s_context,string s,iptr ofs){
		bb=_RenderText(MODE_BB,a,line_breaks,s,ofs, 0LL,0LL,0.f,0.f,0.f).bb
		a[0]=bb.x
		a[1]=bb.y
	}
	Add=function(i64[] a,i64[] b){
		bb=combineEditorOffset(long2(a[0],a[1]),long2(b[0],b[1]))
		a[0]=bb.x
		a[1]=bb.y
	}
	/////////////////
	Compare=function(CEditableText ed,i64[] a,i64[] b){
		ret=__C_compare(a[1],b[1])
		if ret==0:ret=__C_compare(a[0],b[0])
		return ret
	}
	SeekInBlock=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] line_breaks,string s,i64[] b){
		return iptr(_RenderText(MODE_SEEK,a,line_breaks,s,s.n, b[0],b[1],0.f,0.f,0.f).seek_ret)
	}
	/////////////////
	long3 m_caret_overlay
	JSObject m_overlay_obj
	i64 m_caret_offset
	SetTextStyle=function(JSObject obj){
		m_font=obj["font"].as(TFont)
		m_color=int(obj["color"].or(u32(m_color)))
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width=obj["wrap_width"].or(0.f)
		//m_hyphenator=obj["hyphenator"].or(g_default_hyphenator)
	}
	SetCaretOverlay=function(CEditableText caller,i64 x,i64 y,JSObject obj){
		m_overlay_obj=obj
		w_overlayd=0.
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlayd=GetStringWidth(m_font,s)
		w_overlay=double2fixed(w_overlayd)
		m_caret_overlay=long3(x,y,w_overlay)
		m_caret_offset=0LL
		return w_overlay
	}
	GetCaretOffset=function(){
		//Writeln(m_caret_overlay,' ',m_caret_offset)
		//if m_overlay_obj:
		//	Writeln(m_overlay_obj["text"].as(string))
		return m_caret_offset
	}
	charWidth=inline(ch){
		return float2fixed(g_renderer.GetCharacterAdvance(m_font,int(ch)))
	}
	charHeight=inline(){
		return float2fixed(g_renderer.GetCharacterHeight(m_font))
	}
	_RenderText=function(int mode,i64[] a,i64[] line_breaks,string s,iptr ofs, i64 scroll_x,i64 scroll_y,float screen_x,float screen_y,float scale){
		if mode==MODE_RENDER:
			//Writeln('before fnt_scaled ',m_font.h,' ',scale)
			fnt_scaled=m_font
			fnt_scaled.h*=scale
			//smart emboldening for SRGB
			if g_renderer.m_srgb_supported:
				//fnt_scaled.embolden+=int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*3000.f/fnt_scaled.h)
				fnt_scaled.SmartEmbolden(m_color)
			//Writeln('after fnt_scaled ',m_font.h)
			//scaled=double(scale)
		w_tab=i64(m_tab_width)*charWidth(' ')
		hc=charHeight()
		x=a[0]
		y=a[1]
		if mode==MODE_RENDER:
			//if epsEqual(y,m_caret_overlay.y)&&x>m_caret_overlay.x:
			if y==m_caret_overlay.y&&x>m_caret_overlay.x:
				x+=m_caret_overlay.z
		is_wrapping=(m_wrap_width>0.f)
		w_space=charWidth(' ')
		w_hyphen=charWidth('-')
		inline projectX(i64 x)
			return fixed2float(x-scroll_x)*scale+screen_x
		inline projectY(i64 y)
			return fixed2float(y-scroll_y)*scale+screen_y
		auto testIMEOverlay()
			if x==m_caret_overlay.x&&y==m_caret_overlay.y:
				if m_overlay_obj["type"].as(string)=="IME":
					s_overlay=m_overlay_obj["text"].as(string)
					yf=projectY(y)
					if s_overlay:
						cmap=new iptr[]
						foreach chj,J in Utf8Chars(s_overlay)
							cmap.push(J)
						cmap.push(s_overlay.n)
						overlay_sel0=m_overlay_obj["start"].as(iptr)
						overlay_sel1=overlay_sel0+m_overlay_obj["length"].as(iptr)
						overlay_sel0=min(overlay_sel0,cmap.n-1)
						overlay_sel1=min(overlay_sel1,cmap.n-1)
						if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
							x_sel0=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel0]-1])
							x_sel1=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel1]-1])
							m_caret_offset=double2fixed(x_sel1)
							if x_sel0>x_sel1:
								(x_sel0,x_sel1)=(x_sel1,x_sel0)
							//selection - pre-draw the highlight
							if x_sel0<x_sel1:
								g_renderer.DrawRectangle(float((fixed2float(x-scroll_x)+x_sel0)*scale+screen_x),yf,float((x_sel1-x_sel0)*scale),fixed2float(hc), m_bgcolor_selection)
						else
							assert(0)
						xo=x
						foreach chj,J in Utf8Chars(s_overlay)
							dx_j=charWidth(chj)
							g_renderer.DrawChar(fnt_scaled, projectX(xo),yf,m_color, chj)
							xo+=dx_j
					else
						assert(0)
					//draw the underline
					y_underline=yf+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height+0.02f)
					g_renderer.DrawRectangle(projectX(x),y_underline,fixed2float(m_caret_overlay.z)*scale,max(fnt_scaled.h*0.05f,1.f), m_color)
				else
					assert(0)
				x+=m_caret_overlay.z
		for i=0:line_breaks.n-2
			got_newline=0
			//justified wrapping
			space_padding=0LL
			space_padding_rem=0
			need_to_pad_non_space=0
			has_hyphen=0
			i_padding=0
			if is_wrapping&&i<line_breaks.n-1:
				nspaces=0
				n_trailing_space=0
				n_paddable_non_space=0
				w_total=0LL
				if line_breaks[i+1]<0LL:
					//we have a hyphen
					has_hyphen=1
					w_total+=w_hyphen
				for ch,I in Utf8Chars(s[iptr(line_breaks[i]&0x7fffffffffffffffLL):iptr((line_breaks[i+1]&0x7fffffffffffffffLL)-1)])
					if ch=='\r'||ch=='\n':
						//nothing
						if ch=='\n':
							got_newline=1
						continue
					else if ch==' '||ch=='\t':
						nspaces++
						n_trailing_space++
						w_total+=w_space
					else
						if isCJK(ch)||!isWordChar(ch):
							n_paddable_non_space++
						n_trailing_space=0
						w_total+=charWidth(ch)
				nspaces-=n_trailing_space
				if !nspaces:
					//count CJK or non-word chars
					need_to_pad_non_space=1
					nspaces=n_paddable_non_space
				remaining_space=float2fixed(m_wrap_width)-(w_total-w_space*n_trailing_space)
				//with paragraph consistency, got_newline should hold for i==line_breaks.n-2 unless we're at eof
				if nspaces>0&&remaining_space>0LL&&!got_newline&&i<line_breaks.n-2:
					space_padding=remaining_space/nspaces
					space_padding_rem=int(remaining_space-space_padding*nspaces)
				//Writeln(space_padding,' ',nspaces,' ',space_padding)
			got_newline=0
			///////////////
			for ch,I in Utf8Chars(s[iptr(line_breaks[i]&0x7fffffffffffffffLL):iptr(min(line_breaks[i+1]&0x7fffffffffffffffLL,ofs))-1])
				if mode==MODE_SEEK:
					//if y>epsUp(dy)||dy>=epsDown(y)&&dy<epsDown(y+hc)&&x>=dx:
					if y>scroll_y||scroll_y>=y&&scroll_y<y+hc&&x>=scroll_x:
						return TRenderingInfo(){bb:long2(x,y),seek_ret:iptr((line_breaks[i]&0x7fffffffffffffffLL)+I)}
				if mode==MODE_RENDER:
					//if epsEqual(x,m_caret_overlay.x)&&epsEqual(y,m_caret_overlay.y):
					testIMEOverlay()
				if ch=='\r'||ch=='\n':
					//nothing
					if ch=='\n':
						got_newline=1
						if !is_wrapping:
							x=0LL
							y+=hc
					continue
				else if ch==' ':
					x+=w_space+space_padding
					if i_padding<space_padding_rem:
						i_padding++
						x++
				else if ch=='\t':
					if is_wrapping:
						x+=w_space+space_padding
						if i_padding<space_padding_rem:
							i_padding++
							x++
					else
						x=(x/w_tab+1LL)*w_tab
				else
					dx_i=charWidth(ch)
					if mode==MODE_RENDER:
						g_renderer.DrawChar(fnt_scaled, projectX(x),projectY(y),m_color, ch)
					x+=dx_i
			if (line_breaks[i+1]&0x7fffffffffffffffLL)>ofs:break
			if is_wrapping:
				if mode==MODE_RENDER&&has_hyphen:
					g_renderer.DrawChar(fnt_scaled, projectX(x),projectY(y),m_color, int('-'))
				if got_newline||i<line_breaks.n-2:
					x=0LL
					y+=hc
		if mode==MODE_RENDER:
			//IME at EOF
			testIMEOverlay()
		return TRenderingInfo(){bb:long2(x,y),seek_ret:s.n}
	}
	RenderText=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] pp,string s, u8[] color_ids, i64 scroll_x,i64 scroll_y,i64 clip_w,i64 clip_h,float screen_x,float screen_y,float scale){
		_RenderText(MODE_RENDER,a,pp,s,s.n,scroll_x,scroll_y,screen_x,screen_y,scale)
	}
	GetCharacterHeightAt=function(i64 ccnt_base,i64[] a,i64[] pp,string s,iptr ofs){
		return charHeight()
	}
	GetDefaultFont=function(){
		return m_font
	}
	//////////////////////////////
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"m_color")
	}

class CLine_handler
	//add char count and word count
	name=function(){return "line_column"}
	stateSize=function(){return 4}
	/////////////////
	AddString=function(i64[] a,i64[] pp,string s_context,string s,iptr ofs){
		l=a[0]
		c=a[1]
		wc_c=a[2]
		wc_w=a[3]
		foreach ch,I in Utf8Chars(s)
			if I>=ofs:break
			if ch=='\n':
				l++
				c=0LL
			else
				c++
			wc_c++
			if ch<=' ':
				wc_w&=~1LL
			else
				if !(wc_w&1LL):
					wc_w+=3LL
		a[0]=l
		a[1]=c
		a[2]=wc_c
		a[3]=wc_w
	}
	Add=function(i64[] a,i64[] b){
		if b[0]:
			a[0]+=b[0]
			a[1]=b[1]
		else
			a[1]+=b[1]
		a[2]+=b[2]
		a[3]=(a[3]&~1L)+b[3]
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(CEditableText ed,i64[] a,i64[] b){
		ret=__C_compare(a[0],b[0])
		if !ret:
			ret=__C_compare(a[1],b[1])
		return ret
	}
	SeekInBlock=function(CEditableText ed,i64 ccnt_base,i64[] a,i64[] unused,string s,i64[] b){
		l=a[0]
		c=a[1]
		bl=b[0]
		bc=b[1]
		if b.n>2:
			//last-line hint
			l_last_known=b[2]
			ccnt_last_known=b[3]
			if u64(ccnt_last_known-ccnt_base)<u64(s.n):
				//the hint is valid
				p=iptr(ccnt_last_known-ccnt_base)
				l=l_last_known
				c=0LL
				foreach ch,I in Utf8Chars(s[p:])
					if ch=='\n':
						l++
						c=0LL
					else
						c++
					if l>bl||l==bl&&c>bc:
						return iptr(I)+p
				return s.n
		foreach ch,I in Utf8Chars(s)
			if ch=='\n':
				l++
				c=0LL
			else
				c++
			if l>bl||l==bl&&c>bc:
				return iptr(I)
		return s.n
	}
	////////////////////
	__JS_prototype=function(JSObject proto){}

///////////////////////////////
//diff tracker
/*
use skiplist
unified ccnt
	maintain multiple text segments, each segment has a side: base, current, or both
	maintain one ccnt for each side
*/
DIFF_SIDE_BASE=1
DIFF_SIDE_CURRENT=2
DIFF_SIDE_BOTH=DIFF_SIDE_BASE+DIFF_SIDE_CURRENT
class CDiffSLNode
	CDiffSLNode pchild
	CDiffSLNode pnext
	//////////
	//"both" isn't a simple sum of base and current - there are dedicated "both" segments that count as both
	long3 ccnts

auto CreateDiffSLNode(int side,i64 ccnt)
	pc=new CDiffSLNode()
	switch side{
	case DIFF_SIDE_BASE:{
		pc.ccnts=long3(ccnt,0LL,0LL)
		break
	}case DIFF_SIDE_CURRENT:{
		pc.ccnts=long3(0LL,ccnt,0LL)
		break
	}case DIFF_SIDE_BOTH:{
		pc.ccnts=long3(ccnt,ccnt,ccnt)
		break
	}}
	return pc

struct TDiffSLList
	CDiffSLNode phead
	CDiffSLNode ptail
	inline cat(TDiffSLList b)
		if !phead:return b
		if !b.phead:return TDiffSLList(){phead:phead,ptail:ptail}
		ret=TDiffSLList()
		ret.phead=phead
		ptail.pnext=b.phead
		ret.ptail=b.ptail
		return ret

//but del / add operate on current, it should be just fine
//we don't care the relative ordering of BASE / CURRENT blocks? sometimes it's ill-defined anyway
//at least try to make it right - current mode and unified mode
//unified=base+current-both
struct TDiffNodeOp
	//i64 ccnt_current
	i64 ccnt
	i64 sz_ed_del
	//set high bit for restore
	i64 sz_ed_add_type
	//i64 sz_ed_restore//for undo: restore BASE into BOTH

struct TDiffUndoItem
	TDiffNodeOp[] ops

class CDiffTracker
	m_skiplist=new CDiffSLNode()
	m_undo_queue=new TDiffUndoItem[]
	m_redo_queue=new TDiffUndoItem[]
	TDiffNodeOp[] m_temp_undo_queue
	m_temp_undo_delta=0LL
	auto debugDumpSL()
		levels=new string[]
		auto _debugDumpSL(int level,CDiffSLNode nd)
			if nd.pchild:
				for(pc=nd.pchild;pc;pc=pc.pnext)
					_debugDumpSL(level+1,pc)
			else
				Writeln(nd.ccnts)
		Writeln('---')
		_debugDumpSL(0,m_skiplist)
	auto DiffSkipListPromote(TDiffSLList nds_ret0, TDiffSLList nds_child0,TDiffSLList nds_toadd,CDiffSLNode nd_ignore)
		nds_ret=nds_ret0
		nds_child=nds_child0
		pc_pnext=CDiffSLNode.NULL
		for(pc=nds_toadd.phead;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			if iptr(pc)!=iptr(nd_ignore)&&nds_child.phead&&System.Algorithm.Random(float)<SKIPLIST_PROMOTION_PROBABILITY:
				//finish off the dangling chain
				nds_child.ptail.pnext=CDiffSLNode.NULL
				nds_ret.ptail.pchild=nds_child.phead
				DiffRecomputeCcntInner(nds_ret.ptail)
				//actually promote pc
				nd_new=new CDiffSLNode
				nds_ret.ptail.pnext=nd_new
				nds_ret.ptail=nd_new
				nds_child=TDiffSLList(){phead:pc,ptail:pc}
			else
				if !nds_child.phead:
					nds_child.phead=pc
					//nds_child.ptail=pc
				else
					nds_child.ptail.pnext=pc
				nds_child.ptail=pc
		return (nds_ret,nds_child)
	auto DiffSkipListPromoteToRoot(TDiffSLList nds_toadd0)
		nds_toadd=nds_toadd0
		for(;;)
			if iptr(nds_toadd.phead)==iptr(nds_toadd.ptail)&&nds_toadd.phead.pchild:
				assert(!nds_toadd.phead.pnext)
				return nds_toadd.phead
			//promote the head
			nd_new=new CDiffSLNode
			nds_ret=TDiffSLList(){phead:nd_new,ptail:nd_new}
			nds_child=TDiffSLList(){phead:nds_toadd.phead,ptail:nds_toadd.phead}
			nds_toadd.phead=nds_toadd.phead.pnext
			//add the rest
			(nds_ret,nds_child)=DiffSkipListPromote(nds_ret,nds_child,nds_toadd,CDiffSLNode.NULL)
			nds_ret.ptail.pchild=nds_child.phead;nds_child.ptail.pnext=CDiffSLNode.NULL
			DiffRecomputeCcntInner(nds_ret.ptail)
			//recurse one level up
			nds_toadd=nds_ret
	auto DiffRecomputeCcntInner(CDiffSLNode nd)
		ccnts=long3()
		for(pc=nd.pchild;pc;pc=pc.pnext)
			ccnts+=pc.ccnts
		nd.ccnts=ccnts
	auto DiffBlockEdit(
			int debug_level,CDiffSLNode nd,
			i64 ccnt_ptr0,i64 ccnt_unified0,
			TDiffNodeOp[] bops,iptr pbops0,iptr pbops1,
			int is_unified,int is_loader_mode)
		ccnt_ptr=ccnt_ptr0
		ccnt_unified=ccnt_unified0//we always need a unified ccnt for undo generation
		//nds_ret.ptail.pchild is the dangling part represented by nds_child
		nds_ret=TDiffSLList(){phead:nd,ptail:nd}
		if pbops0>=pbops1:return nds_ret
		nds_child=TDiffSLList()
		pc_pnext=CDiffSLNode.NULL
		if !nd.pchild:
			//leaf node case
			//delete: DIFF_SIDE_CURRENT to nothing, DIFF_SIDE_BOTH to DIFF_SIDE_BASE, leave covered DIFF_SIDE_BASE untouched
			//add: insert a DIFF_SIDE_CURRENT segment
			//validate that leaf nodes can only have a single component
			//assert(!nd.ccnts[0]+!nd.ccnts[1]>=1||nd.ccnts[2])
			side=DIFF_SIDE_BOTH
			nd_ccnt=0LL
			if nd.ccnts[2]:
				//both is... both
				assert(nd.ccnts[2]==nd.ccnts[1]&&nd.ccnts[2]==nd.ccnts[0])
				side=DIFF_SIDE_BOTH
			else if nd.ccnts[0]:
				side=DIFF_SIDE_BASE
			else if nd.ccnts[1]:
				side=DIFF_SIDE_CURRENT
			nd_ccnt=nd.ccnts[0]+nd.ccnts[1]-nd.ccnts[2]
			last_side=-1
			appendChild=inline(side,ccnt){
				//best-effort merging
				auto pc=CreateDiffSLNode(side,ccnt)
				if last_side==side:
					nds_child.ptail.ccnts+=pc.ccnts
				else
					nds_child=nds_child.cat(TDiffSLList(){phead:pc,ptail:pc})
				last_side=side
			}
			//foreach bop in bops
			for I=pbops0:pbops1-1
				bop=bops[I]
				if ccnt_ptr<bop.ccnt:
					//create something as is
					appendChild(side,bop.ccnt-ccnt_ptr)
				//del
				if bop.sz_ed_del:
					if side!=DIFF_SIDE_CURRENT:
						//keep it or downgrade to base
						appendChild(DIFF_SIDE_BASE,bop.sz_ed_del)
						//use restore for undo
						m_temp_undo_queue.push(TDiffNodeOp(){
							ccnt:ccnt_unified+(bop.ccnt-ccnt_ptr0)+m_temp_undo_delta,
							sz_ed_add_type:bop.sz_ed_del+(1LL<<63)})
						//the unified ccnt doesn't change!
						//do not touch m_temp_undo_delta 
					else
						//remove it
						//use add for undo
						m_temp_undo_queue.push(TDiffNodeOp(){
							ccnt:ccnt_unified+(bop.ccnt-ccnt_ptr0)+m_temp_undo_delta,
							sz_ed_add_type:bop.sz_ed_del})
						//unified ccnt got removed
						m_temp_undo_delta-=bop.sz_ed_del
				//update current ccnt
				ccnt_ptr=bop.ccnt+bop.sz_ed_del
				//add / restore
				if bop.sz_ed_add_type:
					if !(bop.sz_ed_add_type&(1LL<<63)):
						//add
						sz_ed_add=bop.sz_ed_add_type
						m_temp_undo_queue.push(TDiffNodeOp(){
							ccnt:ccnt_unified+(ccnt_ptr-ccnt_ptr0)+m_temp_undo_delta,
							sz_ed_del:sz_ed_add})
						m_temp_undo_delta+=sz_ed_add
						appendChild(DIFF_SIDE_CURRENT,sz_ed_add)
					else
						//restore
						sz_ed_restore=(bop.sz_ed_add_type-(1LL<<63))
						m_temp_undo_queue.push(TDiffNodeOp(){
							ccnt:ccnt_unified+(ccnt_ptr-ccnt_ptr0)+m_temp_undo_delta,
							sz_ed_del:sz_ed_restore})
						//leave m_temp_undo_delta untouched
						//Writeln(side,' ',sz_ed_restore,' ',nd_ccnt)
						assert(side==DIFF_SIDE_BASE||is_loader_mode)
						if is_loader_mode:
							m_temp_undo_delta+=sz_ed_restore
							appendChild(DIFF_SIDE_BOTH,sz_ed_restore)
						else
							//assert(sz_ed_restore==nd_ccnt)
							//assert(ccnt_current==ccnt_current0)
							appendChild(DIFF_SIDE_BOTH,nd_ccnt)
							ccnt_ptr+=sz_ed_restore
			if ccnt_ptr<ccnt_ptr0+nd_ccnt:
				//create something as is
				appendChild(side,ccnt_ptr0+nd_ccnt-ccnt_ptr)
			return nds_child
		p=pbops0
		for(pc=nd.pchild;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			pc_ccnt_unified=pc.ccnts[0]+pc.ccnts[1]-pc.ccnts[2]
			if is_unified:
				pc_ccnt=pc_ccnt_unified
			else
				pc_ccnt=pc.ccnts[1]
			//intersect/cut bops within the child
			p0=p
			while p<pbops1&&bops[p].ccnt<ccnt_ptr+pc_ccnt:
				p++
			if p<pbops1&&!bops[p].sz_ed_del&&(bops[p].sz_ed_add_type>=0LL||is_loader_mode)&&bops[p].ccnt==ccnt_ptr+pc_ccnt:
				//we still don't want a tail-restore, except when we're doing the loader mode
				p++
			//each bop could cover *multiple* children... need to test it
			if p0<p:
				bk=bops[p-1]
				bk2=bops[p0]
				//compute covering from sz_ed_del
				bops[p-1].sz_ed_del=min(ccnt_ptr+pc_ccnt-bops[p-1].ccnt,bops[p-1].sz_ed_del)
				if bops[p-1].sz_ed_del<bk.sz_ed_del:
					bops[p-1].sz_ed_add_type=0LL
				bops[p0].sz_ed_del+=bops[p0].ccnt
				bops[p0].ccnt=max(ccnt_ptr,bops[p0].ccnt)
				bops[p0].sz_ed_del-=bops[p0].ccnt
				assert(bops[p-1].sz_ed_del>=0LL)
				assert(bops[p0].sz_ed_del>=0LL)
				pc.pnext=CDiffSLNode.NULL//this is required
				nds_pc=DiffBlockEdit(debug_level+1,pc,ccnt_ptr,ccnt_unified,bops,p0,p, is_unified,is_loader_mode)
				(nds_ret,nds_child)=DiffSkipListPromote(nds_ret, nds_child,nds_pc,pc)
				bops[p0]=bk2
				bops[p-1]=bk
				//the last bop covers multiple segments
				if ccnt_ptr+pc_ccnt<bops[p-1].ccnt+bops[p-1].sz_ed_del:
					p--
			else
				pc.pnext=CDiffSLNode.NULL
				nds_child=nds_child.cat(TDiffSLList(){phead:pc,ptail:pc})
			ccnt_ptr+=pc_ccnt
			ccnt_unified+=pc_ccnt_unified
		//coulddo: removing nd itself
		nds_ret.ptail.pchild=nds_child.phead;
		if nds_child.ptail:nds_child.ptail.pnext=CDiffSLNode.NULL
		DiffRecomputeCcntInner(nds_ret.ptail)
		return nds_ret
	auto BlockEdit(TDiffNodeOp[] bops,int is_unified,int is_loader_mode)
		m_temp_undo_queue=new TDiffNodeOp[]
		m_temp_undo_delta=0LL
		nds_pc=DiffBlockEdit(0,m_skiplist,0LL,0LL,bops,0L,bops.n, is_unified,is_loader_mode)
		m_skiplist=DiffSkipListPromoteToRoot(nds_pc)
		ret=m_temp_undo_queue
		m_temp_undo_queue=TDiffNodeOp[].NULL
		//debugDumpSL()
		return ret
	auto MakeBlockOps(TEditop[] ops,int is_loader_mode)
		bops=new TDiffNodeOp[ops.n]
		if is_loader_mode:
			mask=1LL<<63
		else
			mask=0LL
		foreach op,I in ops
			bops[I].ccnt=op.ccnt
			bops[I].sz_ed_del=op.sz
			if op.s:
				bops[I].sz_ed_add_type=i64(op.s.n)+mask
		return bops
	auto Edit(TEditop[] ops,int is_loader_mode)
		//debugDumpSL()
		m_undo_queue.push(TDiffUndoItem(){ops:BlockEdit(MakeBlockOps(ops,is_loader_mode),0,is_loader_mode)})
		if is_loader_mode:
			m_undo_queue.pop()
	auto RawUndo(TDiffUndoItem[] queue_in,TDiffUndoItem[] queue_out,TEditop[] ops)
		if queue_in.n:
			bops=queue_in.pop().ops
			is_unified=1
		else
			bops=MakeBlockOps(ops,0)
			is_unified=0
		queue_out.push(TDiffUndoItem(){ops:BlockEdit(bops,is_unified,0)})
	inline Undo(TEditop[] ops)
		return RawUndo(m_undo_queue,m_redo_queue,ops)
	inline Redo(TEditop[] ops)
		return RawUndo(m_redo_queue,m_undo_queue,ops)
	auto Init(i64 ccnt)
		m_skiplist=new CDiffSLNode()
		m_skiplist.ccnts=long3(ccnt,ccnt,ccnt)
	auto ConvertCcnt(CDiffSLNode nd,i64 ccnt,const to_side_idx)
		pc=nd.pchild
		if !pc:
			//if we have what we want, it's ccnt, otherwise just subtract the difference
			if nd.ccnts[to_side_idx]:
				return ccnt
			else
				return ccnt-nd.ccnts[to_side_idx^1]
		ccnt_remaining=ccnt
		ccnt_acc=0LL
		for(;pc;pc=pc.pnext)
			if ccnt_remaining<=pc.ccnts[to_side_idx^1]:
				return ccnt_acc+ConvertCcnt(pc,ccnt_remaining,to_side_idx)
			ccnt_remaining-=pc.ccnts[to_side_idx^1]
			ccnt_acc+=pc.ccnts[to_side_idx]
		return ccnt_acc+ccnt_remaining
	inline CurrentToBase(i64 ccnt)
		return ConvertCcnt(m_skiplist,ccnt,0)
	inline BaseToCurrent(i64 ccnt)
		return ConvertCcnt(m_skiplist,ccnt,1)
	auto CurrentToBoth(CDiffSLNode nd,i64 ccnt)
		pc=nd.pchild
		if !pc:
			//if we have what we want, it's ccnt, otherwise just subtract the difference
			if nd.ccnts[1]:
				if nd.ccnts[2]:
					return ccnt
				else
					return 0
			else
				return ccnt-nd.ccnts[1]
		ccnt_remaining=ccnt
		ccnt_acc=0LL
		for(;pc;pc=pc.pnext)
			if ccnt_remaining<=pc.ccnts[1]:
				return ccnt_acc+CurrentToBoth(pc,ccnt_remaining)
			ccnt_remaining-=pc.ccnts[1]
			ccnt_acc+=pc.ccnts[2]
		return ccnt_acc+ccnt_remaining
	auto RangeQuery(i64 ccnt0,i64 ccnt1)
		//whether there's add / delete in this range
		//do not have to tell the difference
		//does this actually need something *more*?
		//no, [2]==[0]==[1] is sufficient: any change increases [0] or [1]
		pboth0=CurrentToBoth(m_skiplist,ccnt0)
		pboth1=CurrentToBoth(m_skiplist,ccnt1)
		if pboth1-pboth0!=ccnt1-ccnt0:return 1
		pbase0=CurrentToBase(ccnt0)
		pbase1=CurrentToBase(ccnt1)
		if pboth1-pboth0!=pbase1-pbase0:return 1
		return 0
	JS_discard=function(JSContext JS){
		m_skiplist=CDiffSLNode.NULL
		return 0
	}
	JS_RangeQuery=function(JSContext JS){
		ccnt0=JS.Param(0).as(i64)
		ccnt1=JS.Param(1).as(i64)
		return JS.Return(RangeQuery(ccnt0,ccnt1))
	}
	JS_CurrentToBase=function(JSContext JS){
		ccnt=JS.Param(0).as(i64);
		return JS.Return(CurrentToBase(ccnt))
	}
	JS_CurrentToBoth=function(JSContext JS){
		ccnt=JS.Param(0).as(i64);
		return JS.Return(CurrentToBoth(m_skiplist,ccnt))
	}
	JS_BaseToCurrent=function(JSContext JS){
		ccnt=JS.Param(0).as(i64);
		return JS.Return(BaseToCurrent(ccnt))
	}
	isUnmodifiedBase=function(i64 ccnt0,i64 ccnt1){
		ccnt0_cur=BaseToCurrent(ccnt0)
		ccnt1_cur=BaseToCurrent(ccnt1)
		ccnt0_both=CurrentToBoth(m_skiplist,ccnt0_cur)
		ccnt1_both=CurrentToBoth(m_skiplist,ccnt1_cur)
		return ccnt1_both-ccnt0_both==ccnt1-ccnt0&&ccnt1_cur-ccnt0_cur==ccnt1-ccnt0
	}		
	JS_isUnmodifiedBase=function(JSContext JS){
		ccnt0=JS.Param(0).as(i64);
		ccnt1=JS.Param(1).as(i64);
		return JS.Return(isUnmodifiedBase(ccnt0,ccnt1))
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportMethod(this,"discard",JS_discard)
		proto.ExportMethod(this,"RangeQuery",JS_RangeQuery)
		proto.ExportMethod(this,"CurrentToBase",JS_CurrentToBase)
		proto.ExportMethod(this,"CurrentToBoth",JS_CurrentToBoth)
		proto.ExportMethod(this,"BaseToCurrent",JS_BaseToCurrent)
		proto.ExportMethod(this,"isUnmodifiedBase",JS_isUnmodifiedBase)

///////////////////////////////
//base editor data structure
struct TBlockOp
	//delete first, add after
	i64 ccnt
	i64 sz
	string[] ss

class CSLNode
	CSLNode pchild
	CSLNode pnext
	//////////
	i64 ccnt
	string s
	i64[] a

struct TSLList
	CSLNode phead
	CSLNode ptail
	inline cat(TSLList b)
		if !phead:return b
		if !b.phead:return TSLList(){phead:phead,ptail:ptail}
		ret=TSLList()
		ret.phead=phead
		ptail.pnext=b.phead
		ret.ptail=b.ptail
		return ret

struct TEditop
	//delete first, add after
	i64 ccnt
	i64 sz
	string s

//this will be directly passed to JS... research class wrapping
class CLocator
	i64 ccnt
	i8 side
	i8 undo_tracked
	i8 discarded
	discard=function(JSContext JS){
		discarded=i8(1)
		return 0
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"ccnt")
		proto.ExportProperty(this,"side")
		proto.ExportProperty(this,"undo_tracked")
		proto.ExportMethod(this,"discard",discard)

HL_DISPLAY_MODE_RECT=0
HL_DISPLAY_MODE_RECTEX=1
class CHLRange
	CLocator p0
	CLocator p1
	int color
	i16 category
	i8 invertible
	i8 discarded
	i16 depth
	i8 display_mode
	i8 display_param
	discard=function(JSContext JS){
		discarded=i8(1)
		return 0
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"p0")
		proto.ExportProperty(this,"p1")
		proto.ExportProperty(this,"color")
		proto.ExportProperty(this,"invertible")
		proto.ExportProperty(this,"category")
		proto.ExportProperty(this,"depth")
		proto.ExportProperty(this,"display_mode")
		proto.ExportProperty(this,"display_param")
		proto.ExportMethod(this,"discard",discard)

struct TLocatorUndoItem
	//test undo_tracked...
	CLocator loc
	i64 ccnt

struct TUndoItem
	TEditop[] ops
	TLocatorUndoItem[] locs

SKIPLIST_PROMOTION_PROBABILITY=0.25f//1.0/2.71828
//the internal methods *should not* validate parameters
g_unicode_wordchars=[170,171,181,182,186,187,192,215,216,247,248,706,710,722,736,741,748,749,750,751,880,885,886,894,895,896,902,903,904,1014,1015,1154,1162,1370,1377,1416,1488,1523,1568,1611,1632,1642,1646,1648,1649,1748,1749,1750,1765,1767,1774,1789,1791,1792,1808,1809,1810,1840,1869,1958,1969,2027,2036,2038,2042,2070,2074,2075,2084,2085,2088,2089,2112,2137,2208,2227,2308,2362,2365,2366,2384,2385,2392,2402,2406,2416,2417,2433,2437,2490,2493,2494,2510,2511,2524,2530,2534,2546,2565,2618,2649,2672,2674,2677,2693,2746,2749,2750,2768,2786,2790,2800,2821,2874,2877,2878,2908,2914,2918,2928,2929,2930,2947,3002,3024,3025,3046,3056,3077,3134,3160,3170,3174,3184,3205,3258,3261,3262,3294,3298,3302,3315,3333,3390,3406,3407,3424,3426,3430,3440,3450,3456,3461,3527,3558,3568,3585,3633,3634,3636,3648,3655,3664,3674,3713,3761,3762,3764,3773,3783,3792,3841,3872,3882,3904,3949,3976,3981,4096,4139,4159,4170,4176,4182,4186,4190,4193,4194,4197,4199,4206,4209,4213,4226,4238,4239,4240,4250,4256,4347,4348,4955,4992,5008,5024,5109,5121,5741,5743,5760,5761,5787,5792,5867,5873,5906,5920,5938,5952,5970,5984,6001,6016,6068,6103,6104,6108,6109,6112,6122,6160,6313,6314,6431,6470,6572,6593,6600,6608,6618,6656,6679,6688,6741,6784,6810,6823,6824,6917,6964,6981,7002,7043,7073,7086,7142,7168,7204,7232,7294,7401,7405,7406,7410,7413,7415,7424,7616,7680,8125,8126,8127,8130,8141,8144,8156,8160,8173,8178,8189,8255,8257,8276,8277,8305,8306,8319,8320,8336,8349,8450,8451,8455,8456,8458,8468,8469,8470,8473,8478,8484,8485,8486,8487,8488,8489,8490,8494,8495,8506,8508,8512,8517,8522,8526,8527,8579,8581,11264,11493,11499,11503,11506,11508,11520,11632,11648,11743,11823,11824,12293,12295,12337,12342,12347,12349,12353,12439,12445,12448,12449,12539,12540,12687,12704,12731,12784,12800,13312,19894,19968,42125,42192,42238,42240,42509,42512,42607,42623,42654,42656,42726,42775,42784,42786,42889,42891,43010,43011,43014,43015,43019,43020,43043,43072,43124,43138,43188,43216,43226,43250,43256,43259,43302,43312,43335,43360,43389,43396,43443,43471,43482,43488,43493,43494,43561,43584,43587,43588,43596,43600,43610,43616,43639,43642,43643,43646,43696,43697,43698,43701,43703,43705,43710,43712,43713,43714,43742,43744,43755,43762,43765,43777,43867,43868,44003,44016,55292,63744,64286,64287,64297,64298,64434,64467,64830,64848,65020,65075,65077,65101,65104,65136,65277,65296,65306,65313,65339,65343,65344,65345,65371,65382,65501,65536,65787,66176,66257,66304,66336,66352,66369,66370,66378,66384,66422,66432,66462,66464,66512,66560,66916,67072,67670,67680,67703,67712,67743,67840,67862,67872,67898,67968,68097,68112,68148,68192,68221,68224,68253,68288,68296,68297,68325,68352,68406,68416,68438,68448,68467,68480,68498,68608,68681,69635,69688,69734,69744,69763,69808,69840,69882,69891,69927,69942,69952,69968,70003,70006,70007,70019,70067,70081,70085,70096,70107,70144,70188,70320,70367,70384,70394,70405,70458,70461,70462,70493,70498,70784,70832,70852,70854,70855,71087,71168,71216,71236,71339,71360,71914,71935,74649,77824,92778,92880,92910,92928,92976,92992,92996,93008,93018,93027,94033,94099,113818,119808,120513,120514,120539,120540,120571,120572,120597,120598,120629,120630,120655,120656,120687,120688,120713,120714,120745,120746,120771,120772,125125,126464,126652,131072,195102]
//g_states_time_leaf=new double[8]
class CEditableText
	m_skiplist=new CSLNode(){s:new string}
	m_locators=new CLocator[]
	m_highlights=new CHLRange[]
	m_diff_trackers=new CDiffTracker[]
	m_layout_valid_to=0L
	////////////////////
	m_handlers=new ITextStateHandler[]
	m_state_ofs=new iptr[]
	//m_hid_renderer=-1L
	m_is_line_only=0
	m_context_size=0
	m_block_size=1024
	m_js=JSContext.NULL
	m_handler_registration=JSObject.NULL
	//////////
	m_caret_locator=CLocator.NULL
	m_IME_overlay=JSObject.NULL
	m_other_overlay=JSObject.NULL
	m_caret_offset=0.
	//////////
	//m_ascii_wordchars=uint4()
	inline AddStateHandler(a)
		m_handlers.push(getInterface(a,ITextStateHandler))
		return m_handlers.n-1
	auto Init(JSObject obj_style)
		m_js=obj_style.m_jsctx
		m_handler_registration=m_js.New()
		ofs=0L
		foreach hstate,I in m_handlers
			hstate.id=I
			if hstate.SetTextStyle:
				//we need to initialize it before calling anything else
				hstate.SetTextStyle(obj_style)
			if hstate.isLineOnly&&hstate.isLineOnly():
				m_is_line_only=1
			m_state_ofs.push(ofs)
			ofs+=hstate.stateSize()
			///////////
			if hstate.contextSize:
				context_size=hstate.contextSize()
				if m_context_size<context_size:m_context_size=context_size
			///////////
			m_handler_registration[hstate.name()]=I
		//m_handler_registration["m_is_line_only"]=m_is_line_only
		m_state_ofs.push(ofs)
		RecomputeStatesLeaf(new char[m_context_size],m_skiplist)
		//m_handler_registration["style"]=obj_style
		//m_ascii_wordchars=MakeCharSet(obj_style["charset_word"].or("0-9A-Za-z_"))
		//validation
		hid=m_handler_registration["renderer"].or(-1)
		if hid<0:
			//validation failed
			return 0
		return 1
	auto RecomputeStatesDfs(CSLNode nd,i64 ccnt_base,i64[] ccnt_range,iptr p_range)
		if nd.s:
			if m_context_size:
				context_size=m_context_size
				ccnt_context0=max(ccnt_base-i64(context_size),0LL)
				s_context=GetText(ccnt_context0,min(ccnt_base-ccnt_context0,m_skiplist.ccnt))
				if s_context.n<context_size:
					s_context=(['\n' for i=0:context_size-s_context.n-1])+s_context
				//if s_context.n<context_size:
				//	s_context="\n"+s_context;
			else
				s_context=string.NULL
			RecomputeStatesLeaf(s_context,nd)
			return
		ccnt=ccnt_base
		p=p_range
		for(pc=nd.pchild;pc;pc=pc.pnext)
			while p<ccnt_range.n:
				range0=ccnt_range[p]
				range1=range0+ccnt_range[p+1]
				if ccnt<range1&&range0<ccnt+pc.ccnt:
					//there is overlap, recurse
					RecomputeStatesDfs(pc,ccnt,ccnt_range,p)
					break
				else if range1<=ccnt:
					p+=2
				else
					break
			//if we recomputed, !pc.a can't possibly hold
			if !pc.a:
				RecomputeStatesDfs(pc,ccnt,ccnt_range,p)
			ccnt+=pc.ccnt
		RecomputeStatesInner(nd)
	auto RecomputeStatesInner(CSLNode nd)
		n=m_state_ofs.back()
		ccnt=0LL
		a=new i64[n]
		for(pc=nd.pchild;pc;pc=pc.pnext)
			foreach hstate,I in m_handlers
				hstate.Add(a[m_state_ofs[I]:m_state_ofs[I+1]-1],pc.a[m_state_ofs[I]:m_state_ofs[I+1]-1])
			ccnt+=pc.ccnt
		nd.a=a
		nd.ccnt=ccnt
	auto RecomputeCcntInner(CSLNode nd)
		n=m_state_ofs.back()
		ccnt=0LL
		for(pc=nd.pchild;pc;pc=pc.pnext)
			ccnt+=pc.ccnt
		nd.ccnt=ccnt
		nd.a=i64[].NULL
	auto RecomputeStatesLeaf(string s_context0,CSLNode nd)
		n=m_state_ofs.back()
		ccnt=0LL
		s=nd.s
		a=new i64[n+m_handlers.n]
		ccnt=i64(s.n)
		foreach hstate,I in m_handlers
			a_slice=a[m_state_ofs[I]:m_state_ofs[I+1]-1]
			block_state=i64[].NULL
			if hstate.PreprocessBlock:
				block_state=hstate.PreprocessBlock(this,a_slice,s)
			if hstate.contextSize:
				context_size=hstate.contextSize()
				s_context=s_context0[s_context0.n-context_size:]
			else
				s_context=string.NULL
			//t0=System.Time.tick64()
			hstate.AddString(a_slice,block_state,s_context,s,s.n)
			//g_states_time_leaf[I]+=System.Time.TicksToSeconds(System.Time.tick64()-t0)*1000.0
			a_slice.discard()
			a[n+I]=i64(a.n)
			if block_state:
				a.push(block_state)
		//Writeln('    states: ',System.Time.TicksToSeconds(System.Time.tick64()-t0)*1000.0)
		nd.a=a
		nd.ccnt=ccnt
	auto BlockFromCcnt(i64 ccnt0)
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				nd=nd.pnext
			if nd.s:
				return (nd,ccnt0-ccnt_base)
			assert(!!nd.pchild)
			nd=nd.pchild
	auto GetContextBefore(ITextStateHandler handler,i64 ccnt_base)
		if handler.contextSize:
			context_size=handler.contextSize()
			ccnt_context0=max(ccnt_base-i64(context_size),0LL)
			s_context=GetText(ccnt_context0,min(ccnt_base-ccnt_context0,m_skiplist.ccnt))
			if s_context.n<context_size:
				s_context="\n"+s_context;
			//if s_context.n<context_size:
			//	s_context=(new char[context_size-s_context.n])+s_context
		else
			s_context=string.NULL
		return s_context
	auto GetPrecomputedStates(ITextStateHandler handler,CSLNode nd)
		n0=m_state_ofs.back()
		ofspp=nd.a[n0+handler.id]
		ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
		return nd.a[iptr(ofspp):iptr(ofspp2)-1]
	auto GetStateAt(int hid,i64 ccnt0)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		handler=m_handlers[hid]
		///////////
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
				nd=nd.pnext
			if nd.s:
				handler.AddString(acc,GetPrecomputedStates(handler,nd),GetContextBefore(handler,ccnt_base),nd.s,iptr(ccnt0-ccnt_base))
				if iptr(ccnt0-ccnt_base)==nd.s.n&&handler.contextSize:
					//oops, it seems we're at EOF, add an empty string to make sure the trailing token is added properly
					handler.AddString(acc,GetPrecomputedStates(handler,nd),GetContextBefore(handler,ccnt0),"\n",0L)
				return acc
			assert(!!nd.pchild)
			nd=nd.pchild
	auto GetStateEnMasse(int hid,i64[] all_ccnt)
		handler=m_handlers[hid]
		szacc=m_state_ofs[hid+1]-m_state_ofs[hid]
		ret=new i64[szacc*all_ccnt.n]
		auto dfs(i64[] acc0,i64 ccnt_base0,CSLNode nd0,int p0x,int p1)
			auto ccnt_base=ccnt_base0
			auto acc=new(acc0)
			auto p0=p0x
			auto nd=nd0
			for(;;)
				p=p0
				while p<p1&&all_ccnt[p]<ccnt_base+nd.ccnt:
					p++
				if p0<p:
					if nd.s:
						pp=GetPrecomputedStates(handler,nd)
						s_context=GetContextBefore(handler,ccnt_base)
						s=nd.s
						if handler.isLineOnly():
							//line-only renderers need to preprocess the input, and you can't partition the string
							//for the fancier renderers, it could even be algorithmically impossible
							for i=p0:p-1
								acc2=new(acc)
								ofs=iptr(all_ccnt[i]-ccnt_base)
								handler.AddString(acc2,pp,s_context,s,ofs)
								copy(ret[i*szacc:],acc2)
						else
							acc2=new(acc)
							ccnt_base2=ccnt_base
							for i=p0:p-1
								ofs=iptr(all_ccnt[i]-ccnt_base2)
								//note: the code editor colorer will *ignore* the last token in a block
								//and for accumulation correctness, we can't add it here
								//the top-level UI shouldn't use GetStateEnMasse for that
								handler.AddString(acc2,pp,s_context,s,ofs)
								copy(ret[i*szacc:],acc2)
								if s_context:
									n0=s_context.n
									s_context.push(s[:ofs-1])
									s_context=new(s_context[s_context.n-n0:])
								s=s[ofs:]
								ccnt_base2+=i64(ofs)
					else
						dfs(acc,ccnt_base,nd.pchild,p0,p)
				p0=p
				if p0>=p1:break
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
				nd=nd.pnext
				if !nd:
					//out of bound, fill with acc
					for i=p0:p1-1
						ofs=iptr(all_ccnt[i]-ccnt_base)
						copy(ret[i*szacc:],acc)
					break
		///////////
		dfs(new i64[szacc],0LL,m_skiplist,0,int(all_ccnt.n))
		return ret
	auto GetXYEnMasse(i64[] ccnts)
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		a=GetStateEnMasse(hid,ccnts)
		szacc=m_state_ofs[hid+1]-m_state_ofs[hid]
		n=ccnts.n
		reti=new i64[n*2]
		for i=0:n-1
			if handler.GetXYFromState:
				xy=handler.GetXYFromState(this,a[szacc*i:szacc*i+szacc-1])
				x=xy.x
				y=xy.y
			else
				x=a[szacc*i+0]
				y=a[szacc*i+1]
			reti[i*2+0]=x
			reti[i*2+1]=y
		return reti
	auto GetCharacterHeightAt(i64 ccnt0)
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		///////////
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
				nd=nd.pnext
			if nd.s:
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+handler.id]
				ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
				return handler.GetCharacterHeightAt(ccnt_base,acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,iptr(ccnt0-ccnt_base))
			assert(!!nd.pchild)
			nd=nd.pchild
	auto skipListPromote(TSLList nds_ret0, TSLList nds_child0,TSLList nds_toadd,CSLNode nd_ignore)
		nds_ret=nds_ret0
		nds_child=nds_child0
		pc_pnext=CSLNode.NULL
		for(pc=nds_toadd.phead;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			if iptr(pc)!=iptr(nd_ignore)&&nds_child.phead&&System.Algorithm.Random(float)<SKIPLIST_PROMOTION_PROBABILITY:
				//finish off the dangling chain
				nds_child.ptail.pnext=CSLNode.NULL
				nds_ret.ptail.pchild=nds_child.phead
				RecomputeCcntInner(nds_ret.ptail)
				//actually promote pc
				nd_new=new CSLNode
				nds_ret.ptail.pnext=nd_new
				nds_ret.ptail=nd_new
				nds_child=TSLList(){phead:pc,ptail:pc}
			else
				if !nds_child.phead:
					nds_child.phead=pc
					//nds_child.ptail=pc
				else
					nds_child.ptail.pnext=pc
				nds_child.ptail=pc
		return (nds_ret,nds_child)
	auto skipListPromoteToRoot(TSLList nds_toadd0)
		nds_toadd=nds_toadd0
		for(;;)
			if iptr(nds_toadd.phead)==iptr(nds_toadd.ptail)&&!nds_toadd.phead.s:
				assert(!nds_toadd.phead.pnext)
				return nds_toadd.phead
			//promote the head
			nd_new=new CSLNode
			nds_ret=TSLList(){phead:nd_new,ptail:nd_new}
			nds_child=TSLList(){phead:nds_toadd.phead,ptail:nds_toadd.phead}
			nds_toadd.phead=nds_toadd.phead.pnext
			//add the rest
			(nds_ret,nds_child)=skipListPromote(nds_ret,nds_child,nds_toadd,CSLNode.NULL)
			nds_ret.ptail.pchild=nds_child.phead;nds_child.ptail.pnext=CSLNode.NULL
			RecomputeCcntInner(nds_ret.ptail)
			//recurse one level up
			nds_toadd=nds_ret
	auto BlockEdit(int debug_level,CSLNode nd,i64 ccnt_base0,TBlockOp[] bops,iptr pbops0,iptr pbops1)
		assert(!nd.s)
		//for each child -> untouched / new list (on which we apply random growth)
		//so the return value is a list
		p=pbops0
		ccnt_base=ccnt_base0
		//nds_ret.ptail.pchild is the dangling part represented by nds_child
		nds_ret=TSLList(){phead:nd,ptail:nd}
		nds_child=TSLList()
		pc_pnext=CSLNode.NULL
		for(pc=nd.pchild;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			pc_ccnt=pc.ccnt
			//Writeln(debug_level,' ',formatNumber(iptr(pc),{align:8,base:16}),' ',pc_ccnt)
			//intersect cut bops with the child
			p0=p
			while p<pbops1&&bops[p].ccnt<ccnt_base+pc.ccnt:
				p++
			//assert(p==bops.n||bops[p].ccnt==ccnt_base+pc.ccnt)
			//each bop could cover *multiple* children... need to test it
			//Writeln('>>> ',formatNumber(iptr(pc),{base:16,align:8}),' ',formatNumber(iptr(pc_pnext),{base:16,align:8}),' ',p0,' ',p,' ',ccnt_base,' ',pc.ccnt)
			if p0<p:
				bk=bops[p-1]
				bk2=bops[p0]
				bops[p-1].sz=min(ccnt_base+pc.ccnt-bops[p-1].ccnt,bops[p-1].sz)
				if bops[p-1].sz<bk.sz:
					bops[p-1].ss=string[].NULL
				bops[p0].sz+=bops[p0].ccnt
				bops[p0].ccnt=max(ccnt_base,bops[p0].ccnt)
				bops[p0].sz-=bops[p0].ccnt
				assert(bops[p-1].sz>0LL)
				assert(bops[p0].sz>0LL)
				if p0==p-1&&(!bops[p0].ss||ccnt_base+pc.ccnt<bops[p0].ccnt+bops[p0].sz)&&bops[p0].ccnt==ccnt_base&&bops[p0].sz==pc.ccnt:
					//completely deleted, discard the child
					//do nothing here but continue on with the loop code
				else
					pc.pnext=CSLNode.NULL//this is required
					if pc.s:
						assert(p0==p-1)
						assert(!!bops[p0].ss)
						assert(bops[p0].ccnt==ccnt_base)
						nds_pc=TSLList()
						foreach s in bops[p0].ss
							nd_new=new CSLNode(){s:s,ccnt:s.n}
							if !nds_pc.phead:
								nds_pc.phead=nd_new
							else
								nds_pc.ptail.pnext=nd_new
							nds_pc.ptail=nd_new
						//Writeln(formatNumber(iptr(nds_pc.phead),{base:16,align:8}),' ',formatNumber(iptr(nds_pc.ptail),{base:16,align:8}))
						if bops[p0].sz:
							//throw away pc
							assert(bops[p0].sz==pc.ccnt)
						else
							//keep it
							nds_pc=nds_pc.cat(TSLList(){phead:pc,ptail:pc})
					else
						//nds_pc=BlockEdit(debug_level+1,pc,ccnt_base,bops[p0:p-1])
						nds_pc=BlockEdit(debug_level+1,pc,ccnt_base,bops,p0,p)
					(nds_ret,nds_child)=skipListPromote(nds_ret, nds_child,nds_pc,pc)
				bops[p0]=bk2
				bops[p-1]=bk
				//the last bop covers multiple segments
				if ccnt_base+pc_ccnt<bops[p-1].ccnt+bops[p-1].sz:
					p--
			else
				pc.pnext=CSLNode.NULL
				nds_child=nds_child.cat(TSLList(){phead:pc,ptail:pc})
			ccnt_base+=pc_ccnt
		//coulddo: removing nd itself
		nds_ret.ptail.pchild=nds_child.phead;
		if nds_child.ptail:nds_child.ptail.pnext=CSLNode.NULL
		RecomputeCcntInner(nds_ret.ptail)
		return nds_ret
	auto SortLocators()
		need_sort=0
		n2=0L
		ccnt_current=0L
		foreach loc,I in m_locators
			if !loc.discarded:
				m_locators[n2++]=loc
				if loc.ccnt<ccnt_current:
					need_sort=1
				ccnt_current=loc.ccnt
		m_locators.resize(n2)
		if need_sort:
			m_locators.Sortby(inline(loc){return loc.ccnt})
	auto RawEdit(TEditop[] ops)
		//editop -> block replace: mainly take-the-next-and-merge
		//do the locators here
		pb=CSLNode.NULL
		ccnt_base=0LL
		ofs=0LL
		//////////
		SortLocators()
		ploc=0L
		pops=0L
		lside_tar=0LL
		rside_tar=0LL
		delta=0LL
		while ploc<m_locators.n&&pops<ops.n:
			ccnt0=ops[pops].ccnt
			ccnt1=ccnt0+ops[pops].sz
			loc=m_locators[ploc]
			ccnt_loc=loc.ccnt
			if ccnt_loc<ccnt0:
				//it didn't overlap anything
				loc.ccnt+=delta
				ploc++
				continue
			lside_tar=ccnt0+delta
			rside_tar=ccnt0+delta
			if ops[pops].s:rside_tar+=ops[pops].s.n
			if ccnt_loc<=ccnt1:
				//it overlapped the deletion
				if loc.side<1||ccnt_loc<ccnt1:
					//push left
					loc.ccnt=lside_tar
				else
					//push right
					loc.ccnt=rside_tar
				ploc++
				continue
			else
				//we're still to the left of the locator
				if ops[pops].s:delta+=ops[pops].s.n
				delta+=ccnt0-ccnt1
				pops++
		while ploc<m_locators.n
			loc=m_locators[ploc]
			loc.ccnt+=delta
			ploc++
		//////////
		bops=new TBlockOp[]
		bop_current=TBlockOp()
		s_pool=new string
		s_pool_last_newline=0L
		//s_pool_has_bidi_bound=0
		auto poolString(string s)
			if !s.n:return
			auto p_last_flush=0L
			auto p_last_newline=s_pool_last_newline
			auto p=s_pool.n
			auto addBlock(iptr p0,iptr p1)
				p_last_flush=p1
				//Writeln('addBlock: ',p0,' ',p1)
				//virtual string access
				auto s_block=string.NULL
				if p1<=s_pool.n:
					s_block=new(s_pool[p0:p1-1])
				else if p0>=s_pool.n:
					s_block=new(s[p0-s_pool.n:p1-s_pool.n-1])
				else
					s_block=s_pool[p0:]+s[:p1-s_pool.n-1]
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
			foreach chc,I in s
				ch=int(u8(chc))
				if (ch&0xc0)!=0x80&&!(s_pool.n&&s_pool.back()=='\r'&&ch=='\n'):
					//check for block breaking, but do not break UTF-8 chars or \r\n
					if p-p_last_flush>=m_block_size&&(!m_is_line_only||p_last_newline>p_last_flush):
						//need a break...
						if p_last_newline>p_last_flush:
							//we got newlines in the block, we can only break at s_pool_last_newline
							addBlock(p_last_flush,p_last_newline)
						else
							//it's a single-line block...
							addBlock(p_last_flush,p)
				p++//s_pool.push(chc)
				if ch=='\n':
					p_last_newline=p
			//virtual -> real
			if p_last_flush<s_pool.n:
				s_pool=s_pool[p_last_flush:]+s
			else
				s_pool=new(s[p_last_flush-s_pool.n:])
			s_pool_last_newline=max(p_last_newline-p_last_flush,0L)
		auto flush()
			if pb&&pb.s.n:
				if ofs<pb.s.n:
					poolString(pb.s[iptr(ofs):])
					bop_current.sz+=i64(pb.s.n)-ofs
				else
					//assert last block
			//if s_pool_last_newline:
			//	s_block=new(s_pool[:s_pool_last_newline-1])
			//	if !bop_current.ss:
			//		bop_current.ss=new string[]
			//	bop_current.ss.push(s_block)
			//	s_pool=new(s_pool[s_pool_last_newline:])
			//	s_pool_last_newline=0L
			if s_pool.n:
				//assert(!m_is_line_only)//or end of text... which is untestable here
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_pool)
			if bop_current.sz||bop_current.ss:
				bops.push(bop_current)
				bop_current=TBlockOp()
				//Writeln('after push: ',iptr(bop_current.ss))
			s_pool=new string
			s_pool_last_newline=0L
		foreach op in ops
			if !pb||ccnt_base+pb.ccnt<op.ccnt:
				//we've left the current block, need to reseek
				(pb2,ofs2)=BlockFromCcnt(op.ccnt)
				//if pb:Writeln('>>> ',op.ccnt-ofs2,' ',ccnt_base+pb.ccnt)
				if pb&&op.ccnt-ofs2==ccnt_base+pb.ccnt:
					//don't flush if it's the immediately following block - we gotta merge that anyway
					//just merge the tail, the remaining code should finish the rest
					//Writeln('immediate next')
					is_immediate_after=1
					poolString(pb.s[iptr(ofs):])
				else
					is_immediate_after=0
					flush()
				pb=pb2
				ccnt_base=op.ccnt-ofs2
				if !is_immediate_after:
					bop_current.ccnt=ccnt_base
				ofs=0LL
			ofs_new=i64(op.ccnt-ccnt_base)
			if ofs_new>ofs:
				poolString(pb.s[iptr(ofs):iptr(ofs_new)-1])
				ofs=ofs_new
				assert(ofs<=pb.ccnt)
				if ofs==pb.ccnt:
					//merge with the next block - it's mandatory for line-only guys
					ccnt_base+=ofs
					(pb,ofs)=BlockFromCcnt(ccnt_base)
					if ofs==pb.ccnt:
						//do nothing, it's the tail
					else
						assert(!ofs)
						ofs=0LL
			//move by sz
			if op.sz:
				ofs+=op.sz
				if ofs>=pb.ccnt:
					(pb,ofs)=BlockFromCcnt(op.ccnt+op.sz)
					ccnt_base=op.ccnt+op.sz-ofs
			bop_current.sz=op.ccnt+op.sz-bop_current.ccnt
			if op.s:poolString(op.s)
		flush()
		//Writeln(ops)
		//Writeln(bops)
		//Writeln('---------------------------------------------------------')
		//foreach bop in bops
		//	Writeln(bop.ccnt,' ',bop.sz,' ',iptr(bop.ss))
		//block replace -> skiplist edit
		if m_skiplist.ccnt:
			nds_pc=BlockEdit(0,m_skiplist,0LL,bops,0L,bops.n)
		else
			nds_pc=TSLList()
			foreach bop in bops
				foreach s in bop.ss
					nd_new=new CSLNode(){s:s,ccnt:s.n}
					if !nds_pc.phead:
						nds_pc.phead=nd_new
					else
						nds_pc.ptail.pnext=nd_new
					nds_pc.ptail=nd_new
		m_skiplist=skipListPromoteToRoot(nds_pc)
		assert(!m_skiplist.pnext)
		if !m_skiplist.ccnt:
			m_skiplist=new CSLNode(){s:new string}
			RecomputeStatesLeaf(new char[m_context_size],m_skiplist)
		else
			delta=0LL
			ccnt0_current=-1LL
			sz_current=0LL
			restate_ranges=new i64[]
			foreach bop in bops
				ccnt_inserted=0LL
				if bop.ss:
					foreach s in bop.ss
						ccnt_inserted+=i64(s.n)
				ccnt=bop.ccnt+delta
				sz_influenced=ccnt_inserted+i64(m_context_size)
				delta+=ccnt_inserted-bop.sz
				if ccnt<=ccnt0_current+sz_current:
					sz_current=ccnt+sz_influenced-ccnt0_current
				else
					if ccnt0_current>=0LL:
						restate_ranges.push(ccnt0_current)
						restate_ranges.push(sz_current)
					ccnt0_current=ccnt
					sz_current=sz_influenced
			if ccnt0_current>=0LL:
				restate_ranges.push(ccnt0_current)
				restate_ranges.push(sz_current)
			RecomputeStatesDfs(m_skiplist,0LL,restate_ranges,0L)
		//Writeln('    leaf: ',g_states_time_leaf);g_states_time_leaf=new double[8]
		sz_text_new=GetTextSize()
		m_block_size=1024
		if sz_text_new>128<<20:
			m_block_size=8192
		else if sz_text_new>16<<20:
			m_block_size=4096
		else if sz_text_new>1<<20:
			m_block_size=2048
	inline InvalidateStates(i64[] ccnt_range)
		RecomputeStatesDfs(m_skiplist,0LL,ccnt_range,0)
	auto _GetText(string buf,iptr ofs, CSLNode nd,i64 ccnt0,i64 ccnt1)
		if nd.s:
			copy(buf[ofs:],nd.s[iptr(ccnt0):iptr(ccnt1-1LL)])
		else
			ccnt_base=0LL
			for(pc=nd.pchild;pc;pc=pc.pnext)
				p0=max(ccnt0-ccnt_base,0LL)
				p1=min(ccnt1-ccnt_base,pc.ccnt)
				if p1>p0:
					_GetText(buf,ofs+iptr(max(ccnt_base-ccnt0,0LL)), pc,p0,p1)
				ccnt_base+=pc.ccnt
	auto GetText(i64 ccnt,i64 sz)
		buf=new char[sz]
		_GetText(buf,0L, m_skiplist,ccnt,ccnt+sz)
		return buf
	inline GetTextSize()
		return m_skiplist.ccnt
	////////////////////////////////////
	//undo/redo enabled editing
	m_undo_queue=new TUndoItem[]
	m_redo_queue=new TUndoItem[]
	auto InvertEditops(TEditop[] ops)
		//Here we assume ops is sorted
		ops2=new TEditop[ops.n]
		delta=0LL
		foreach op,I in ops
			op2=op
			op2.ccnt+=delta
			if op.sz:
				op2.s=GetText(op.ccnt,op.sz)
				delta-=op.sz
			else
				op2.s=string.NULL
			if op.s:
				op2.sz=i64(op.s.n)
				delta+=i64(op.s.n)
			else
				op2.sz=0LL
			ops2[I]=op2
		return ops2
	auto UndoableEdit(TEditop[] ops,TUndoItem[] queue)
		locs=new TLocatorUndoItem[]
		foreach loc,I in m_locators
			if loc.undo_tracked:
				locs.push(TLocatorUndoItem(){loc:loc,ccnt:loc.ccnt})
		queue.push(TUndoItem(){ops:InvertEditops(ops),locs:locs})
		RawEdit(ops)
	auto Edit(TEditop[] ops)
		m_redo_queue.discard()
		UndoableEdit(ops,m_undo_queue)
		///////////////////////
		//normal edit for diff tracking
		n2=0L
		foreach diff in m_diff_trackers
			if diff.m_skiplist:
				diff.Edit(ops,0)
				m_diff_trackers[n2++]=diff
		m_diff_trackers.resize(n2)
	auto LoaderEdit(TEditop[] ops)
		RawEdit(ops)
		n2=0L
		foreach diff in m_diff_trackers
			if diff.m_skiplist:
				diff.Edit(ops,1)
				m_diff_trackers[n2++]=diff
		m_diff_trackers.resize(n2)
	auto RawUndo(TUndoItem[] queue_in,TUndoItem[] queue_out)
		uitem=queue_in.pop()
		///////////////////////
		//undo for diff tracking
		n2=0L
		foreach diff in m_diff_trackers
			if diff.m_skiplist:
				if iptr(queue_in)==iptr(m_undo_queue):
					diff.Undo(uitem.ops)
				else
					diff.Redo(uitem.ops)
				m_diff_trackers[n2++]=diff
		m_diff_trackers.resize(n2)
		///////////////
		UndoableEdit(uitem.ops,queue_out)
		foreach loci in uitem.locs
			loci.loc.ccnt=loci.ccnt
		//single-insert special case: return the info in the API, select it in js code
		ret=long2(-1LL,-1LL)
		if uitem.ops.n>=1:
			if uitem.ops[0].s&&uitem.ops[0].s.n:
				ret=long2(uitem.ops[0].ccnt,i64(uitem.ops[0].s.n))
			else
				ret=long2(uitem.ops[0].ccnt,0LL)
		return ret
	inline Undo()
		return RawUndo(m_undo_queue,m_redo_queue)
	inline Redo()
		return RawUndo(m_redo_queue,m_undo_queue)
	////////////////////////////////////
	/*
	how exactly do we do a backward bracket lookup? the thing is state-dependent and *not* monotone!
		--
		start-from-zero min/count evaluation
			evaluate front-to-back
			or we could evaluate and Compare front-to-back
				then search back-to-front for the last 1
		and a contexted per-char version
			SeekInBlock
				the ccnt anchor / search type could be included in b
		it's a non-bisect search using an "or" hierarchy
		--
	*/
	auto _Bisect(i64[] acc, int hid,i64 ccnt_base0,CSLNode nd,i64[] b)
		handler=m_handlers[hid]
		if nd.s:
			n0=m_state_ofs.back()
			ofspp=nd.a[n0+handler.id]
			ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
			return ccnt_base0+i64(handler.SeekInBlock(this,ccnt_base0,acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,b))
		else
			ccnt_base=ccnt_base0
			acc2=new(acc)
			for(pc=nd.pchild;pc;pc=pc.pnext)
				copy(acc2,acc)
				handler.Add(acc2,pc.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
				if handler.Compare(this,acc2,b)>0:
					acc2=i64[].NULL
					return _Bisect(acc, hid,ccnt_base,pc,b)
				copy(acc,acc2)
				ccnt_base+=pc.ccnt
			return ccnt_base
	auto Bisect(int hid,i64[] b)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		return _Bisect(acc,hid,0LL,m_skiplist,b)
	auto SeekXY(i64 x,i64 y)
		hid=m_handler_registration["renderer"].as(int)
		//ccnt0=Bisect(hid,[__double_as_longlong(x),__double_as_longlong(y)])
		//xy=XYFromCcnt(ccnt0)
		//return Bisect(hid,[__double_as_longlong(x),__double_as_longlong(xy.y)])
		ccnt0=Bisect(hid,[x,y])
		//the newline / invisible logic is in JS
		return ccnt0
	//////////////////////
	auto FindNearest(int hid,i64[] b,i64 ccnt0,int direction)
		handler=m_handlers[hid]
		ccnt=ccnt0
		//////////////////////////
		//same-block pass
		(nd,ofs)=BlockFromCcnt(ccnt)
		ccnt_base=ccnt-i64(ofs)
		acc_block=GetStateAt(hid,ccnt_base)
		cv_block=handler.QueryPerCharValidity(acc_block,GetPrecomputedStates(handler,nd),GetContextBefore(handler,ccnt_base),nd.s,b)
		if direction<0:
			for i=min(iptr(ccnt-ccnt_base),cv_block.n-1):-1:0
				if cv_block[i]:
					return ccnt_base+i64(i)
			ccnt=ccnt_base
		else
			for i=iptr(ccnt-ccnt_base):cv_block.n-1
				if cv_block[i]:
					return ccnt_base+i64(i)
			ccnt=ccnt_base+nd.ccnt
		//not in the current block
		//dfs pass
		auto dfsNearest(CSLNode nd,i64[] acc0,i64 ccnt_base0)
			auto ccnt_base=ccnt_base0
			if nd.s:
				cv_block=handler.QueryPerCharValidity(acc0,GetPrecomputedStates(handler,nd),GetContextBefore(handler,ccnt_base),nd.s,b)
				if direction<0:
					for i=cv_block.n-1:-1:0
						if cv_block[i]:
							return ccnt_base+i64(i)
				else
					for i=0:cv_block.n-1
						if cv_block[i]:
							return ccnt_base+i64(i)
			else
				auto acc=new(acc0)
				if direction<0:
					all_accs=new i64[][]
					all_ccnts=new i64[]
					all_pcs=new CSLNode[]
				for(pc=nd.pchild;pc;pc=pc.pnext)
					da=pc.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1]
					if direction<0:
						if ccnt_base>=ccnt:
							break
						if handler.hasValidResult(acc,da,b):
							all_accs.push(new(acc))
							all_ccnts.push(ccnt_base)
							all_pcs.push(pc)
					else
						if ccnt<ccnt_base+pc.ccnt:
							if handler.hasValidResult(acc,da,b):
								ret=dfsNearest(pc,acc,ccnt_base)
								if ret!=-1LL:
									return ret
					handler.Add(acc,da)
					ccnt_base+=pc.ccnt
				if direction<0:
					for i=all_pcs.n-1:-1:0
						ret=dfsNearest(all_pcs[i],all_accs[i],all_ccnts[i])
						if ret!=-1LL:
							return ret
			return -1LL
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		return dfsNearest(m_skiplist,acc,0LL)
	//////////////////////
	auto Render(JSObject obj,i64 x,i64 y,i64 w,i64 h, float scr_x,float scr_y,float scale)
		//x,y,w,h refer to the world space window
		wf=fixed2float(w)
		hf=fixed2float(h)
		g_renderer.PushCliprect(scr_x,scr_y,wf*scale,hf*scale)
		hid_colorer=m_handler_registration["colorer"].or(-1)
		if hid_colorer>=0:
			handler_colorer=m_handlers[hid_colorer]
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		//Writeln('Render ',x,' ',y,' ',w,' ',h)
		wnd_ccnt0=SeekXY(x,y)
		wnd_ccnt1=SeekXY(x+w,y+h)
		rendering_started=0
		//Writeln('Render ',x,' ',y,' ',w,' ',h,' wnd ',wnd_ccnt0,' ',wnd_ccnt1)
		////////////////////////
		//fnt_bold_scaled=obj["font_emboldened"].as(TFont)
		//fnt_bold_scaled.h*=scale
		//scaled=double(scale)
		//dx=double(scr_x)-x*scaled
		//dy=double(scr_y)-y*scaled
		//////////////////////////////
		//prepare the achint
		caret_overlay=long3(-1LL,-1LL,0LL)
		if m_IME_overlay:
			m_IME_overlay["type"]="IME"
			xy_overlay=XYFromCcnt(m_caret_locator.ccnt)
			caret_overlay=long3(xy_overlay.x,xy_overlay.y,handler.SetCaretOverlay(this,xy_overlay.x,xy_overlay.y,m_IME_overlay))
		else if m_other_overlay:
			xy_overlay=XYFromCcnt(m_caret_locator.ccnt)
			caret_overlay=long3(xy_overlay.x,xy_overlay.y,handler.SetCaretOverlay(this,xy_overlay.x,xy_overlay.y,m_other_overlay))
		else
			handler.SetCaretOverlay(this,-1LL,-1LL,JSObject.NULL)
		//pre-draw the rect highlights
		//coulddo: text color inversion for high contrast highlight
		SortLocators()
		m_highlights.Sortby(inline(a){return a.depth})
		hl_to_seek=new i64[]
		n2=0L
		foreach hl in m_highlights
			if hl.discarded||hl.p0.discarded||hl.p1.discarded:continue
			m_highlights[n2++]=hl
			ccnt0=hl.p0.ccnt
			ccnt1=hl.p1.ccnt
			if ccnt1==ccnt0:continue
			if ccnt1<ccnt0:
				if !hl.invertible:continue
				(ccnt0,ccnt1)=(ccnt1,ccnt0)
			if ccnt1<=wnd_ccnt0||ccnt0>=wnd_ccnt1:continue
			hl_to_seek.push(ccnt0)
			hl_to_seek.push(ccnt1)
		m_highlights.resize(n2)
		if hl_to_seek.n:
			hl_to_seek.Sort()
			hl_xys=GetXYEnMasse(hl_to_seek)
			hl_xy_map=new long2[i64]
			for i=0:hl_to_seek.n-1
				hl_xy_map[hl_to_seek[i]]=long2(hl_xys[i*2+0],hl_xys[i*2+1])
		inline projectDocumentPosition(i64 ccnt)
			auto xy=hl_xy_map[ccnt]//XYFromCcnt(ccnt)
			auto ret
			if xy.y==caret_overlay.y&&xy.x>=caret_overlay.x:
				ret=xy+long2(caret_overlay.z,0LL)
			else
				ret=xy
			return float2(fixed2float(ret.x-x)*scale+scr_x,fixed2float(ret.y-y)*scale+scr_y)
		rr_styles=new TRRContext[]
		wf_hl=wf
		if handler.GetWrapWidth:
			wf_hl=min(wf_hl,fixed2float(handler.GetWrapWidth()-x))
		foreach hl in m_highlights
			ccnt0=hl.p0.ccnt
			ccnt1=hl.p1.ccnt
			if ccnt1==ccnt0:continue
			if ccnt1<ccnt0:
				if !hl.invertible:continue
				(ccnt0,ccnt1)=(ccnt1,ccnt0)
			if ccnt1<=wnd_ccnt0||ccnt0>=wnd_ccnt1:continue
			if int(hl.display_mode)==HL_DISPLAY_MODE_RECTEX:
				style_id=iptr(hl.display_param)
				while rr_styles.n<=style_id:
					rr_styles.push(TRRContext())
				if !rr_styles[style_id].is_valid:
					rr_styles[style_id]=g_renderer.CreateRRContext(obj["rectex_styles"][style_id].as(JSObject))
				rr_ctx=rr_styles[style_id]
				xy0=projectDocumentPosition(ccnt0)
				xy1=projectDocumentPosition(ccnt1)
				rr_dx=0.f
				if rr_ctx.border_width<0.f:
					rr_dx=-0.25f*rr_ctx.border_width
				if xy0.y==xy1.y:
					hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
					g_renderer.DrawRR(rr_ctx,xy0.x-rr_dx,xy0.y,xy1.x-xy0.x+rr_dx*2.f,hc)
				else
					//draw 3 rects, we have a cliprect, don't worry
					//coulddo: line-by-line drawing
					hc=fixed2float(GetCharacterHeightAt(ccnt0))*scale
					g_renderer.DrawRR(rr_ctx,xy0.x-rr_dx,xy0.y,max(scr_x+wf_hl*scale-xy0.x,0.f)+rr_dx*2.f,hc)
					for(y_rect=xy0.y+hc;y_rect<xy1.y;y_rect+=hc)
						if xy1.y-y_rect>1.f:
							g_renderer.DrawRR(rr_ctx,scr_x-rr_dx,y_rect,wf_hl*scale+rr_dx*2.f,min(xy1.y-y_rect,hc))
					hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
					g_renderer.DrawRR(rr_ctx,scr_x-rr_dx,xy1.y,max(xy1.x-scr_x,0.f)+rr_dx*2.f,hc)
			else if int(hl.display_mode)==HL_DISPLAY_MODE_RECT:
				xy0=projectDocumentPosition(ccnt0)
				xy1=projectDocumentPosition(ccnt1)
				//Writeln(xy0,' ',xy1,' ',ccnt0,' ',ccnt1,' ',formatNumber(u32(hl.color),{base:16,align:8}))
				//Writeln(__double_as_longlong(xy0.y)-__double_as_longlong(xy1.y))
				//Writeln(abs(__double_as_longlong(xy0.y)-__double_as_longlong(xy1.y)))
				//Writeln('epsEqual')
				if xy0.y==xy1.y:
					hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
					g_renderer.DrawRectangle(xy0.x,xy0.y,xy1.x-xy0.x,hc, hl.color)
				else
					//draw 3 rects, we have a cliprect, don't worry
					hc=fixed2float(GetCharacterHeightAt(ccnt0))*scale
					g_renderer.DrawRectangle(xy0.x,xy0.y,max(scr_x+wf_hl*scale-xy0.x,0.f),hc, hl.color)
					g_renderer.DrawRectangle(scr_x,xy0.y+hc,wf_hl*scale,max(xy1.y-(xy0.y+hc),0.f), hl.color)
					hc=fixed2float(GetCharacterHeightAt(ccnt1))*scale
					g_renderer.DrawRectangle(scr_x,xy1.y,max(xy1.x-scr_x,0.f),hc, hl.color)
		//////////////////////////////
		if handler.BeginRender:handler.BeginRender(obj)
		//////////////////////////////
		//really draw the blocks
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		acc_temp=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		if hid_colorer>=0:
			acc_colorer=new i64[m_state_ofs[hid_colorer+1]-m_state_ofs[hid_colorer]]
		//auto timer_t0=System.Time.tick64()
		//Writeln('------------------------------')
		auto dfsRender(CSLNode nd,i64 ccnt_base0)
			ccnt_base=ccnt_base0
			if handler.IsRangeHidden:
				if handler.IsRangeHidden(this,ccnt_base,ccnt_base+nd.ccnt):
					handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
					if hid_colorer>=0:
						handler_colorer.Add(acc_colorer,nd.a[m_state_ofs[hid_colorer]:m_state_ofs[hid_colorer+1]-1])
					return
			if nd.s:
				rendering_started=1
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+hid]
				ofspp2=(hid==m_handlers.n-1?i64(nd.a.n):nd.a[n0+hid+1])
				if hid_colorer>=0:
					s_context=GetContextBefore(handler_colorer,ccnt_base)
					color_ids=handler_colorer.ComputeCharColorID(acc_colorer,s_context,nd.s)
				else
					color_ids=u8[].NULL
				//auto t0=System.Time.tick64()
				if handler.GetXYFromState:
					xy0=handler.GetXYFromState(this,acc)
				else
					xy0=long2(acc[0],acc[1])
				copy(acc_temp,acc)
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
				if handler.GetXYFromState:
					xy1=handler.GetXYFromState(this,acc)
				else
					xy1=long2(acc[0],acc[1])
				if xy0.y==xy1.y&&(xy0.x>=x+w||xy1.x<=x)&&(nd.s.n||ccnt_base):
					//x culled, do nothing, but we can't cull the only node of an empty document
				else
					handler.RenderText(this,ccnt_base,acc_temp,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s, color_ids, x,y,w,h,scr_x,scr_y,scale)
				//Writeln('render a block: ',System.Time.TicksToSeconds(System.Time.tick64()-t0)*1000.0,'ms')
				if hid_colorer>=0:
					handler_colorer.Add(acc_colorer,nd.a[m_state_ofs[hid_colorer]:m_state_ofs[hid_colorer+1]-1])
			else
				for(pc=nd.pchild;pc;pc=pc.pnext)
					p0=max(wnd_ccnt0-ccnt_base,0LL)
					p1=min(wnd_ccnt1-ccnt_base,pc.ccnt)
					if p1>p0:
						dfsRender(pc,ccnt_base)
					else if !rendering_started:
						handler.Add(acc,pc.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
						if hid_colorer>=0:
							handler_colorer.Add(acc_colorer,pc.a[m_state_ofs[hid_colorer]:m_state_ofs[hid_colorer+1]-1])
					ccnt_base+=pc.ccnt
		dfsRender(m_skiplist,0LL)
		//Writeln('>>>>> total: ',System.Time.TicksToSeconds(System.Time.tick64()-timer_t0)*1000.0,'ms')
		//////////////////////////////
		//draw the advanced highlights
		if handler.DrawEnhancedHighlight:
			foreach hl in m_highlights
				ccnt0=hl.p0.ccnt
				ccnt1=hl.p1.ccnt
				if ccnt1==ccnt0:continue
				if ccnt1<ccnt0:
					if !hl.invertible:continue
					(ccnt0,ccnt1)=(ccnt1,ccnt0)
				if ccnt1<=wnd_ccnt0||ccnt0>=wnd_ccnt1:continue
				mode=int(hl.display_mode)
				if mode==HL_DISPLAY_MODE_RECT:continue
				handler.DrawEnhancedHighlight(obj,this,hl, x,y,w,h,scr_x,scr_y,scale)
		m_caret_offset=fixed2double(handler.GetCaretOffset())
		//////////////////////////////
		if handler.EndRender:handler.EndRender(obj,this, x,y,w,h,scr_x,scr_y,scale)
		g_renderer.PopCliprect()
	/////////////////////////////////////////////////
	//just record classes and ccnts - restoring ccnt for discarded locators is OK
	auto CreateLocator(i64 ccnt,int side)
		ret=new CLocator(){ccnt:ccnt,side:i8(side)}
		m_locators.push(ret)
		return ret
	auto CreateHighlight(CLocator p0,CLocator p1,int depth)
		ret=new CHLRange(){p0:p0,p1:p1,depth:i16(depth)}
		m_highlights.push(ret)
		return ret
	auto XYFromCcnt(i64 ccnt)
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		a=GetStateAt(hid,ccnt)
		if handler.GetXYFromState:
			return handler.GetXYFromState(this,a)
		else
			return long2(a[0],a[1])
	//todo: style changing
	/////////////////
	auto IsAtLineWrap(i64 ccnt)
		if !ccnt:return 0
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		if !handler.IsAtLineWrap:return 0
		if GetUtf8CharNeighborhood(ccnt)[0]=='\n':return 0
		(nd,ofs)=BlockFromCcnt(ccnt)
		return handler.IsAtLineWrap(nd.a,GetPrecomputedStates(handler,nd),nd.s,iptr(ofs))
	/////////////////
	inline enumCharsForward(i64 ccnt0)
		return {'forEach':inline(fbody){
			ccnt=ccnt0
			ccnt_tot=GetTextSize()
			for(;;)
				if ccnt>=ccnt_tot:break
				(pb,ofs)=BlockFromCcnt(ccnt)
				s=pb.s
				ccnt_base=ccnt-ofs
				n=s.n
				for(i=ofs;i<n;i++)
					fbody(s[i],ccnt_base+i64(i))
				if i<n:break
				ccnt=ccnt_base+i64(s.n)
		}}
	inline enumUtf8Forward(i64 ccnt)
		return CharToUtf8(enumCharsForward(ccnt),i64)
	//backward functions are exclusive w.r.t ccnt0
	inline enumCharsBackward(i64 ccnt0)
		return {'forEach':inline(fbody){
			ccnt=ccnt0-1LL
			for(;;)
				if ccnt<0LL:break
				(pb,ofs)=BlockFromCcnt(ccnt)
				s=pb.s
				ccnt_base=ccnt-ofs
				for(i=ofs;i>=0L;i--)
					fbody(s[i],ccnt_base+i64(i))
				if i>=0L:break
				ccnt=ccnt_base-1LL
		}}
	inline enumUtf8Backward(i64 ccnt)
		return CharToUtf8Backward(enumCharsBackward(ccnt),i64)
	auto GetUtf8CharNeighborhood(i64 ccnt0)
		ch0=int('\n');ch1=int('\n')
		foreach ch,I in enumUtf8Backward(ccnt0)
			ch0=ch
			break
		foreach ch,I in enumUtf8Forward(ccnt0)
			ch1=ch
			break
		return (ch0,ch1)
	auto GetCharNeighborhood(i64 ccnt0)
		ch0=int('\n');ch1=int('\n')
		foreach ch,I in enumCharsBackward(ccnt0)
			ch0=int(u8(ch))
			break
		foreach ch,I in enumCharsForward(ccnt0)
			ch1=int(u8(ch))
			break
		return (ch0,ch1)
	/////////////////
	JS_Edit=function(JSContext JS){
		js_ops=JS.Param(0).as(JSObject)
		if !js_ops:return 0
		is_raw=JS.Param(1).or(0)
		n=js_ops["length"].as(iptr)
		if !(n>=0)||(n%3):
			return JS.ReturnError("bad operation array length @1".Replace(["@1",string(n)]))
		//one array with even-odd packing
		range0=0LL
		range1=GetTextSize()
		ops=new TEditop[]
		for i=0:3:n-3
			op=TEditop(){ccnt:js_ops[i].as(i64),sz:js_ops[i+1].as(i64),s:js_ops[i+2].as(string)}
			if u64(op.ccnt)<u64(range0)||u64(op.ccnt+op.sz)>u64(range1)||u64(op.ccnt+op.sz)<u64(op.ccnt):
				return JS.ReturnError("invalid operation #@1".Replace(["@1",string(i)]))
			range0=op.ccnt+op.sz
			ops.push(op)
		ops.Sortby(inline(a){return a.ccnt})
		if is_raw:
			LoaderEdit(ops)
		else
			Edit(ops)
		return 0
	}
	JS_Undo=function(JSContext JS){
		sside=JS.Param(0).or("undo")
		if sside=="undo":
			if !m_undo_queue.n:return 0
			ret=Undo()
		else
			if !m_redo_queue.n:return 0
			ret=Redo()
		jsret=JS.New()
		jsret["ccnt"]=ret.x
		jsret["sz"]=ret.y
		return JS.Return(jsret)
	}
	JS_GetUndoQueueLength=function(JSContext JS){
		return JS.Return(m_undo_queue.n)
	}
	JS_GetRedoQueueLength=function(JSContext JS){
		return JS.Return(m_redo_queue.n)
	}
	JS_GetText=function(JSContext JS){
		ed=this
		range0=0LL
		range1=ed.GetTextSize()
		ccnt=JS.Param(0).or(range0)
		sz=JS.Param(1).or(range1)
		if u64(ccnt)<u64(range0)||u64(ccnt+sz)>u64(range1)||u64(ccnt+sz)<u64(ccnt):
			return 0//JS.ReturnError("invalid range")
		return JS.Return(ed.GetText(ccnt,sz))
	}
	JS_GetTextSize=function(JSContext JS){
		return JS.Return(GetTextSize())
	}
	JS_InvalidateStates=function(JSContext JS){
		js_ops=JS.Param(0).as(JSObject)
		if !js_ops:return 0
		n=js_ops["length"].as(iptr)
		if !(n>=0)||(n%2):
			return JS.ReturnError("bad operation array length @1".Replace(["@1",string(n)]))
		//one array with even-odd packing
		range0=0LL
		range1=GetTextSize()
		ranges=new i64[]
		for i=0:2:n-2
			ccnt=js_ops[i].as(i64)
			sz=js_ops[i+1].as(i64)
			if u64(ccnt)<u64(range0)||u64(ccnt+sz)>u64(range1)||u64(ccnt+sz)<u64(ccnt):
				return JS.ReturnError("invalid operation #@1".Replace(["@1",string(i)]))
			range0=ccnt+sz
			///////
			ranges.push(ccnt)
			ranges.push(sz)
		InvalidateStates(ranges)
		return 0
	}
	JS_Render=function(JSContext JS){
		ed=this
		params=JS.Param(0).as(JSObject)
		if !params:return 0
		if JS.GetGlobal()["UI"]["m_frame_is_invalid"].as(int):return 0
		param_x=double2fixed(params["x"].or(0.))
		param_y=double2fixed(params["y"].or(0.))
		param_w=double2fixed(params["w"].or(0.))
		param_h=double2fixed(params["h"].or(0.))
		param_scr_x=params["scr_x"].or(0.f)
		param_scr_y=params["scr_y"].or(0.f)
		param_scale=params["scale"].or(1.f)
		obj=params["obj"].as(JSObject)
		ed.Render(
			obj,
			param_x,
			param_y,
			param_w,
			param_h,
			param_scr_x,
			param_scr_y,
			param_scale)
		return 0
	}
	JS_CreateLocator=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		side=JS.Param(1).or(0)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			return 0
		else
			return JS.Return(CreateLocator(ccnt,side))
	}
	JS_CreateHighlight=function(JSContext JS){
		auto p0=JS.Param(0).as(CLocator)
		auto p1=JS.Param(1).as(CLocator)
		auto depth=JS.Param(2).or(0)
		if !p0||!p1:
			return 0
		else
			return JS.Return(CreateHighlight(p0,p1,depth))
	}
	JS_CreateDiffTracker=function(JSContext JS){
		diff=new CDiffTracker
		diff.Init(this.GetTextSize())
		m_diff_trackers.push(diff)
		return JS.Return(diff)
	}
	JS_XYFromCcnt=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			//debugDumpSL()
			return 0
		xy=XYFromCcnt(ccnt)
		ret=JS.New()
		ret["x"]=fixed2double(xy[0])
		ret["y"]=fixed2double(xy[1])
		return JS.Return(ret)
	}
	JS_GetXYEnMasse=function(JSContext JS){
		js_ccnts=JS.Param(0).as(JSObject)
		if !js_ccnts:return JS.ReturnError("invalid ccnt array")
		//////////
		range1=GetTextSize()
		n=js_ccnts.length()
		ccnts=new i64[n]
		for i=0:n-1
			ccnts[i]=js_ccnts[i].as(i64)
			if ccnts[i]<0LL:
				ccnts[i]=(i?ccnts[i-1]:0LL)
			if i&&ccnts[i]<ccnts[i-1]||u64(ccnts[i])>u64(range1):
				return JS.ReturnError("invalid location @1".Replace(["@1",string(i)]))
		reti=GetXYEnMasse(ccnts)
		stypes=['d' for i=0:reti.n-1]
		ret=DecodeStateArray(JS,reti,stypes)
		return JS.Return(ret)
	}
	//only need to support "l" and "d"
	EncodeStateArray=function(JSContext JS,JSObject js_array,string stypes){
		if !stypes||!js_array:return i64[].NULL
		n=js_array["length"].as(iptr)
		if n!=stypes.n:return i64[].NULL
		ret=new i64[n]
		for i=0:n-1
			d=js_array[i].as(double)
			if stypes[i]=='l':
				l=i64(d)
			else if stypes[i]=='d':
				l=double2fixed(d)
			else if stypes[i]=='i':
				l=i64(i32(d))
			else
				return i64[].NULL
			ret[i]=l
		return ret
	}
	DecodeStateArray=function(JSContext JS,i64[] a,string stypes){
		if !stypes||!a:return JSObject.NULL
		n=a.n
		//if n!=stypes.n:return JSObject.NULL
		ret=JS.NewArray()
		for i=0:n-1
			l=a[i]
			ch_type=stypes[min(i,stypes.n-1)]
			if ch_type=='l':
				d=double(l)
			else if ch_type=='i':
				d=double(i32(l))
			else if ch_type=='d':
				d=fixed2double(l)
			else
				return JSObject.NULL
			ret[i]=d
		return ret
	}
	JS_Bisect=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		js_array=JS.Param(1).as(JSObject)
		stypes=JS.Param(2).as(string)
		if !js_array||!stypes:return JS.ReturnError("array or format string not specified")
		if js_array.length()!=stypes.n:return JS.ReturnError("invalid state array length @1, should be @2".Replace(["@1",string(js_array.length()),"@2",string(stypes.n)]))
		b=EncodeStateArray(JS,js_array,stypes)
		if !b:return JS.ReturnError("invalid type description '@1'".Replace(["@1",stypes]))
		return JS.Return(Bisect(hid,b))
	}
	JS_FindNearest=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		js_array=JS.Param(1).as(JSObject)
		stypes=JS.Param(2).as(string)
		if !js_array||!stypes:return JS.ReturnError("array or format string not specified")
		if js_array.length()!=stypes.n:return JS.ReturnError("invalid state array length @1, should be @2".Replace(["@1",string(js_array.length()),"@2",string(stypes.n)]))
		b=EncodeStateArray(JS,js_array,stypes)
		if !b:return JS.ReturnError("invalid type description '@1'".Replace(["@1",stypes]))
		ccnt0=JS.Param(3).as(i64)
		direction=JS.Param(4).as(int)
		return JS.Return(FindNearest(hid,b,ccnt0,direction))
	}
	JS_GetStateAt=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		ccnt0=JS.Param(1).as(i64)
		range1=GetTextSize()
		if u64(ccnt0)>u64(range1):return JS.ReturnError("invalid location")
		stypes=JS.Param(2).as(string)
		a=GetStateAt(hid,ccnt0)
		ret=DecodeStateArray(JS,a,stypes)
		if !ret:
			return JS.ReturnError("invalid type description '@1'".Replace(["@1",stypes]))
		else
			return JS.Return(ret)
	}
	JS_GetStateEnMasse=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		js_ccnts=JS.Param(1).as(JSObject)
		if !js_ccnts:return JS.ReturnError("invalid ccnt array")
		stypes0=JS.Param(2).as(string)
		//////////
		range1=GetTextSize()
		n=js_ccnts.length()
		stypes=new string
		ccnts=new i64[n]
		for i=0:n-1
			ccnts[i]=js_ccnts[i].as(i64)
			if ccnts[i]<ccnts[i-1]||u64(ccnts[i])>u64(range1):
				return JS.ReturnError("invalid location @1".Replace(["@1",string(i)]))
			stypes.push(stypes0)
		a=GetStateEnMasse(hid,ccnts)
		ret=DecodeStateArray(JS,a,stypes)
		if !ret:
			return JS.ReturnError("invalid type description '@1'".Replace(["@1",stypes]))
		else
			return JS.Return(ret)
	}
	JS_SeekXY=function(JSContext JS){
		x=double2fixed(JS.Param(0).as(double))
		y=double2fixed(JS.Param(1).as(double))
		return JS.Return(SeekXY(x,y))
	}
	JS_GetCharacterHeightAt=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		return JS.Return(fixed2double(GetCharacterHeightAt(ccnt)))
	}
	JS_GetDefaultFont=function(JSContext JS){
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		return JS.Return(handler.GetDefaultFont())
	}
	JS_SnapToCharBoundary=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		for(;;)
			if !ccnt||ccnt==range1:break
			(ch0,ch1)=GetCharNeighborhood(ccnt)
			//ch=GetText(ccnt,1LL)[0]
			if (ch1&0xc0)==0x80||ch1=='\n'&&ccnt&&ch1==int('\n')&&ch0==int('\r'):
				direction=JS.Param(1).or(1)
				if direction<1:
					if ccnt:
						ccnt--
					else
						break
				else
					if ccnt<range1:
						ccnt++
					else
						break
			else
				break
		return JS.Return(ccnt)
	}
	JS_IsAtLineWrap=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		return JS.Return(IsAtLineWrap(ccnt))
	}
	auto MoveToBoundary(i64 ccnt,int direction,function(int,int):int fcheck,int limit0)
		limit=limit0
		(ch0,ch1)=GetUtf8CharNeighborhood(ccnt)
		if direction<0:
			ch0=ch1
			ccnti_previous=ccnt
			foreach ch,ccnti in enumUtf8Backward(ccnt)
				ch1=ch0
				ch0=ch
				//Writeln('enumUtf8Backward ',ch0,' ',ch1,' ',ccnt)
				if fcheck(ch0,ch1):return (ccnti_previous)
				limit--
				if limit<=0:return (ccnti_previous)
				ccnti_previous=ccnti
			return (0LL)
		else
			ch1=ch0
			foreach ch,ccnti in enumUtf8Forward(ccnt)
				ch0=ch1
				ch1=ch
				if fcheck(ch0,ch1):return (ccnti)
				limit--
				if limit<=0:return (ccnti)
			return (GetTextSize())
	auto GetStockFCheck(string stype,int direction)
		if stype=="space":
			if direction<0:
				fcheck=function(int c0,int c1){return c0!=' '&&c0!='\t'&&c0!='\r'}
			else
				fcheck=function(int c0,int c1){return c1!=' '&&c1!='\t'&&c1!='\r'}
		else if stype=="space_newline":
			if direction<0:
				fcheck=function(int c0,int c1){return c0!=' '&&c0!='\t'&&c0!='\r'&&c0!='\n'}
			else
				fcheck=function(int c0,int c1){return c1!=' '&&c1!='\t'&&c1!='\r'&&c1!='\n'}
		else if stype=="word_boundary":
			fcheck=function(int c0,int c1){return isWordChar(c0)!=isWordChar(c1)}
		else if stype=="word_boundary_left":
			fcheck=function(int c0,int c1){return !isWordChar(c0)&&isWordChar(c1)}
		else if stype=="word_boundary_right":
			fcheck=function(int c0,int c1){return isWordChar(c0)&&!isWordChar(c1)}
		else if stype=="ctrl_lr_stop":
			fcheck=function(int c0,int c1){return !isWordChar(c0)&&isWordChar(c1)||isCJK(c0)&&!isCJK(c1)&&isWordChar(c1)||c1=='\n'}
		else if stype=="precise_ctrl_lr_stop":
			fcheck=function(int c0,int c1){
				return isWordChar(c0)!=isWordChar(c1)||isCJK(c0)&&!isCJK(c1)&&isWordChar(c1)||isCJK(c1)&&!isCJK(c0)&&isWordChar(c0)||c1=='\n'||c0=='\n'
			}
		else if stype=="invisible_boundary":
			hid=m_handler_registration["renderer"].as(int)
			handler=m_handlers[hid]
			if !handler.IsCharInvisible:
				fcheck=function(int c0,int c1){return 1}
				//return JS.Return(ccnt)
			else if direction<0:
				fcheck=function(int c0,int c1){return !handler.IsCharInvisible(c0)}
			else
				fcheck=function(int c0,int c1){return !handler.IsCharInvisible(c1)}
		else
			fcheck=function(int c0,int c1){return 1}
		return fcheck
	JS_MoveToBoundary=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		direction=JS.Param(1).or(1)
		stype=JS.Param(2).or("space")
		limit=JS.Param(3).or(65536)
		fcheck=GetStockFCheck(stype,direction)
		if !fcheck:return 0
		//boundary types: word, space, ctrl-lr
		return JS.Return(MoveToBoundary(ccnt,direction,fcheck,limit))
	}
	JS_GetUtf8CharNeighborhood=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		//if u64(ccnt)>u64(range1):return 0
		ccnt=min(max(ccnt,0LL),range1)
		(ch0,ch1)=GetUtf8CharNeighborhood(ccnt)
		ret=JS.NewArray()
		ret[0]=ch0
		ret[1]=ch1
		return JS.Return(ret)
	}
	JS_ConvertUTF8OffsetToBytesize=function(JSContext JS){
		ccnt0=JS.Param(0).or(0LL)
		n_utf8=JS.Param(1).or(0L)
		foreach ch,I in enumUtf8Forward(ccnt0)
			if n_utf8<=0L:
				return JS.Return(I)
			n_utf8--
		return 0
	}
	JS_GetHandlerByID=function(JSContext JS){
		id=JS.Param(0).as(int)
		if u32(id)<u32(m_handlers.n):
			return JS.Return(m_handlers[id])
		else
			return 0
	}
	///////////////////////////
	auto debugDumpSL()
		levels=new string[]
		auto _debugDumpSL(int level,CSLNode nd0)
			if levels.n<=level*2:
				levels.push(new string)
				levels.push(new string)
			for(nd=nd0;nd;nd=nd.pnext)
				sname=levels[level*2+0]
				sdash=levels[level*2+1]
				if nd.s:
					sdash.push(nd.s.Replace(["\r",".", "\t",".", "\n","."]))
					assert(nd.s.n==nd.ccnt)
				else
					if nd.ccnt:sdash.push('+')
					for i=1:int(nd.ccnt)-1
						sdash.push('-')
				sname.push(formatNumber(iptr(nd),{base:16,align:8}))
				sname.resize(sdash.n)
				if nd.pchild:
					_debugDumpSL(level+1,nd.pchild)
		_debugDumpSL(0,m_skiplist)
		foreach s in levels
			Writeln(s.Replace(["\0","."]))
		Writeln()
	///////////////////////////
	//(function(){
	//	Writeln('editor created ',__cast(__pointer,this))
	//})()
	//auto __done__()
	//	Writeln('editor destroyed ',__cast(__pointer,this),' ',this.GetTextSize())
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"m_handler_registration")
		proto.ExportProperty(this,"m_caret_locator")
		proto.ExportProperty(this,"m_IME_overlay")
		proto.ExportProperty(this,"m_other_overlay")
		proto.ExportProperty(this,"m_caret_offset")
		proto.ExportMethod(this,"Edit",JS_Edit)
		proto.ExportMethod(this,"GetText",JS_GetText)
		proto.ExportMethod(this,"GetTextSize",JS_GetTextSize)
		proto.ExportMethod(this,"InvalidateStates",JS_InvalidateStates)
		proto.ExportMethod(this,"Render",JS_Render)
		proto.ExportMethod(this,"CreateLocator",JS_CreateLocator)
		proto.ExportMethod(this,"CreateHighlight",JS_CreateHighlight)
		proto.ExportMethod(this,"CreateDiffTracker",JS_CreateDiffTracker)
		proto.ExportMethod(this,"XYFromCcnt",JS_XYFromCcnt)
		proto.ExportMethod(this,"GetXYEnMasse",JS_GetXYEnMasse)
		proto.ExportMethod(this,"SeekXY",JS_SeekXY)
		proto.ExportMethod(this,"Bisect",JS_Bisect)
		proto.ExportMethod(this,"FindNearest",JS_FindNearest)
		proto.ExportMethod(this,"GetStateAt",JS_GetStateAt)
		proto.ExportMethod(this,"GetStateEnMasse",JS_GetStateEnMasse)
		proto.ExportMethod(this,"GetCharacterHeightAt",JS_GetCharacterHeightAt)
		proto.ExportMethod(this,"GetDefaultFont",JS_GetDefaultFont)
		proto.ExportMethod(this,"SnapToCharBoundary",JS_SnapToCharBoundary)
		proto.ExportMethod(this,"IsAtLineWrap",JS_IsAtLineWrap)
		proto.ExportMethod(this,"MoveToBoundary",JS_MoveToBoundary)
		proto.ExportMethod(this,"Undo",JS_Undo)
		proto.ExportMethod(this,"GetUndoQueueLength",JS_GetUndoQueueLength)
		proto.ExportMethod(this,"GetRedoQueueLength",JS_GetRedoQueueLength)
		proto.ExportMethod(this,"GetUtf8CharNeighborhood",JS_GetUtf8CharNeighborhood)
		proto.ExportMethod(this,"ConvertUTF8OffsetToBytesize",JS_ConvertUTF8OffsetToBytesize)
		proto.ExportMethod(this,"GetHandlerByID",JS_GetHandlerByID)

g_registered_state_handlers=new function(CEditableText ret)[string]

inline registerStateHandler(string name,T)
	g_registered_state_handlers[name]=function(CEditableText ret){ret.AddStateHandler(new T)}

registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
	JS_UI["CreateEditor"]=function(JSContext JS){
		obj_style=JS.Param(0).as(JSObject)
		if !obj_style:return 0
		obj_handlers=obj_style["state_handlers"].as(JSObject)
		ret=new CEditableText
		if !obj_handlers:
			ret.AddStateHandler(new CLayouter_baseline)
			ret.AddStateHandler(new CLine_handler)
		else
			for i=0:obj_handlers.length()-1
				auto f=g_registered_state_handlers[obj_handlers[i].or("")]
				if f:
					f(ret)
				else
					return JS.ReturnError("Invalid state handler @1".Replace(["@1",obj_handlers[i].or("")]))
		if !ret.Init(obj_style):
			return JS.ReturnError("Failed to create the editor")
		else
			return JS.Return(ret)
	}
	JS_UI["IsWordChar"]=function(JSContext JS){
		return JS.Return(isWordChar(JS.Param(0).as(int)))
	}
	if Platform.BUILD=="debug"&&LeakDetection.isEnabled():
		LeakDetection.RegisterRTTI(i8[])
		LeakDetection.RegisterRTTI(int[])
		LeakDetection.RegisterRTTI(iptr[])
		LeakDetection.RegisterRTTI(CSLNode)
		LeakDetection.RegisterRTTI(CDiffSLNode)
		LeakDetection.RegisterRTTI(CLocator)
		LeakDetection.RegisterRTTI(CHLRange)
		LeakDetection.RegisterRTTI(CEditableText)
})

registerStateHandler("renderer_baseline",CLayouter_baseline)
registerStateHandler("line_column_unicode",CLine_handler)
}

registerStateHandler=TextBox.detail.registerStateHandler
isWordChar=TextBox.detail.isWordChar


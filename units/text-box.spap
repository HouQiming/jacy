/*
todo:
	basic event handling
	basic interface
		MassEdit
		handle-based locator system
		locator-aware undo history
			no-longer-used locators and stuff...
			ignore them
				which needs unique locator ids
				or erase history when deleting locators
				or just mark it in the undo history
		Render
			spatial query
		GetText
			text query
	paragraph-based structure
		bland array indexing
		O(n/C+C) edit + O(log(n)+C) seek
*/
import Gui2D.*
import Gui2D.detail.*
import Javascript.*
import System.Algorithm.*
import System.Math.*
import System.Console.*

struct TMouseMap
	double2 pos
	i64 ccnt

//struct TCharJob
//	pos=float2()
//	ch=0
//	color=0

struct TRenderingInfo
	double2 bb
	//TCharJob[] pt
	TMouseMap[] mm

auto SearchMouseMap(TMouseMap[] mm,double x,double y0)
	y=y0
	p=0L
	for iiter=0:1
		p=mm.Bisect(function(TMouseMap a){return a.pos.y<y||a.pos.y==y&&a.pos.x<x})
		if y!=mm[p].pos.y:
			y=mm[p].pos.y
		else
			break
	return p

///////////////////////////////
//double should be as-ed
class ITextStateHandler
	iptr id
	function():string name
	function():int stateSize
	function():int isLineOnly
	//The "add" function must be associative
	//The result should be written to "a"
	//if AddBlock returns anything... it's considered as a per-block cache
	//todo: context
	function(i64[] a,string s):i64[] AddBlock
	function(i64[] a,i64[] b) Add
	//For coloring states, we need a colorer
	function(i64[] a,string s):u8[] ComputeCharColorID
	//For rendering states, we need a layouter
	function(JSObject obj) SetTextStyle
	function(i64[] a,i64[] pp,string s, double dx,double dy,float scaling) RenderText
	//function(string s):i64[] PreprocessBlock
	//For seeking states, we need comparison and in-block seeking
	function(i64[] a,i64[] b):int Compare
	function(i64[] a,i64[] pp,string s,i64[] b):iptr SeekInBlock

auto combineBB(double2 bb0,double2 bb1)
	bb=bb0
	if bb1.y:
		bb.x=0.
		bb.y+=bb1.y
	else
		bb.x+=bb1.x
	return bb

inline Utf8Chars(string s)
	return {'forEach':inline(fbody){
		ch0=0;nnxt=0;II=0L
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					ch0=(ch&0x1f)
					nnxt=1
					if ch&0x20:
						nnxt++
						if ch&0x10:
							nnxt++
							ch0&=7
				else
					ch0=(ch0<<6)+(ch&63)
					nnxt--
				if nnxt:continue
				ch=ch0
			else
				II=I
			fbody(ch,II)
	}}	

class CLayouter_baseline
	MODE_BB=0
	MODE_MOUSE_MAP=1
	MODE_RENDER=2
	/////////
	m_word_wrap=0
	m_tab_width=8
	m_font=TFont()
	m_color=0xff000000
	name=function(){return "renderer"}
	stateSize=function(){return 2}
	isLineOnly=function(){return 1}
	/////////////////
	AddBlock=function(i64[] a,string s){
		line_breaks=new i64[]
		if m_word_wrap:
			//todo: m_word_wrap
		else
			line_breaks.push(0LL)
			line_breaks.push(i64(s.n))
		bb=_RenderText(MODE_BB,a,line_breaks,s, 0.,0.,0.f).bb
		bb=combineBB(double2(__longlong_as_double(a[0]),__longlong_as_double(a[1])),bb)
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
		return line_breaks
	}
	Add=function(i64[] a,i64[] b){
		bb=combineBB(double2(__longlong_as_double(a[0]),__longlong_as_double(a[1])),double2(__longlong_as_double(b[0]),__longlong_as_double(b[1])))
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(i64[] a,i64[] b){
		ret=__C_compare(a[1],b[1])
		if ret==0:ret=__C_compare(a[0],b[0])
		return ret
	}
	SeekInBlock=function(i64[] a,i64[] line_breaks,string s,i64[] b){
		x=__longlong_as_double(b[0])
		y=__longlong_as_double(b[1])-__longlong_as_double(a[1])
		if y>0.0:
			x-=__longlong_as_double(a[0])
		hc=Gui2D.detail.g_renderer.GetCharacterHeight(m_font)
		line_id=int(floor(y/hc))
		if line_id<0:
			return 0L
		else if line_id>line_breaks.n-1:
			return s.n
		else
			l0=line_breaks[line_id]
			l1=line_breaks[line_id+1]
			mm=_RenderText(MODE_MOUSE_MAP,a,[0L,l1-l0],s[iptr(l0):iptr(l1)-1], 0.,0.,0.f).mm
			x=__longlong_as_double(b[0])
			y=__longlong_as_double(b[1])
			return SearchMouseMap(mm,x,y)
	}
	/////////////////
	SetTextStyle=function(JSObject obj){
		m_font=obj["font"].as(TFont)
		m_color=int(obj["color"].or(0xffffffffu))
		m_tab_width=obj["tab_width"].or(8)
		m_word_wrap=obj["word_wrap"].or(0)
	}
	_RenderText=function(int mode,i64[] a,i64[] line_breaks,string s, double dx,double dy,float scaling){
		if mode==MODE_MOUSE_MAP:
			mm=new TMouseMap[]
		else
			mm=TMouseMap[].NULL
		if mode==MODE_RENDER:
			//Writeln('before fnt_scaled ',m_font.h,' ',scaling)
			fnt_scaled=m_font
			fnt_scaled.h*=scaling
			//smart emboldening for SRGB
			if g_renderer.m_srgb_supported:
				fnt_scaled.embolden+=int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*3000.f/fnt_scaled.h)
			//Writeln('after fnt_scaled ',m_font.h)
			scalingd=double(scaling)
		w_tab=double(m_tab_width)*double(g_renderer.GetCharacterAdvance(m_font,int(' ')))
		hc=g_renderer.GetCharacterHeight(m_font)
		x=__longlong_as_double(a[0])
		y=__longlong_as_double(a[1])
		for i=0:line_breaks.n-2
			//got_newline=0
			for ch,I in Utf8Chars(s[iptr(line_breaks[i]):iptr(line_breaks[i+1]-1)])
				if mode==MODE_MOUSE_MAP:
					mm.push(TMouseMap(){pos:double2(x,y),ccnt:line_breaks[i]+I})
				if ch=='\r'||ch=='\n':
					//nothing
					if ch=='\n':
						//got_newline=1
						x=0.
						y+=hc
					continue
				else if ch==' ':
					x+=double(g_renderer.GetCharacterAdvance(m_font,ch))
				else if ch=='\t':
					x=(floor(x/w_tab)+1.0)*w_tab
				else
					dx_i=double(g_renderer.GetCharacterAdvance(m_font,ch))
					if mode==MODE_RENDER:
						//pt.push(TCharJob(){pos:double2(x,y),ch:ch,color:m_color})
						//Writeln(x,' ',y,' ',m_font.h,' ',fnt_scaled.h,' ',scalingd,' ',ch,' ',m_color)
						g_renderer.DrawChar(fnt_scaled, float(x*scalingd+dx),float(y*scalingd+dy),m_color, ch)
					x+=dx_i
			//if got_newline:
			//	x=0.
			//	y+=hc
		return TRenderingInfo(){bb:double2(x,y),mm:mm}
	}
	RenderText=function(i64[] a,i64[] pp,string s, double dx,double dy,float scaling){
		_RenderText(MODE_RENDER,a,pp,s,dx,dy,scaling)
	}

///////////////////////////////
/*/
hybrid line-size consistency
	rendering breaks
		LTR|RTL
		\n|
	block
		design criteria
			should be O(n/C)
			should have a tight rendering BB
		consistency
			don't break UTF8 chars
			block size must not exceed C+epsilon
			if a block contains one rendering break
				it must be the block tail
			if a block contains more than one rendering breaks
				the block head must also be one
			\n and LTR|RTL are nested
				the break consistencies should be satisfied separately
					with \n taking priority
				e.g. if the block contains more than one line breaks
					the head must be one line break, not a LTR|RTL
			if we have isLineOnly:
				allow block size to exceed C
				but still merge short lines
/*/
struct TEditop
	//delete first, add after
	i64 ccnt
	i64 sz
	string s

struct TBlockOp
	//delete first, add after
	i64 ccnt
	i64 sz
	string[] ss

class CSLNode
	CSLNode pchild
	CSLNode pnext
	//////////
	i64 ccnt
	string s
	i64[] a

struct TSLList
	CSLNode phead
	CSLNode ptail
	inline cat(TSLList b)
		if !phead:return b
		if !b.phead:return TSLList(){phead:phead,ptail:ptail}
		ret=TSLList()
		ret.phead=phead
		ptail.pnext=b.phead
		ret.ptail=b.ptail
		return ret

//this will be directly passed to JS... research class wrapping
class CLocator
	i64 ccnt
	i8 side
	i8 discarded
	discard=function(JSContext JS){
		discarded=i8(1)
		return 0
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"ccnt")
		proto.ExportProperty(this,"side")
		proto.ExportMethod(this,"discard",discard)

SKIPLIST_PROMOTION_PROBABILITY=0.25f//1.0/2.71828
//the internal methods *should not* validate parameters
class CEditableText
	m_skiplist=new CSLNode(){s:new string}
	m_locators=new CLocator[]
	m_layout_valid_to=0L
	////////////////////
	m_handlers=new ITextStateHandler[]
	m_state_ofs=new iptr[]
	//m_hid_renderer=-1L
	m_is_line_only=0
	m_block_size=1024
	m_js=JSContext.NULL
	m_handler_registration=JSObject.NULL
	inline AddStateHandler(a)
		m_handlers.push(getInterface(a,ITextStateHandler))
		return m_handlers.n-1
	auto Init(JSObject obj_style)
		m_js=obj_style.m_jsctx
		m_handler_registration=m_js.New()
		ofs=0L
		foreach hstate,I in m_handlers
			hstate.id=I
			if hstate.isLineOnly&&hstate.isLineOnly():
				m_is_line_only=1
			//if hstate.RenderText:
			//	assert(m_hid_renderer==-1L)
			//	m_hid_renderer=I
			m_state_ofs.push(ofs)
			ofs+=hstate.stateSize()
			///////////
			m_handler_registration["handler_id_"+hstate.name()]=I
			if hstate.SetTextStyle:
				hstate.SetTextStyle(obj_style)
		//m_handler_registration["m_is_line_only"]=m_is_line_only
		m_state_ofs.push(ofs)
		RecomputeStates(m_skiplist)
		m_handler_registration["style"]=obj_style
	auto RecomputeStates(CSLNode nd)
		n=m_state_ofs.back()
		ccnt=0LL
		s=nd.s
		if s:
			a=new i64[n+m_handlers.n]
			ccnt=i64(s.n)
			foreach hstate,I in m_handlers
				a_slice=a[m_state_ofs[I]:m_state_ofs[I+1]-1]
				block_state=hstate.AddBlock(a_slice,s)
				a_slice.discard()
				a[n+I]=i64(a.n)
				if block_state:
					a.push(block_state)
		else
			a=new i64[n]
			for(pc=nd.pchild;pc;pc=pc.pnext)
				foreach hstate,I in m_handlers
					hstate.Add(a[m_state_ofs[I]:m_state_ofs[I+1]-1],pc.a[m_state_ofs[I]:m_state_ofs[I+1]-1])
				ccnt+=pc.ccnt
		nd.a=a
		nd.ccnt=ccnt
	auto BlockFromCcnt(i64 ccnt0)
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				nd=nd.pnext
			if nd.s:
				return (nd,ccnt0-ccnt_base)
			assert(!!nd.pchild)
			nd=nd.pchild
	auto GetStateAt(int hid,i64 ccnt0)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		handler=m_handlers[hid]
		///////////
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a)
				nd=nd.pnext
			if nd.s:
				handler.AddBlock(acc,nd.s[:iptr(ccnt0-ccnt_base-1LL)])
				return acc
			assert(!!nd.pchild)
			nd=nd.pchild
	auto skipListPromote(TSLList nds_ret0, TSLList nds_child0,TSLList nds_toadd,CSLNode nd_ignore)
		nds_ret=nds_ret0
		nds_child=nds_child0
		pc_pnext=CSLNode.NULL
		for(pc=nds_toadd.phead;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			if iptr(pc)!=iptr(nd_ignore)&&System.Algorithm.Random(float)<SKIPLIST_PROMOTION_PROBABILITY&&nds_child.phead:
				//finish off the dangling chain
				nds_child.ptail.pnext=CSLNode.NULL
				nds_ret.ptail.pchild=nds_child.phead
				RecomputeStates(nds_ret.ptail)
				//actually promote pc
				nd_new=new CSLNode
				nds_ret.ptail.pnext=nd_new
				nds_ret.ptail=nd_new
				nds_child=TSLList(){phead:pc,ptail:pc}
			if !nds_child.phead:
				nds_child.phead=pc
			else
				nds_child.ptail.pnext=pc
			nds_child.ptail=pc
		return (nds_ret,nds_child)
	auto skipListPromoteToRoot(TSLList nds_toadd0)
		nds_toadd=nds_toadd0
		for(;;)
			if iptr(nds_toadd.phead)==iptr(nds_toadd.ptail):
				return nds_toadd.phead
			//promote the head
			nd_new=new CSLNode
			nds_ret=TSLList(){phead:nd_new,ptail:nd_new}
			nds_child=TSLList(){phead:nds_toadd.phead,ptail:nds_toadd.phead}
			nds_toadd.phead=nds_toadd.phead.pnext
			//add the rest
			(nds_ret,nds_child)=skipListPromote(nds_ret,nds_child,nds_toadd,CSLNode.NULL)
			nds_ret.ptail.pchild=nds_child.phead;nds_child.ptail.pnext=CSLNode.NULL
			RecomputeStates(nds_ret.ptail)
			//recurse one level up
			nds_toadd=nds_ret
	auto BlockEdit(CSLNode nd,i64 ccnt_base0,TBlockOp[] bops)
		assert(!nd.s)
		//for each child -> untouched / new list (on which we apply random growth)
		//so the return value is a list
		p=0L
		ccnt_base=ccnt_base0
		//nds_ret.ptail.pchild is the dangling part represented by nds_child
		nds_ret=TSLList(){phead:nd,ptail:nd}
		nds_child=TSLList()
		pc_pnext=CSLNode.NULL
		for(pc=nd.pchild;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			//intersect cut bops with the child
			p0=p
			while p<bops.n&&bops[p].ccnt<ccnt_base+pc.ccnt:
				p++
			if p0<p:
				bk=bops[p-1]
				bops[p-1].sz=min(ccnt_base+pc.ccnt-bops[p-1].ccnt,bops[p-1].sz)
				if bops[p-1].sz<bk.sz:
					bops[p-1].ss=string[].NULL
				bops[p0].sz+=bops[p0].ccnt
				bops[p0].ccnt=max(ccnt_base,bops[p0].ccnt)
				bops[p0].sz-=bops[p0].ccnt
				assert(bops[p-1].sz>0LL)
				assert(bops[p0].sz>0LL)
				if p0==p-1&&!bops[p0].ss&&bops[p0].ccnt==ccnt_base&&bops[p0].sz==pc.ccnt:
					//completely deleted, discard the child
					continue
				if pc.s:
					assert(p0==p-1)
					assert(!!bops[p0].ss)
					assert(bops[p0].ccnt==ccnt_base)
					nds_pc=TSLList()
					foreach s in bops[p0].ss
						nd_new=new CSLNode(){s:s,ccnt:s.n}
						RecomputeStates(nd_new)
						if !nds_pc.phead:
							nds_pc.phead=nd_new
						else
							nds_pc.ptail.pnext=nd_new
							nds_pc.ptail=nd_new
					if bops[p0].sz:
						//throw away pc
						assert(bops[p0].sz==pc.ccnt)
					else
						//keep it
						nds_pc=nds_pc.cat(TSLList(){phead:pc,ptail:pc})
				else
					nds_pc=BlockEdit(pc,ccnt_base,bops[p0:p-1])
				(nds_ret,nds_child)=skipListPromote(nds_ret, nds_child,nds_pc,pc)
				bops[p-1]=bk
			else
				pc.pnext=CSLNode.NULL
				nds_child=nds_child.cat(TSLList(){phead:pc,ptail:pc})
			ccnt_base+=pc.ccnt
		//coulddo: removing nd itself
		nds_ret.ptail.pchild=nds_child.phead;nds_child.ptail.pnext=CSLNode.NULL
		RecomputeStates(nds_ret.ptail)
		return nds_ret
	auto SortLocators()
		n2=0L
		foreach loc,I in m_locators
			if !loc.discarded:
				m_locators[n2++]=loc
		m_locators.resize(n2)
		m_locators.Sortby(inline(loc){return loc.ccnt})
	auto MassEdit(TEditop[] ops)
		//editop -> block replace: mainly take-the-next-and-merge
		//do the locators here
		pb=CSLNode.NULL
		ccnt_base=0LL
		ofs=0LL
		//////////
		SortLocators()
		ploc=0L
		pops=0L
		lside_tar=0LL
		rside_tar=0LL
		delta=0LL
		while ploc<m_locators.n&&pops<ops.n:
			ccnt0=ops[pops].ccnt
			ccnt1=ccnt0+ops[pops].sz
			loc=m_locators[ploc]
			ccnt_loc=loc.ccnt
			if ccnt_loc<ccnt0:
				//it didn't overlap anything
				loc.ccnt+=delta
				ploc++
				continue
			lside_tar=ccnt0+delta
			rside_tar=ccnt0+delta
			if ops[pops].s:rside_tar+=ops[pops].s.n
			if ccnt_loc<=ccnt1:
				//it overlapped the deletion
				if loc.side<1:
					//push left
					loc.ccnt=lside_tar
				else
					//push right
					loc.ccnt=rside_tar
				ploc++
			else
				//we're still to the left of the locator
				pops++
			if ops[pops].s:delta+=ops[pops].s.n
			delta+=ccnt0-ccnt1
		//////////
		bops=new TBlockOp[]
		bop_current=TBlockOp()
		s_pool=new string
		s_pool_last_newline=0L
		//s_pool_has_bidi_bound=0
		auto poolString(string s)
			if !s.n:return
			auto p_last_flush=0L
			auto p_last_newline=s_pool_last_newline
			auto p=s_pool.n
			auto addBlock(iptr p0,iptr p1)
				p_last_flush=p1
				//Writeln('addBlock: ',p0,' ',p1)
				//virtual string access
				auto s_block=string.NULL
				if p1<=s_pool.n:
					s_block=new(s_pool[p0:p1-1])
				else if p0>=s_pool.n:
					s_block=new(s[p0-s_pool.n:p1-s_pool.n-1])
				else
					s_block=s_pool[p0:]+s[:p1-s_pool.n-1]
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
			foreach chc,I in s
				ch=int(u8(chc))
				if (ch&0xc0)!=0x80&&!(s_pool.n&&s_pool.back()=='\r'&&ch=='\n'):
					//check for block breaking, but do not break UTF-8 chars or \r\n
					if p-p_last_newline>=m_block_size&&(!m_is_line_only||p_last_newline>p_last_flush):
						//need a break...
						if p_last_newline>p_last_flush:
							//we got newlines in the block, we can only break at s_pool_last_newline
							addBlock(p_last_flush,p_last_newline)
						else
							//it's a single-line block...
							addBlock(p_last_flush,p)
				p++//s_pool.push(chc)
				if ch=='\n':
					p_last_newline=p
			//virtual -> real
			if p_last_flush<s_pool.n:
				s_pool=s_pool[p_last_flush:]+s
			else
				s_pool=new(s[p_last_flush-s_pool.n:])
			s_pool_last_newline=max(p_last_newline-p_last_flush,0L)
		auto flush()
			if pb&&pb.s.n:
				assert(ofs<pb.s.n)
				poolString(pb.s[iptr(ofs):])
				bop_current.sz+=i64(pb.s.n)-ofs
			if s_pool_last_newline:
				s_block=new(s_pool[:s_pool_last_newline-1])
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
				s_pool=new(s_pool[s_pool_last_newline:])
			if s_pool.n:
				//assert(!m_is_line_only)//or end of text... which is untestable here
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_pool)
			if bop_current.sz||bop_current.ss:
				bops.push(bop_current)
				bop_current=TBlockOp()
		foreach op in ops
			if !pb||ccnt_base+pb.ccnt<op.ccnt:
				//we've left the current block, need to reseek
				flush()
				(pb,ofs)=BlockFromCcnt(op.ccnt)
				ccnt_base=op.ccnt-ofs
				bop_current.ccnt=ccnt_base
				ofs=0LL
			ofs_new=i64(op.ccnt-ccnt_base)
			if ofs_new>ofs:
				poolString(pb.s[iptr(ofs):iptr(ofs_new)-1])
				ofs=ofs_new
				assert(ofs<=pb.ccnt)
				if ofs==pb.ccnt:
					//merge with the next block - it's mandatory for line-only guys
					(pb,ofs)=BlockFromCcnt(ccnt_base+ofs)
					assert(!ofs)
					ofs=0LL
			//move by sz
			if op.sz:
				ofs+=op.sz
				if ofs>=pb.ccnt:
					(pb,ofs)=BlockFromCcnt(op.ccnt+op.sz)
			bop_current.sz=op.ccnt+op.sz-bop_current.ccnt
			if op.s:poolString(op.s)
		flush()
		//Writeln(ops)
		//Writeln('---------------------------------------------------------')
		//Writeln(bops)
		//block replace -> skiplist edit
		if m_skiplist.ccnt:
			nds_pc=BlockEdit(m_skiplist,0LL,bops)
		else
			nds_pc=TSLList()
			foreach bop in bops
				foreach s in bop.ss
					nd_new=new CSLNode(){s:s,ccnt:s.n}
					RecomputeStates(nd_new)
					if !nds_pc.phead:
						nds_pc.phead=nd_new
					else
						nds_pc.ptail.pnext=nd_new
						nds_pc.ptail=nd_new
		m_skiplist=skipListPromoteToRoot(nds_pc)
	auto _GetText(string buf,iptr ofs, CSLNode nd,i64 ccnt0,i64 ccnt1)
		if nd.s:
			copy(buf[ofs:],nd.s[iptr(ccnt0):iptr(ccnt1-1LL)])
		else
			ccnt_base=0LL
			ofs_i=ofs
			for(pc=nd.pchild;pc;pc=pc.pnext)
				p0=max(ccnt0-ccnt_base,0LL)
				p1=min(ccnt1-ccnt_base,pc.ccnt)
				if p1>p0:
					_GetText(buf,ofs_i, pc,p0,p1)
				ccnt_base+=pc.ccnt
				ofs_i+=iptr(pc.ccnt)
	auto GetText(i64 ccnt,i64 sz)
		buf=new char[sz]
		_GetText(buf,0L, m_skiplist,ccnt,ccnt+sz)
		return buf
	inline GetTextSize()
		return m_skiplist.ccnt
	/*
	how exactly do we do a backward bracket lookup? the thing is state-dependent and *not* monotone!
		--
		start-from-zero min/count evaluation
			evaluate front-to-back
			or we could evaluate and Compare front-to-back
				then search back-to-front for the last 1
		and a contexted per-char version
			SeekInBlock
				the ccnt anchor / search type could be included in b
		it's a non-bisect search using an "or" hierarchy
		--
	*/
	auto _Bisect(i64[] acc, ITextStateHandler handler,i64 ccnt_base0,CSLNode nd,i64[] b)
		if nd.s:
			n0=m_state_ofs.back()
			ofspp=nd.a[n0+handler.id]
			ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
			return ccnt_base0+handler.SeekInBlock(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,b)
		else
			ccnt_base=ccnt_base0
			acc2=new(acc)
			for(pc=nd.pchild;pc;pc=pc.pnext)
				copy(acc2,acc)
				handler.Add(acc2,pc.a)
				if handler.Compare(acc2,b)>0:
					acc2=i64[].NULL
					return _Bisect(acc, handler,ccnt_base,pc,b)
				ccnt_base+=pc.ccnt
			return ccnt_base
	auto Bisect(int hid,i64[] b)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		return _Bisect(acc,m_handlers[hid],0LL,m_skiplist,b)
	auto Render(double x,double y,double w,double h, float scr_x,float scr_y,float scaling)
		//x,y,w,h refer to the world space window
		R=Gui2D.detail.g_renderer
		R.PushCliprect(scr_x,scr_y,float(w)*scaling,float(h)*scaling)
		hid=m_handler_registration["handler_id_renderer"].as(int)
		handler=m_handlers[hid]
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		ccnt0=Bisect(hid,[__double_as_longlong(x),__double_as_longlong(y)])
		ccnt1=Bisect(hid,[__double_as_longlong(x+w),__double_as_longlong(y+h)])
		rendering_started=0
		dx=double(scr_x)-x*double(scaling)
		dy=double(scr_y)-y*double(scaling)
		auto dfsRender(CSLNode nd,i64 ccnt0,i64 ccnt1)
			if nd.s:
				rendering_started=1
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+hid]
				ofspp2=(hid==m_handlers.n-1?i64(nd.a.n):nd.a[n0+hid+1])
				handler.RenderText(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s, dx,dy,scaling)
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
			else
				ccnt_base=0LL
				for(pc=nd.pchild;pc;pc=pc.pnext)
					p0=max(ccnt0-ccnt_base,0LL)
					p1=min(ccnt1-ccnt_base,pc.ccnt)
					if p1>p0:
						dfsRender(pc,p0,p1)
					else if !rendering_started:
						handler.Add(acc,pc.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
					ccnt_base+=pc.ccnt
		dfsRender(m_skiplist,ccnt0,ccnt1)
		R.PopCliprect()
	/////////////////////////////////////////////////
	//todo: locator undo, conservative pairs handling
	//just record classes and ccnts - restoring ccnt for discarded locators is OK
	//todo: port edcore to js for UI interaction
	auto CreateLocator(i64 ccnt,int side)
		ret=new CLocator(){ccnt:ccnt,side:i8(side)}
		return ret
	auto XYFromCcnt(i64 ccnt)
		hid=m_handler_registration["handler_id_renderer"].as(int)
		a=GetStateAt(hid,ccnt)
		return double2(__longlong_as_double(a[0]),__longlong_as_double(a[1]))
	//todo: locator-based highlighting / hiding
	//todo: style changing
	/////////////////
	JS_MassEdit=function(JSContext JS){
		js_ops=JS.Param(0).as(JSObject)
		if !js_ops:return 0
		n=iptr(js_ops["length"].as(double))
		if !(n>0)||(n%3):
			JS.Error("bad operation array length @1".Replace(["@1",string(n)]))
			return 0
		//one array with even-odd packing
		range0=0LL
		range1=GetTextSize()
		ops=new TEditop[]
		for i=0:3:n-3
			op=TEditop(){ccnt:i64(js_ops[i].as(double)),sz:i64(js_ops[i+1].as(double)),s:js_ops[i+2].as(string)}
			if u64(op.ccnt)<u64(range0)||u64(op.ccnt+op.sz)>u64(range1)||u64(op.ccnt+op.sz)<u64(op.ccnt):
				JS.Error("invalid operation #@1".Replace(["@1",string(i)]))
				return 0
			range0=op.ccnt+op.sz
			ops.push(op)
		MassEdit(ops)
		return 0
	}
	JS_GetText=function(JSContext JS){
		ed=this
		range0=0LL
		range1=ed.GetTextSize()
		ccnt=JS.Param(0).or(range0)
		sz=JS.Param(1).or(range1)
		if u64(ccnt)<u64(range0)||u64(ccnt+sz)>u64(range1)||u64(ccnt+sz)<u64(ccnt):
			JS.Error("invalid range")
			return 0
		return JS.Return(ed.GetText(ccnt,sz))
	}
	JS_GetTextSize=function(JSContext JS){
		return JS.Return(GetTextSize())
	}
	JS_Render=function(JSContext JS){
		ed=this
		params=JS.Param(0).as(JSObject)
		if !params:return 0
		param_x=params["x"].or(0.)
		param_y=params["y"].or(0.)
		param_w=params["w"].or(0.)
		param_h=params["h"].or(0.)
		param_scr_x=params["scr_x"].or(0.f)
		param_scr_y=params["scr_y"].or(0.f)
		param_scale=params["scale"].or(1.f)
		ed.Render(
			param_x,
			param_y,
			param_w,
			param_h,
			param_scr_x*g_renderer.m_pixels_per_unit,
			param_scr_y*g_renderer.m_pixels_per_unit,
			param_scale)
		return 0
	}
	JS_CreateLocator=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		side=JS.Param(1).or(0)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			return 0
		else
			return JS.Return(CreateLocator(ccnt,side))
	}
	JS_XYFromCcnt=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			return 0
		xy=XYFromCcnt(ccnt)
		ret=JS.New()
		ret["x"]=xy[0]
		ret["y"]=xy[1]
		return JS.Return(ret)
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"m_handler_registration")
		proto.ExportMethod(this,"MassEdit",JS_MassEdit)
		proto.ExportMethod(this,"GetText",JS_GetText)
		proto.ExportMethod(this,"GetTextSize",JS_GetTextSize)
		proto.ExportMethod(this,"Render",JS_Render)
		proto.ExportMethod(this,"CreateLocator",JS_CreateLocator)
		proto.ExportMethod(this,"XYFromCcnt",JS_XYFromCcnt)

jsNewEditorBaseline=function(JSContext JS){
	obj_style=JS.Param(0).as(JSObject)
	if !obj_style:return 0
	ret=new CEditableText
	ret.AddStateHandler(new CLayouter_baseline)
	ret.Init(obj_style)
	return JS.Return(ret)
}

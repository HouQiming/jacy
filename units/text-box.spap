/*
todo:
	make ccnt built-in
	CMetaParagraph balancing
		should be easy
		formulate as recursion
			one node:
				recurse into subtree
				merge subtree results
					handle too-small nodes here
				returns list of new children
					add a level if too large
			still not balanced
				keep editing the same place
		use skiplist
			random creation of upper levels
	name-based state locating
		JS interned strings
	basic interface
		MassEdit
		handle-based locator system
		locator-aware undo history
			no-longer-used locators and stuff...
			ignore them
				which needs unique locator ids
				or erase history when deleting locators
				or just mark it in the undo history
		Render
			spatial query
		GetText
			text query
	paragraph-based structure
		bland array indexing
		O(n/C+C) edit + O(log(n)+C) seek
*/
import Gui2D.*
import Javascript.*
import System.Algorithm.*

struct TMouseMap
	double2 pos
	i64 ccnt

struct TRenderingInfo
	double2 bb
	TPositionedText[] pt
	TMouseMap[] mm

auto SearchMouseMap(TMouseMap[] mm,double x,double y0)
	y=y0
	p=0L
	for iiter=0:1
		p=mm.Bisect(function(TMouseMap a){return a.pos.y<y||a.pos.y==y&&a.pos.x<x})
		if y!=mm[p].pos.y:
			y=mm[p].pos.y
		else
			break
	return p

///////////////////////////////
//double should be as-ed
class ITextStateHandler
	function():int stateSize
	function():int isParagraphOnly
	//The "add" function must be associative
	//The result should be written to "a"
	//if AddBlock returns anything... it's considered as a per-block cache
	function(i64[] a,string s):i64[] AddBlock
	function(i64[] a,i64[] b) Add
	//For coloring states, we need a colorer
	function(i64[] a,string s):u8[] ComputeCharColorID
	//For rendering states, we need a layouter
	function(i64[] a,i64[] pp,string s):TRenderingInfo RenderText
	//function(string s):i64[] PreprocessBlock
	//For seeking states, we need comparison and in-block seeking
	function(i64[] a,i64[] b):int Compare
	function(i64[] a,i64[] pp,string s,i64[] b):iptr SeekInBlock

auto combineBB(double2 bb0,double2 bb1)
	bb=bb0
	if bb1.y:
		bb.x=0.
		bb.y+=bb1.y
	else
		bb.x+=bb1.x
	return bb

inline Utf8Chars(string s)
	return {'forEach':inline(fbody){
		ch0=0;nnxt=0;II=0L
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					ch0=(ch&0x1f)
					nnxt=1
					if ch&0x20:
						nnxt++
						if ch&0x10:
							nnxt++
							ch0&=7
				else
					ch0=(ch0<<6)+(ch&63)
					nnxt--
				if nnxt:continue
				ch=ch0
			else
				II=I
			fbody(ch,II)
	}}	

class CLayouter_baseline
	m_word_wrap=0
	m_tab_width=8
	TFont m_font
	stateSize=function(){return 2}
	isParagraphOnly=function(){return 1}
	/////////////////
	AddBlock=function(i64[] a,string s){
		line_breaks=new i64[]
		if m_word_wrap:
			//todo: m_word_wrap
		else
			line_breaks.push(0LL)
			line_breaks.push(i64(s.n))
		rinfo=RenderText(a,line_breaks,s)
		bb=combineBB(double2(__longlong_as_double(a[0]),__longlong_as_double(a[1])),rinfo.bb)
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
		return line_breaks
	}
	Add=function(i64[] a,i64[] b){
		bb=combineBB(double2(__longlong_as_double(a[0]),__longlong_as_double(a[1])),double2(__longlong_as_double(b[0]),__longlong_as_double(b[1])))
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(i64[] a,i64[] b){
		ret=__C_compare(a[1],b[1])
		if ret==0:ret=__C_compare(a[0],b[0])
		return ret
	}
	SeekInBlock=function(i64[] a,i64[] line_breaks,string s,i64[] b){
		x=__longlong_as_double(b[0])
		y=__longlong_as_double(b[1])-__longlong_as_double(a[1])
		if y>0.0:
			x-=__longlong_as_double(a[0])
		hc=Gui2D.detail.g_renderer.GetCharacterHeight(fnt)
		line_id=int(floor(y/hc))
		if line_id<0:
			return 0L
		else if line_id>line_breaks.n-1:
			return s.n
		else
			l0=line_breaks[line_id]
			l1=line_breaks[line_id+1]
			rinfo=RenderText(a,[0L,l1-l0],s[l0:l1-1])
			x=__longlong_as_double(b[0])
			y=__longlong_as_double(b[1])
			return SearchMouseMap(rinfo.mm,x,y)
	}
	/////////////////
	RenderText=function(i64[] a,i64[] line_breaks,string s):TRenderingInfo{
		pt=new TPositionedText[]
		mm=new TMouseMap[]
		w_tab=double(m_tab_width)*double(Gui2D.detail.g_renderer.CacheGlyph(m_font,' ')[0].dx)
		hc=Gui2D.detail.g_renderer.GetCharacterHeight(fnt)
		x=__longlong_as_double(a[0])
		y=__longlong_as_double(a[1])
		for i=0:line_breaks.n-2
			got_newline=0
			for ch,I in Utf8Chars(s[line_breaks[i]:line_breaks[i+1]-1])
				mm.push(TMouseMap(){pos:double2(x,y),ccnt:line_breaks[i]+I})
				if ch=='\r'||ch=='\n':
					//nothing
					if ch=='\n':got_newline=1
					continue
				else if ch==' ':
					x+=double(Gui2D.detail.g_renderer.CacheGlyph(m_font,ch)[0].dx)
				else if ch=='\t':
					x=(floor(x/w_tab)+1.0)*w_tab
				else
					(gc_I,delta_y)=Gui2D.detail.g_renderer.CacheGlyph(m_font,ch)
					pt.push(TPositionedText(){pos:double2(x,y),ch:ch})
					x+=gc_I.dx
			if got_newline:
				x=0.
				y+=hc
		return TRenderingInfo(){bb:double2(x,y),pt:pt,mm:mm}
	}

///////////////////////////////
/*/
hybrid line-size consistency
	rendering breaks
		LTR|RTL
		\n|
	block
		design criteria
			should be O(n/C)
			should have a tight rendering BB
		consistency
			don't break UTF8 chars
			block size must not exceed C+epsilon
			if a block contains one rendering break
				it must be the block tail
			if a block contains more than one rendering breaks
				the block head must also be one
			\n and LTR|RTL are nested
				the break consistencies should be satisfied separately
					with \n taking priority
				e.g. if the block contains more than one line breaks
					the head must be one line break, not a LTR|RTL
			if we have isParagraphOnly:
				allow block size to exceed C
				but still merge short lines
/*/
struct TEditop
	//delete first, add after
	i64 ccnt
	i64 sz
	string s

struct TBlockOp
	//delete first, add after
	i64 ccnt
	i64 sz
	string[] ss

class CLocator
	i64 ccnt

class CSLNode
	CSLNode pchild
	CSLNode pnext
	//////////
	iptr ccnt
	string s
	i64[] a

g_seeker_ccnt=new CSeeker_ccnt
class CEditableText
	m_skiplist=new CSLNode
	m_locators=new CLocator[]
	m_total_ccnt=0L
	m_layout_valid_to=0L
	////////////////////
	m_handlers=new ITextStateHandler[]
	m_state_ofs=new iptr[]
	m_hid_renderer=-1L
	m_hid_ccnt=-1L
	m_is_paragraph_only=0
	m_block_size=1024
	inline AddStateHandler(a)
		m_handlers.push(getInterface(a,ITextStateHandler))
		return m_handlers.n-1
	auto InitStateHandlers()
		m_hid_ccnt=AddStateHandler(g_seeker_ccnt)
		ofs=0L
		foreach hstate,I in m_handlers
			if hstate.isParagraphOnly&&hstate.isParagraphOnly():
				m_is_paragraph_only=1
			if hstate.RenderText:
				assert(m_hid_renderer==-1L)
				m_hid_renderer=I
			ofs+=hstate.stateSize()
			m_state_ofs.push(ofs)
		m_state_ofs.push(ofs)
	//todo: font/color ids in rendering, JS style interpretation
	auto BlockEdit(CSLNode nd,TBlockOp[] bops)
		assert(!nd.s)
		//for each child -> untouched / new list (on which we apply random growth)
		//so the return value is a list
		!?
	auto BlockFromCcnt(i64 ccnt0)
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				nd=nd.pnext
			if nd.s:
				return (nd,ccnt0-ccnt_base)
			assert(!!nd.pchild)
			nd=nd.pchild
	auto MassEdit(TEditop[] ops)
		//editop -> block replace: mainly take-the-next-and-merge
		//do the locators here
		pb=CSLNode.NULL
		ccnt_base=0LL
		ofs=0LL
		//////////
		bops=new TBlockOp[]
		bop_current=TBlockOp()
		s_pool=new string
		s_pool_last_newline=0L
		//s_pool_has_bidi_bound=0
		auto poolString(string s)
			if !s.n:return
			auto p_last_flush=0L
			auto p_last_newline=s_pool_last_newline
			auto p=s_pool.n
			auto addBlock(iptr p0,iptr p1)
				p_last_flush=p1
				//virtual string access
				auto s_block=string.NULL
				if p1<=s_pool.n:
					s_block=new(s_pool[p0:p1-1])
				else if p0>=s_pool.n:
					s_block=new(s[p0-s_pool.n:p1-s_pool.n-1])
				else
					s_block=s_pool[p0:]+s[:p1-s_pool.n-1]
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
			foreach chc,I in s
				ch=int(u8(chc))
				if (ch&0xc0)!=0x80&&!(s_pool.n&&s_pool.back()=='\r'&&ch=='\n'):
					//check for block breaking, but do not break UTF-8 chars or \r\n
					if p-p_last_newline>=m_block_size&&(!m_is_paragraph_only||p_last_newline>p_last_flush):
						//need a break...
						if p_last_newline:
							//we got newlines in the block, we can only break at s_pool_last_newline
							addBlock(p_last_flush,p_last_newline)
						else
							//it's a single-line block...
							addBlock(p_last_flush,p)
				p++//s_pool.push(chc)
				if ch=='\n':
					p_last_newline=p
			//virtual -> real
			if p_last_flush<s_pool.n:
				s_pool=s_pool[p_last_flush:]+s
			else
				s_pool=new(s[p_last_flush-s_pool.n:])
			s_pool_last_newline=max(p_last_newline-p_last_flush,0L)
		auto flush()
			if pb:
				assert(ofs<pb.s.n)
				poolString(pb.s[iptr(ofs):])
			if s_pool_last_newline:
				s_block=new(s_pool[s_pool_last_newline-1:])
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
				s_pool=new(s_pool[s_pool_last_newline:])
			if s_pool.n:
				assert(!m_is_paragraph_only)
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_pool)
			if bop_current.sz||bop_current.ss:
				bops.push(bop_current)
				bop_current=TBlockOp()
		foreach op in ops
			if !pb||ccnt_base+pb.ccnt<op.ccnt:
				//we've left the current block, need to reseek
				flush()
				(pb,ofs)=BlockFromCcnt(op.ccnt)
				ccnt_base=op.ccnt-ofs
				bop_current.ccnt=ccnt_base
				ofs=0LL
			ofs_new=i64(op.ccnt-ccnt_base)
			if ofs_new>ofs:
				poolString(pb.s[iptr(ofs):iptr(ofs_new)-1])
				ofs=ofs_new
				assert(ofs<=pb.ccnt)
				if ofs==pb.ccnt:
					//merge with the next block - it's mandatory for paragraph-only guys
					(pb,ofs)=BlockFromCcnt(ccnt_base+ofs)
					assert(!ofs)
					ccnt_base=op.ccnt-ofs
					bop_current.ccnt=ccnt_base
					ofs=0LL
			//move by sz
			if op.sz:
				ofs+=op.sz
				if ofs>=pb.ccnt:
					(pb,ofs)=BlockFromCcnt(op.ccnt+op.sz)
			bop_current.sz=op.ccnt+op.sz-bop_current.ccnt
			if op.s:poolString(op.s)
		flush()
		//block replace -> skiplist edit
		nds=BlockEdit(m_skiplist,bops)
		!? m_skiplist= 
		//todo: recompute states...
	auto SeekGeneral(int hid,i64[] b)
		//m_handlers[hid].Compare()
		!?
	auto Render(double x,double y,double w,double h,auto drawText)
		//x,y,w,h refer to the window
		!? //todo: relayout, styling...
	auto GetText(iptr ccnt,iptr sz)
		!?

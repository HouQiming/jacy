//sharpening filter for font -- just downsample it differently... would it even work?
import "javascript.jc"
import "s-d-l.jc"
import "g-l.jc"
import "leak-detection.jc"
import Javascript.*
import SDL.*
import GL.*
import System.Math.*
import System.Algorithm.*
import System.Console.*

module detail{
FTW_LoadFont=__c_function(__pointer,"FTW_LoadFont","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetCharacterEx=__c_function(__pointer,"FTW_GetCharacterEx","stb_truetype.h", "c_files","stb_truetype.c")
FTW_UnloadFont=__c_function(int,"FTW_UnloadFont","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetGlyphId=__c_function(int,"FTW_GetGlyphId","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetAscent=__c_function(float,"FTW_GetAscent","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetGlyphAdvance=__c_function(float,"FTW_GetGlyphAdvance","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetKerning=__c_function(float,"FTW_GetKerning","stb_truetype.h", "c_files","stb_truetype.c")
FTW_SetRetardedWindingOrder=__c_function(int,"FTW_SetRetardedWindingOrder","stb_truetype.h", "c_files","stb_truetype.c")
stbi_load_from_memory=__c_function(__pointer,"stbi_load_from_memory","stb_image.h", "c_files","stb_image.c")
stbi_zlib_decode_malloc=__c_function(__pointer,"stbi_zlib_decode_malloc","stb_image.h", "c_files","stb_image.c")
stbi_zlib_decode_noheader_malloc=__c_function(__pointer,"stbi_zlib_decode_noheader_malloc","stb_image.h", "c_files","stb_image.c")
osal_mmap_res_zip=__c_function(__pointer,"osal_mmap_res_zip","spaprt_portable.h")
class CFinalBuffers
	tex0=int[].NULL
	//vbo1 is the transp stuff
	vbo0=int[].NULL
	vbo1=int[].NULL
	nv0=0
	nv1=0
	w0=0
	h0=0
	hreal=0
	zmax=0

auto promoteToTextureSize(int w0)
	//w|=w>>16
	w=w0-1
	w|=w>>1
	w|=w>>2
	w|=w>>4
	w|=w>>8
	w++
	return w

//g_pack_counter=0
class CBinPacker
	m_wbig=0
	m_hbig=0
	m_skyline=int3[].NULL
	auto __init__(int w)
		m_wbig=w
		m_hbig=0
		m_skyline=[int3(0,w, 0)]
	auto Pack(int w,int h,int dryrun)
		PACKING_Y_TOLERANCE=24
		skyline=m_skyline
		sups=new int[]
		p0=0
		pa0=0
		cands=new int2[]
		foreach sitem,I in skyline
			while sups.n>p0&&skyline[sups.back()].z<=sitem.z:
				sups.pop()
				//g_pack_counter++
			sups.push(int(I))
			if p0>0:
				ximin=skyline[sups[p0-1]].x+skyline[sups[p0-1]].y
			else
				ximin=0
			while pa0<I&&skyline[pa0].x+skyline[pa0].y<=sitem.x+sitem.y-w:
				/*g_pack_counter++*/
				xi=skyline[pa0].x
				if xi>=ximin:
					while p0<sups.n&&sups[p0]<pa0:
						p0++
					hbase=skyline[sups[p0]].z
					assert(!cands.n||cands.back().x<=xi)
					if !cands.n||cands.back().y>hbase:
						cands.push(int2(xi,hbase))
				pa0++
			////////////////
			xi=skyline[pa0].x
			if xi+w<=sitem.x+sitem.y://.wbig:
				while p0<sups.n&&sups[p0]<pa0:
					/*g_pack_counter++*/
					p0++
				hbase=skyline[sups[p0]].z
				assert(!cands.n||cands.back().x<=xi)
				if !cands.n||cands.back().y>hbase:
					cands.push(int2(xi,hbase))
			while p0<sups.n-1&&skyline[sups[p0]].x+skyline[sups[p0]].y<=sitem.x+sitem.y-w:
				/*g_pack_counter++*/
				p0++
			hbase=skyline[sups[p0]].z
			xi=sitem.x+sitem.y-w
			if xi>=0:
				assert(!cands.n||cands.back().x<=xi)
				if !cands.n||cands.back().y>hbase:
					cands.push(int2(xi,hbase))
			/*g_pack_counter++*/
		xbest=-1
		ybest=-1
		if cands.n:
			y_base=cands.back().y
			y_ok=y_base+((h*PACKING_Y_TOLERANCE+31)>>6)
			for i=0:cands.n-1
				if cands[i].y<=y_ok:
					xbest=cands[i].x
					ybest=cands[i].y
					break
		if xbest>=0&&!dryrun:
			//go up!
			skyline2=new int3[]
			did=0
			foreach sitem,I in skyline
				if sitem.x+sitem.y<=xbest||sitem.x>=xbest+w:
					skyline2.push(sitem)
				else
					if sitem.x<xbest:
						skyline2.push(int3(sitem.x,xbest-sitem.x,sitem.z))
					if !did:
						did=1
						skyline2.push(int3(xbest,w,ybest+h))
					if xbest+w<sitem.x+sitem.y:
						skyline2.push(int3(xbest+w,sitem.x+sitem.y-(xbest+w),sitem.z))
			m_skyline=skyline2
			m_hbig=max(m_hbig,ybest+h)
		return int2(xbest,ybest)

auto IsAlnumUnicode(int ch)
	if ch>=192:
		if ch>=0x3000&&ch<=0x301f&&ch!=0x3005&&ch!=0x3006:return 0
		if ch>=0x2000&&ch<=0x206f:return 0
		if ch>=0xff00&&ch<0xff5f:
			return u32(ch-(0xfee0+0x30))<10u||u32(ch-(0xfee0+0x41))<26u||u32(ch-(0xfee0+0x61))<26u
		if ch>=0xff5f&&ch<0xff65:
			return 0
		return 1
	else
		return u32(ch-0x30)<10u||u32(ch-0x41)<26u||u32(ch-0x61)<26u

///////////////////////
/*
vbo / tex caching:
	same vbo + tex for all windows
	any window changed = redraw everything
*/
struct TTextureSubImage
	x=0
	y=0
	w=0
	h=0

struct TStretchDIBits
	vdata=int4()
	hwnd=NULL
	bmpid=0
	C=int4()

struct TDrawCall
	hwnd=NULL
	pv=0
	nv=0
	crd16_scale=0
	window_w=0.f
	window_h=0.f
	JSObject js_callback
	function() native_callback

class CCoreFont
	id=0
	hfnt=NULL
	sdata=string.NULL
	y_baseline_per_height=0.f
	inline GetGlyphId(int ch)
		return FTW_GetGlyphId(hfnt,ch)
	auto __done__()
		FTW_UnloadFont(hfnt)
		hfnt=NULL

struct TChainFont
	CCoreFont hfnt
	//numbers are measured at height 1
	float scale
	float draw_dx,draw_dy

struct TChainCacheItem
	float dx
	int fntid

class CFontChain
	TChainFont[] fonts
	float y_baseline_per_height,base_scale
	//float base_scale
	TChainCacheItem[] cache_ascii
	TChainCacheItem[int] cache_unicode
	auto CreateCodePoint(int ch)
		fntid=-1
		dx=0.f
		for cfnt,I in fonts
			gid=FTW_GetGlyphId(cfnt.hfnt.hfnt,ch)
			if gid:
				dx=FTW_GetGlyphAdvance(cfnt.hfnt.hfnt,cfnt.scale,gid)
				fntid=int(I+1)
				break
		ci=TChainCacheItem(){dx:dx,fntid:fntid}
		if ch<128:
			cache_ascii[ch]=ci
		else
			cache_unicode[ch]=ci
		return ci
	inline QueryCodePoint(int ch)
		if ch<128:
			ci=cache_ascii[ch]
		else
			ci=cache_unicode[ch]
		if !ci.fntid:
			ci=CreateCodePoint(ch)
		return ci

struct TFont
	pfnt=CFontChain.NULL
	h=0.f
	embolden=0
	inline SmartEmbolden(int m_color)
		embolden+=int(3000.f/h)
	//auto SmartEmbolden(int m_color)
	//	//avoid creating too many glyphs during text fading
	//	embolden+=((int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*3000.f/h)+8)&-16)
	//	//embolden+=((int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*2000.f/h)+8)&-16)

class CGlyphCacheItem
	int tex_id
	float x_draw,y_draw,w_draw,h_draw

struct TPositionedText
	pos=float2()
	ch=0

class CTextLayout
	TPositionedText[] chars
	//x0, y, w, h
	float4[] underlines
	float2 dims

class CSandboxWindow
	int w,h

class CUISandbox
	m_ui_search_paths=new string[]
	CZipFile m_ui_zip
	auto UIReadAll(string s_fname)
		foreach spath in m_ui_search_paths.ReverseOrder()
			sfn_i=spath+s_fname
			if System.IO.FileExists(sfn_i):
				return System.IO.ReadAll(sfn_i)
		if m_ui_zip:
			return m_ui_zip.ReadAll(s_fname)
		else
			return string.NULL
	auto UILoadStaticZip()
		__generate_json("use_static_res","1")
		sz=0L
		pzip=osal_mmap_res_zip(&sz)
		if pzip:
			arr_res_zip=new string
			arr_res_zip.__bind(1,iptr(pzip),iptr(sz))
			//Writeln('>>> ',pzip,' ',sz)
			m_ui_zip=ParseZip(arr_res_zip)
	auto UILoadZip(string szipname)
		arr_res_zip=szipname
		if !arr_res_zip||!arr_res_zip.n:
			if Platform.ARCH=='android'||Platform.ARCH=='ios'||Platform.ARCH=='mac':
				if Platform.ARCH=='android':
					__generate_json("c_files","zipres.c")
					__generate_json("android_system_libnames","android")
				else if Platform.ARCH=='ios'||Platform.ARCH=='mac':
					__generate_json("c_files","zipres_ios.m")
				sz=0L
				pzip=osal_mmap_res_zip(&sz)
				if pzip:
					arr_res_zip=new string
					arr_res_zip.__bind(1,iptr(pzip),iptr(sz))
			else
				arr_res_zip=System.IO.ReadAll(System.Env.GetExecutablePath()+"res.zip")
		m_ui_zip=ParseZip(arr_res_zip)
	inline UIRunJS(JSContext JS,string fn)
		err=JS.evalVoid(UIReadAll(fn),fn)
		if err:
			if Platform.BUILD=="debug":
				Writeln(err["stack"].or(""))
			else
				if g_log_file:
					if !System.IO.FileExists(g_log_file):
						f=System.IO.CreateFile(g_log_file)
					else
						f=System.IO.fopen(g_log_file,System.IO.OPEN_READ|System.IO.OPEN_WRITE)
						f.SeekFromEnd(0L)
					if f:
						f.Write("\n"+err["stack"].or(""))
						f.Close()

lanczos_filter=function(int aa,int szwnd,float font_sharpening){
	auto htap=aa*szwnd
	auto ret=new float[htap*2+1]
	auto scale=float(PI)/float(aa)
	auto scale2=float(PI)/float(aa*szwnd)
	////////
	//sinc
	for i=1:htap
		auto x=scale*float(i)
		//auto x2=scale2*float(i)
		//v=sin(x)*sin(x2)/(x*x2)
		v=sin(x)/x
		ret[htap+i]=v
		ret[htap-i]=v
	ret[htap]=1.f
	////////
	//sharpening
	auto scale=font_sharpening
	auto lap=new float[ret.n]
	for i=1:ret.n-2
		lap[i]=ret[i]*2.f-ret[i-1]-ret[i+1]
	for i=0:ret.n-1
		ret[i]+=lap[i]*scale
	////////
	//windowing
	for i=1:htap
		auto x2=scale2*float(i)
		v=sin(x2)/x2
		ret[htap+i]*=v
		ret[htap-i]*=v
	////////
	auto wgt=0.f
	for i=0:ret.n-1
		wgt+=ret[i]
	wgt=1.f/wgt
	for i=0:ret.n-1
		ret[i]*=wgt
	return ret
}
box_filter=function(int aa){
	auto ret=new float[aa]
	auto val=1.f/float(aa)
	for i=0:aa-1
		ret[i]=val
	return ret
}

//note: m_texture_height cannot go over m_texture_width
//the DC singleton
struct T3x3ColorDesc
	float2 p0,p1
	int C0,C1
	i8 is_gradient
struct TRRContext
	float border_width
	float eff_radius
	int bmpid,bmpid2
	T3x3ColorDesc color,border_color
	i8 is_valid
class CRenderer
	//////////////
	//current status
	m_hwnd=NULL
	COORD_MAX=65535
	VERTEX_SIZE=3
	m_clip=float4()
	m_clip_stack=new float4[]
	//////////////
	//use int ids natively and leave the map stuff to js
	m_pixels_per_unit=1.f
	m_font_sharpening=0.f
	m_gamma=2.2f
	m_mipmap_level=0
	m_text_y_snap=1
	//////////////
	m_texid=0u
	m_tex_has_to_be_deleted=0
	m_texture_packer=CBinPacker.NULL
	m_texture_width=1024
	m_texture_height=0
	m_texture_data=new u8[]
	m_texture_h_downloaded=0
	m_texture_h_packed_to=0
	m_packed_textures=new TTextureSubImage[]
	m_StretchDIBits_calls=new TStretchDIBits[]
	//////////////
	//single vbo for simplicity
	m_vbo=new int[]
	m_gl_vbo=0u
	m_gl_vbo_tiny=0u
	m_gl_vbo_sz=0L
	m_vbo_uploaded=0
	m_drawcall_start=0
	m_crd16_scale=1
	m_window_w=1.f
	m_window_h=1.f
	m_uv16_scale=1
	m_drawcalls=new TDrawCall[]
	//////////////
	CJSGLRenderToTextureContext m_srgb_fbo
	u32 m_clear_color
	GLTechnique m_manual_srgb_tech
	m_srgb_supported=-1
	//m_tex_is_srgb=0
	m_tech=new GLTechnique
	m_caret_tech=new GLTechnique
	//m_vboid=0u
	//m_vbo_size=0
	//////////////
	//the dpis are not necessarily dpis
	//inline SetDesignDPI(int dpi)
	//	m_design_dpi=dpi
	//auto SetScreenDPI(int dpi)
	auto SetScalingFactor(float scale)
		//m_static_textures=new TBitmap[]
		//m_static_packings=TTextureSubImage[].NULL
		m_pixels_per_unit=scale
		//m_screen_dpi=dpi
		//create a pure white bmp
		//img3x3=new int[9]
		//for i=0:8
		//	img3x3[i]=-1
		//LoadStaticBitmap(TBitmap(){rgba:img3x3,w:3,h:3})
		//LoadStaticBitmap(TBitmap(){rgba:[-1],w:1,h:1})
		//LoadStaticBitmap(TBitmap(){rgba:[0xff0000ff],w:1,h:1})
		////////
		m_mipmap_level=0
		sdpi=1.f
		while sdpi*2.f<=m_pixels_per_unit
			sdpi*=2.f
			m_mipmap_level++
		//m_pixels_per_unit=f32(m_screen_dpi)/f32(m_design_dpi)
	//////////////////////////
	auto SavePNG(string fn, int[] img,int w,int h)
		stbi_write_png_to_mem=__c_function(__pointer,"stbi_write_png_to_mem","stb_image_write.h", "c_files","stb_image_write.c")
		stbi_free_image_write=__c_function(__pointer,"stbi_free_image_write","stb_image_write.h", "c_files","stb_image_write.c")
		len=0
		spng=stbi_write_png_to_mem(img,w*4,w,h,4,&len)
		if !spng:
			assert(0)
			return
		spng_str=__ptrToString(spng,len)
		System.IO.CreateFile(fn).Write(spng_str)
		stbi_free_image_write(spng)
	//////////////////////////
	auto EmptyCache()
		m_glyph_cache.discard()
		m_glyph_cache=new CGlyphCacheItem[int3]
		//////////////
		//m_texture_height=0
		//m_texture_data=new u8[]
		m_texture_packer=new CBinPacker(m_texture_width)
		m_texture_h_downloaded=0
		m_texture_h_packed_to=0
		m_packed_textures=new TTextureSubImage[]
		CreatePackedTexture([u8(255),u8(255),u8(255),u8(255),u8(255),u8(255),u8(255),u8(255),u8(255)],3,3)
	auto CreatePackedTexture(u8[] img,int w,int h)
		xy=m_texture_packer.Pack(w,h,0)
		ret=int(m_packed_textures.n)
		m_packed_textures.push(TTextureSubImage(){x:xy.x,y:xy.y,w:w,h:h})
		h_new=xy.y+h
		texture_height_needed=promoteToTextureSize(h_new)
		if texture_height_needed>m_texture_height:
			if !m_tex_has_to_be_deleted:
				m_tex_has_to_be_deleted=1
				m_texture_h_downloaded=0
			m_texture_height=texture_height_needed
			m_texture_data.resize(m_texture_width*m_texture_height)
		for i=0:h-1
			copy(m_texture_data[(xy.y+i)*m_texture_width+xy.x:],img[i*w:(i+1)*w-1])
		m_texture_h_downloaded=min(m_texture_h_downloaded,xy.y)
		if m_texture_h_packed_to<h_new:
			m_texture_h_packed_to=h_new
			if m_texture_h_packed_to>=(m_texture_width>>1):
				//avoid texture over-use
				//Writeln('texture overuse ',xy,' ',w,' ',h,' ',m_texture_width,' ',m_texture_height)
				m_glyph_cache_invalidated=1
		return ret
	//////////////
	m_tick0=0LL
	m_frame_ticks=0LL
	auto BeginFrame()
		//Writeln('----------------')
		m_drawcalls.clear()
		m_vbo.clear()
		if m_glyph_cache_invalidated:
			EmptyCache()
			m_glyph_cache_invalidated=0
		m_fast_glyph_cache_font=TFont()
		//m_fast_glyph_cache=TFastGlyphCacheItem[int].NULL
		//m_fast_glyph_cache_ascii=TFastGlyphCacheItem[].NULL
		m_has_new_glyph_cache_entry=0
		m_StretchDIBits_calls=new TStretchDIBits[]
		m_tick0=System.Time.tick64()
	auto EndFrame()
		//pack m_dynamic_textures and apply the dynamic drawcalls
		if m_StretchDIBits_calls.n:
			m_vbo.resize(m_StretchDIBits_calls.n*(VERTEX_SIZE*6))
			foreach scall,I in m_StretchDIBits_calls
				packed=m_packed_textures[scall.bmpid]
				n0=I*(VERTEX_SIZE*6)
				vdata=scall.vdata
				u0=__int_as_float(0x4b000000+1+packed.x)-8388608.f
				v0=__int_as_float(0x4b000000+1+packed.y)-8388608.f
				du=__int_as_float(0x4b000000-2+packed.w)-8388608.f
				dv=__int_as_float(0x4b000000-2+packed.h)-8388608.f
				//clip_u0=f32(vdata.z&0xffff)/32768.f
				//clip_v0=f32(u32(vdata.z)>>16)/32768.f
				//clip_u1=f32(vdata.w&0xffff)/32768.f
				//clip_v1=f32(u32(vdata.w)>>16)/32768.f
				clip_u0=__int_as_float((vdata.z&0xffff)+0x43800000)-256.f
				clip_v0=__int_as_float(int(u32(vdata.z)>>16)+0x43800000)-256.f
				clip_u1=__int_as_float((vdata.w&0xffff)+0x43800000)-256.f
				clip_v1=__int_as_float(int(u32(vdata.w)>>16)+0x43800000)-256.f
				u1=u0+du*clip_u1
				v1=v0+dv*clip_v1
				u0=u0+du*clip_u0
				v0=v0+dv*clip_v0
				inline f2i_uv(float f)
					//return max(min(int(f*float(m_uv16_scale)),65535),0)
					return max(min(__float_as_int(f*float(m_uv16_scale)+8388608.f)-0x4b000000,65535),0)
				u0i=f2i_uv(u0)
				v0i=(f2i_uv(v0)<<16)
				u1i=f2i_uv(u1)
				v1i=(f2i_uv(v1)<<16)
				m_vbo[n0+(VERTEX_SIZE*0+0)]=vdata.x
				m_vbo[n0+(VERTEX_SIZE*0+1)]=v0i+u0i
				m_vbo[n0+(VERTEX_SIZE*0+2)]=scall.C[0]
				m_vbo[n0+(VERTEX_SIZE*1+0)]=(vdata.x&0xffff0000)+(vdata.y&0xffff)
				m_vbo[n0+(VERTEX_SIZE*1+1)]=v0i+u1i
				m_vbo[n0+(VERTEX_SIZE*1+2)]=scall.C[1]
				m_vbo[n0+(VERTEX_SIZE*2+0)]=vdata.y
				m_vbo[n0+(VERTEX_SIZE*2+1)]=v1i+u1i
				m_vbo[n0+(VERTEX_SIZE*2+2)]=scall.C[2]
				//////////////////////////////////////////
				m_vbo[n0+(VERTEX_SIZE*3+0)]=vdata.x
				m_vbo[n0+(VERTEX_SIZE*3+1)]=v0i+u0i
				m_vbo[n0+(VERTEX_SIZE*3+2)]=scall.C[0]
				m_vbo[n0+(VERTEX_SIZE*4+0)]=vdata.y
				m_vbo[n0+(VERTEX_SIZE*4+1)]=v1i+u1i
				m_vbo[n0+(VERTEX_SIZE*4+2)]=scall.C[2]
				m_vbo[n0+(VERTEX_SIZE*5+0)]=(vdata.x&0xffff)+(vdata.y&0xffff0000)
				m_vbo[n0+(VERTEX_SIZE*5+1)]=v1i+u0i
				m_vbo[n0+(VERTEX_SIZE*5+2)]=scall.C[3]
				//Writeln(u0,' ',v0,' ',du,' ',dv,' ',formatNumber(u32(scall.C),{base:16,align:8}))
			m_StretchDIBits_calls=TStretchDIBits[].NULL
			//dt=System.Time.tick64()-tick0
			//Writeln('dyntex=',formatNumber(System.Time.TicksToSeconds(dt)*1000.,{frac:2}),'ms')
		m_vbo_uploaded=0
		m_frame_ticks=System.Time.tick64()-m_tick0
	//inline texsubimage_format()
	//	if m_srgb_supported&&IS_OPENGL_ES:
	//		return GL_SRGB_ALPHA
	//	else
	//		return GL_RGBA
	auto TestSRGB()
		if m_srgb_supported<0:
			if IS_OPENGL_ES:
				m_srgb_supported=!!SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_sRGB")
			else
				m_srgb_supported=!!(SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_texture_sRGB")&&SDL.detail.SDL_GL_ExtensionSupported("GL_ARB_framebuffer_sRGB"))
				//if Platform.ARCH=="linux32"||Platform.ARCH=="linux64":
				//	if m_srgb_supported:
				//		is_capable=0
				//		glGetIntegerv(GL_FRAMEBUFFER_SRGB_CAPABLE_EXT,&is_capable)
				//		if !is_capable:
				//			m_srgb_supported=0
			//m_srgb_supported=0
			//Writeln('m_srgb_supported=',m_srgb_supported)
			//Writeln(!!SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_sRGB"))
			//Writeln(!!(SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_texture_sRGB")))
			//Writeln(!!(SDL.detail.SDL_GL_ExtensionSupported("GL_ARB_framebuffer_sRGB")))
			if Platform.IS_WINDOWS:
				//if System.IO.FileExists(System.Env.GetExecutablePath()+"/opengl32.dll"):
				//	//hack: LLVMPipe doesn't support it but lies about its extensions
				//	m_srgb_supported=0
				//if(
				//System.IO.FileExists(System.Env.ExpandEnvironmentStrings("%windir%/system32/vm3dgl32.dll"))||
				//System.IO.FileExists(System.Env.ExpandEnvironmentStrings("%windir%/system32/vm3dgl64.dll"))):
				//	//hack: VMWare doesn't support it but lies about its extensions
				//	m_srgb_supported=0
				//too many different Windows drivers, can't expect them to work
				m_srgb_supported=0
			if Platform.ARCH=="mac":
				//hack: Mac supports it but lies about the extensions
				m_srgb_supported=1
			//if Platform.ARCH=="ios":
			//	m_srgb_supported=1
			if Platform.ARCH=="android":
				//we shouldn't trust Android devices with their claims
				m_srgb_supported=0
			if Platform.ARCH=="ios":
				//iOS does it in a different way than what we need
				m_srgb_supported=0
			if !m_srgb_supported:
				m_srgb_supported=2
	auto debugDumpVBO()
		Writeln('=========== Draw')
		inline i2f_P(int i)
			return (__int_as_float(i+0x4b000000)-8388608.f)/float(m_crd16_scale)
		inline i2f_uv(int i)
			return (__int_as_float(i+0x4b000000)-8388608.f)/float(m_uv16_scale)
		for i=0:VERTEX_SIZE:m_vbo.n-VERTEX_SIZE
			P_x=i2f_P(m_vbo[i]&0xffff)
			P_y=i2f_P((m_vbo[i]>>16)&0xffff)
			u=i2f_uv(m_vbo[i+1]&0xffff)
			v=i2f_uv((m_vbo[i+1]>>16)&0xffff)
			Writeln(formatNumber(P_x,{frac:1}),' ',formatNumber(P_y,{frac:1}),' ',formatNumber(u,{frac:3}),' ',formatNumber(v,{frac:3}),' ',
				formatNumber(u32(m_vbo[i+2]),{base:16,align:8}))
			if ((i/VERTEX_SIZE)&3)==3:
				Writeln('-------')
	auto DrawWindow(JSContext JS,__pointer hwnd_onlydraw,float2 translation,float2 scale)
		if !m_vbo_uploaded:
			m_vbo_uploaded=1
			if m_gl_vbo_sz<m_vbo.sz:
				buf_ret=[m_gl_vbo]
				m_gl_vbo_sz=0L
				m_gl_vbo=0u
				glDeleteBuffers(1,__pointer(buf_ret.d))
				buf_ret.discard()
			if !m_gl_vbo:
				buf_ret=[0u]
				glGenBuffers(1,__pointer(buf_ret.d))
				m_gl_vbo=buf_ret[0]
				m_gl_vbo_sz=m_vbo.sz
				glBindBuffer(GL_ARRAY_BUFFER,m_gl_vbo)
				glBufferData(GL_ARRAY_BUFFER,m_gl_vbo_sz*sizeof(int),NULL,GL_DYNAMIC_DRAW)
				//glBindBuffer(GL_ARRAY_BUFFER,0u)
				buf_ret.discard()
			glBindBuffer(GL_ARRAY_BUFFER,m_gl_vbo)
			glBufferSubData(GL_ARRAY_BUFFER,0L,m_vbo.n*sizeof(int),__pointer(m_vbo.d))
		TestSRGB()
		wnd_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(wnd_viewport.d));
		JS["UI"]["m_gl_curwindow_w"]=wnd_viewport[2]
		JS["UI"]["m_gl_curwindow_h"]=wnd_viewport[3]
		if m_srgb_supported==2:
			//manual sRGB
			wnd_w=wnd_viewport[2]
			wnd_h=wnd_viewport[3]
			if !m_srgb_fbo||m_srgb_fbo.w!=wnd_w||m_srgb_fbo.h!=wnd_h:
				fbo_w=wnd_w
				fbo_h=wnd_h
				if m_srgb_fbo:
					//fbo_w=max(fbo_w,m_srgb_fbo.w)
					//fbo_h=max(fbo_h,m_srgb_fbo.h)
					m_srgb_fbo.discard()
				m_srgb_fbo=glCreateRenderToTextureContext(GL_RGBA8,fbo_w,fbo_h,g_rtt_flags)
			bk_fbo=new u32[1]
			glGetIntegerv(GL_FRAMEBUFFER_BINDING,__pointer(bk_fbo.d))
			//glClearColor(1.f,0.f,1.f,1.f)
			//glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)
			//c_exit=__c_function(int,"exit","stdlib.h")
			//c_exit(0)
			glBindFramebuffer(GL_FRAMEBUFFER,m_srgb_fbo.m_fbo)
			glViewport(0,0,wnd_w,wnd_h)
			C_clear=m_clear_color
			c0=f32(C_clear&0xffu)/255.f
			c1=f32((C_clear>>8)&0xffu)/255.f
			c2=f32((C_clear>>16)&0xffu)/255.f
			if m_gamma!=1.f:
				c0=pow(c0,m_gamma)
				c1=pow(c1,m_gamma)
				c2=pow(c2,m_gamma)
			glClearColor(c0,c1,c2,f32(C_clear>>24)/255.f)
			glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)
		if m_tex_has_to_be_deleted:
			m_tex_has_to_be_deleted=0
			glDeleteTextures(1,&m_texid)
			m_texid=0u
		if !m_texid:
			m_texid=glCreateTexture(GL_ALPHA8,m_texture_width,m_texture_height, GL_LINEAR,GL_CLAMP_TO_EDGE,GL_CLAMP_TO_EDGE,NULL)
		if m_texture_h_downloaded<m_texture_h_packed_to:
			glBindTexture(GL_TEXTURE_2D,m_texid)
			glTexSubImage2D(GL_TEXTURE_2D,0,0,m_texture_h_downloaded,
				m_texture_width,m_texture_h_packed_to-m_texture_h_downloaded,GL_ALPHA,GL_UNSIGNED_BYTE,
				__pointer(m_texture_data.d+m_texture_h_downloaded*m_texture_width))
			glBindTexture(GL_TEXTURE_2D,0u)
			//Writeln('upload texture: ',m_texture_h_downloaded,' -> ',m_texture_h_packed_to)
			m_texture_h_downloaded=m_texture_h_packed_to
			//SavePNG("$dynamic.png",[(int(a)*0x010101)|0xff000000 foreach a in m_texture_data],m_texture_width,m_texture_height)
		glDisable(GL_DEPTH_TEST)
		glEnable(GL_BLEND)
		if !IS_OPENGL_ES&&m_srgb_supported&&m_srgb_supported!=2:
			glGetError()
			glEnable(GL_FRAMEBUFFER_SRGB_EXT)
			err=glGetError()
			if err!=GL_NO_ERROR:
				m_srgb_supported=0
		//glEnable(GL_TEXTURE_2D)
		glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)
		//debugDumpVBO()
		foreach dc in m_drawcalls
			if dc.hwnd==hwnd_onlydraw||!hwnd_onlydraw:
				if dc.js_callback:
					dc.js_callback.Call(JSObject)
					continue
				if dc.native_callback:
					dc.native_callback()
					continue
				if !m_tech.m_prg:
					m_tech.SetVarying("vec2 uv;vec4 C;")
					m_tech.SetVertexShader("
					void main(){
						vec2 P_scr=P*scale.xy;
						uv=uv_vert*scale.zw;
						"+(m_srgb_supported?"C=vec4(pow(C_vert.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_vert.w);":"C=C_vert;")+"
						gl_Position=vec4(P_scr.x+trans.x,P_scr.y+trans.y,1.0,1.0);
					}")
					//if m_srgb_supported&&!m_tex_is_srgb:
					//	m_tech.SetFragmentShader("void main(){vec4 C_tex=texture2D(tex0,uv);gl_FragColor=vec4(pow(C_tex.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_tex.w)*C;}")
					//else
					m_tech.SetFragmentShader("void main(){gl_FragColor=vec4(1.0,1.0,1.0,texture2D(tex0,uv).w)*C;}")
				//pslice=m_vbo[dc.pv:]
				m_tech.SetVertexPointer("P", 2,GL_UNSIGNED_SHORT,0, VERTEX_SIZE*sizeof(int),dc.pv*sizeof(int))
				m_tech.SetVertexPointer("uv_vert", 2,GL_UNSIGNED_SHORT,0, VERTEX_SIZE*sizeof(int),(dc.pv+1)*sizeof(int))
				m_tech.SetVertexPointer("C_vert", 4,GL_UNSIGNED_BYTE,1, VERTEX_SIZE*sizeof(int),(dc.pv+2)*sizeof(int))
				scale_scr=float2(scale.x*2.f/f32(dc.window_w),-scale.y*2.f/f32(dc.window_h))
				m_tech.SetUniform("scale",float4(scale_scr.x/f32(dc.crd16_scale),scale_scr.y/f32(dc.crd16_scale), 1.f/f32(m_texture_width*m_uv16_scale),1.f/f32(m_texture_height*m_uv16_scale)))
				m_tech.SetUniform("trans",float2(-1.f,1.f)+translation*scale_scr)
				m_tech.SetTexture2D("tex0", m_texid)
				m_tech.Draw(m_gl_vbo,GL_TRIANGLES,dc.nv)
		if m_srgb_supported==2:
			//manual sRGB
			glBindFramebuffer(GL_FRAMEBUFFER,bk_fbo[0])
			glViewport(wnd_viewport[0],wnd_viewport[1],wnd_viewport[2],wnd_viewport[3])
			glDisable(GL_BLEND);
			tech=m_manual_srgb_tech
			if !tech:
				tech=new GLTechnique
				tech.SetFragmentShader("void main(){
					vec4 C=texture2D(tex0,st*scale,0.0);
					gl_FragColor=vec4(pow(C.xyz,vec3("+formatNumber(1.f/m_gamma,{frac:7})+")),C.w);
				}")
				m_manual_srgb_tech=tech
			tech.SetUniform("scale",float2(float(wnd_w)/float(m_srgb_fbo.w),float(wnd_h)/float(m_srgb_fbo.h)))
			tech.SetTexture2D("tex0",m_srgb_fbo.m_tex)
			tech.DrawScreenQuad()
	auto UploadMiniVBO(int[] mini_vbo)
		if !m_gl_vbo_tiny:
			buf_ret=[0u]
			glGenBuffers(1,__pointer(buf_ret.d))
			m_gl_vbo_tiny=buf_ret[0]
			glBindBuffer(GL_ARRAY_BUFFER,m_gl_vbo_tiny)
			glBufferData(GL_ARRAY_BUFFER,65536,NULL,GL_DYNAMIC_DRAW)
			//glBindBuffer(GL_ARRAY_BUFFER,0u)
			buf_ret.discard()
		if mini_vbo.n*sizeof(int)>65536:
			assert(mini_vbo.n*sizeof(int)<=65536)
			return 0u
		glBindBuffer(GL_ARRAY_BUFFER,m_gl_vbo_tiny)
		glBufferSubData(GL_ARRAY_BUFFER,0L,mini_vbo.n*sizeof(int),__pointer(mini_vbo.d))
		return m_gl_vbo_tiny
	auto DrawCaret(float x,float y,float w,float h,int C)
		m_caret_tech.SetVarying("vec4 C;")
		m_caret_tech.SetVertexShader("
		void main(){
			vec2 P_scr=P*scale;
			"+(m_srgb_supported?"C=vec4(pow(C_vert.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_vert.w);":"C=C_vert;")+"
			gl_Position=vec4(P_scr.x-1.0,1.0-P_scr.y,1.0,1.0);
		}")
		vbo=UploadMiniVBO([
			__float_as_int(x),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y+h),
			__float_as_int(x),__float_as_int(y+h),
			C,C,C,C])
		m_caret_tech.SetFragmentShader("void main(){gl_FragColor=C;}")
		m_caret_tech.SetVertexPointer("P", 2,GL_FLOAT,0, 2*sizeof(int),0L)
		m_caret_tech.SetVertexPointer("C_vert", 4,GL_UNSIGNED_BYTE,1, sizeof(int),0L+8*sizeof(float))
		prev_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
		m_caret_tech.SetUniform("scale",float2(2.f/f32(prev_viewport[2]),2.f/f32(prev_viewport[3])))
		m_caret_tech.Draw(vbo,GL_TRIANGLE_FAN,4)
		//only draw caret for the last drawcall
	//////////////
	//avoid caching the resampled / original bitmaps - batched loadStaticResources
	auto BeginPaint(__pointer hwnd,float w,float h)
		//if m_static_textures:
		//	PackStaticBitmaps()
		m_uv16_scale=32768/m_texture_width
		m_hwnd=hwnd
		m_clip=float4(0.f,0.f,w,h)
		m_clip_stack.clear()
		m_crd16_scale=max(65536/promoteToTextureSize(int(ceil(max(w,h)))+1),1)
		m_drawcall_start=int(m_StretchDIBits_calls.n)
		m_window_w=w
		m_window_h=h
	auto FlushDrawcall()
		//create a drawcall
		if m_window_w&&m_window_h&&m_drawcall_start<int(m_StretchDIBits_calls.n):
			m_drawcalls.push(TDrawCall(){
				hwnd:m_hwnd,
				pv:m_drawcall_start*(VERTEX_SIZE*6),
				nv:(int(m_StretchDIBits_calls.n)-m_drawcall_start)*6,
				crd16_scale:m_crd16_scale,
				window_w:m_window_w,
				window_h:m_window_h})
		m_drawcall_start=int(m_StretchDIBits_calls.n)
	auto EndPaint()
		FlushDrawcall()
		//and to allow caret / progress overlay - videos
		//refer to the same vbo using different drawcalls
		m_hwnd=NULL
		m_clip=float4()
		m_clip_stack.clear()
	auto InsertJSDrawCall(JSObject js_callback)
		FlushDrawcall()
		m_drawcalls.push(TDrawCall(){hwnd:m_hwnd,js_callback:js_callback})
	auto InsertNativeDrawCall(function() native_callback)
		FlushDrawcall()
		m_drawcalls.push(TDrawCall(){hwnd:m_hwnd,native_callback:native_callback})
	auto SwitchToSubWindow(int x0,int y0,int w0,int h0,int is_relative,int is_pop)
		ww=0
		hw=0
		SDL.detail.SDL_GL_GetDrawableSize(m_hwnd,&ww,&hw)
		x=x0
		y=y0
		w=w0
		h=h0
		//if w<=0:
		//	x=0
		//	w=ww
		//if h<=0:
		//	y=0
		//	h=hw
		InsertNativeDrawCall(function(){
			//if Platform.ARCH=="linux32"||Platform.ARCH=="linux64":
			//	glFinish()
			if is_relative:
				prev_viewport=new int[4]
				glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
				glViewport(prev_viewport[0]+x,prev_viewport[1]+prev_viewport[3]-y-h,w,h)
			else
				glViewport(x,hw-y-h,w,h)
		})
		if is_pop:
			m_clip=m_clip_stack.pop()
		else
			m_clip_stack.push(m_clip)
			m_clip=float4(0.f,0.f,float(w),float(h))
		//m_clip_stack.clear()
		m_crd16_scale=max(65536/promoteToTextureSize(max(w,h)+1),1)
		m_drawcall_start=int(m_StretchDIBits_calls.n)
		m_window_w=f32(w)
		m_window_h=f32(h)
	inline PushCliprect(float x,float y,float w,float h)
		m_clip_stack.push(m_clip)
		m_clip=float4(max(m_clip.x,x),max(m_clip.y,y),min(m_clip.z,x+w),min(m_clip.w,y+h))
	inline PopCliprect()
		m_clip=m_clip_stack.pop()
	auto DrawBitmap(int hbmp, float x0,float y0,float w0,float h0, int C)
		u0=0.f
		v0=0.f
		cu=1.f
		cv=1.f
		clipped=0
		x=x0;y=y0;w=w0;h=h0
		if x<m_clip.x:
			dx=m_clip.x-x
			t=dx/w
			x=m_clip.x;w-=dx
			du=cu*t
			u0+=du;cu-=du
			clipped=1
		if m_clip.z<x+w:
			dx=m_clip.z-x
			t=dx/w
			w=dx
			cu*=t
			clipped=1
		//use negated tests against NaN
		if !(cu>0.f)||!(x+w>x):return
		if y<m_clip.y:
			dy=m_clip.y-y
			t=dy/h
			y=m_clip.y;h-=dy
			dv=cv*t
			v0+=dv;cv-=dv
			clipped=1
		if m_clip.w<y+h:
			dy=m_clip.w-y
			t=dy/h
			h=dy
			cv*=t
			clipped=1
		if !(cv>0.f)||!(y+h>y):return
		inline f2i_P(float f)
			//return max(min(int(f*float(m_crd16_scale)),65535),0)
			return max(min(__float_as_int(f*float(m_crd16_scale)+8388608.f)-0x4b000000,65535),0)
		inline f2i_uv(float f)
			return max(min(__float_as_int(f*32768.f+8388608.f)-0x4b000000,65535),0)
		//assert(x>=m_clip.x&&x<=m_clip.z)
		//assert(x+w>=m_clip.x&&x+w<=m_clip.z)
		//assert(y>=m_clip.y&&y<=m_clip.w)
		//assert(y+h>=m_clip.y&&y+h<=m_clip.w)
		ix0=f2i_P(x)
		iy0=f2i_P(y)
		ix1=f2i_P(x+w)
		iy1=f2i_P(y+h)
		vdata=int4(((iy0)<<16)+(ix0),((iy1)<<16)+(ix1),0,0x80008000)
		if clipped:
			iu0=f2i_uv(u0)
			iv0=f2i_uv(v0)
			iu1=f2i_uv(u0+cu)
			iv1=f2i_uv(v0+cv)
			vdata.z=((iv0)<<16)+(iu0)
			vdata.w=((iv1)<<16)+(iu1)
		//if is_static:
		//	n0=m_vbo.n
		//	m_vbo.resize(n0+VERTEX_SIZE*4)
		//	m_vbo[n0+(VERTEX_SIZE*0+0)]=((iy0)<<16)+(ix0)
		//	m_vbo[n0+(VERTEX_SIZE*0+1)]=((iv0)<<16)+(iu0)
		//	m_vbo[n0+(VERTEX_SIZE*0+2)]=C
		//	m_vbo[n0+(VERTEX_SIZE*1+0)]=((iy0)<<16)+(ix1)
		//	m_vbo[n0+(VERTEX_SIZE*1+1)]=((iv0)<<16)+(iu1)
		//	m_vbo[n0+(VERTEX_SIZE*1+2)]=C
		//	m_vbo[n0+(VERTEX_SIZE*2+0)]=((iy1)<<16)+(ix1)
		//	m_vbo[n0+(VERTEX_SIZE*2+1)]=((iv1)<<16)+(iu1)
		//	m_vbo[n0+(VERTEX_SIZE*2+2)]=C
		//	m_vbo[n0+(VERTEX_SIZE*3+0)]=((iy1)<<16)+(ix0)
		//	m_vbo[n0+(VERTEX_SIZE*3+1)]=((iv1)<<16)+(iu0)
		//	m_vbo[n0+(VERTEX_SIZE*3+2)]=C
		//else
		m_StretchDIBits_calls.push(TStretchDIBits(){vdata:vdata,hwnd:m_hwnd,bmpid:hbmp,C:int4(C,C,C,C)})
		//Writeln(x,' ',y,' ',w,' ',h,' ',m_vbo.n)
	inline DrawRectangle(float x0,float y0,float w0,float h0, int C)
		DrawBitmap(0,x0,y0,w0,h0,C)
	//////////////
	m_glyph_cache=new CGlyphCacheItem[int3]
	m_glyph_cache_invalidated=0
	m_has_new_glyph_cache_entry=0
	m_font_paths=string[].NULL
	m_std_fallback_fonts=new string[]
	m_font_unique_id=0
	auto CreateCoreFontFromData(string sdata)
		hfnt=FTW_LoadFont(sdata,sdata.n)
		if hfnt:
			return CCoreFont(){hfnt:hfnt,sdata:sdata,id:m_font_unique_id++,y_baseline_per_height:FTW_GetAscent(hfnt,1)}
		else
			return CCoreFont.NULL
	auto InitFonts()
		if !m_font_paths:
			m_font_paths=new string[]
			if Platform.ARCH==('android'):
				//android font path
				m_font_paths.push(('/system/fonts/'))
				m_std_fallback_fonts.push(('DroidSansFallback'))
			else if Platform.ARCH==('ios'):
				//there is no longer a default font on iOS, you must provide one
				m_std_fallback_fonts.push('res/fonts/opensans.ttf')
				//m_font_paths.push(('/System/Library/Fonts/'))
				//m_font_paths.push(('/System/Library/Fonts/Cache/'))
				//foreach spath in m_font_paths
				//	Writeln('*** searching for iOS fonts at '+spath)
				//	foreach fnfont in System.IO.EnumFiles(spath+"*",System.IO.ENUM_FILE)
				//		Writeln(fnfont)
				//Writeln('*** listing iOS files')
				//foreach fnfont in System.IO.EnumFiles("/*",System.IO.ENUM_FILE|System.IO.ENUM_RECURSIVE)
				//	Writeln(fnfont)
				//m_std_fallback_fonts.push(('Helvetica'))
				//m_std_fallback_fonts.push(('STHeiti-Medium'))
				//m_std_fallback_fonts.push(('LastResort'))
			else if Platform.ARCH==('mac'):
				m_font_paths.push(('/Library/Fonts/'))
				m_font_paths.push(('/System/Library/Fonts/'))
				m_font_paths.push(('/System/Library/Fonts/Cache/'))
				m_std_fallback_fonts.push(('Helvetica'))
				m_std_fallback_fonts.push(('STHeiti Medium'))
				m_std_fallback_fonts.push(('LastResort'))
			else if Platform.IS_UNIX:
				//linux doesn't have standard fonts
				m_font_paths.push(('/usr/share/fonts/truetype/droid/'))
				m_std_fallback_fonts.push(('DroidSansFallbackFull'))
			else
				m_font_paths.push(System.Env.ExpandEnvironmentStrings(("%windir%\\fonts\\")))
				found_arialuni=0
				foreach spath in m_font_paths
					foreach fnfont in System.IO.EnumFiles(spath+"ArialUni.*",System.IO.ENUM_FILE)
						found_arialuni=1
						break
					if found_arialuni:break
				if found_arialuni:
					m_std_fallback_fonts.push(('ArialUni'))
				else
					m_std_fallback_fonts.push(('Arial'))
	auto CreateCoreFontByName(CUISandbox sbox,string sname)
		//JS: core font caching, file font embedding
		//and fallbacks... depend on caching - just put m_std_fallback_fonts into JS as an array
		sdata=sbox.UIReadAll(sname)
		if sdata:
			ret=CreateCoreFontFromData(sdata)
			if ret:return ret
		foreach spath in m_font_paths
			//Writeln(spath,' ',sname)
			foreach fnfont in System.IO.EnumFiles(spath+(sname.IndexOf('.')>=0?sname:sname+".*"),System.IO.ENUM_FILE)
				//Writeln('>>> ',fnfont)
				sdata=System.IO.ReadAll(fnfont)
				if sdata:
					//Writeln('font found: ',fnfont)
					ret=CreateCoreFontFromData(sdata)
					if ret:return ret
		//Writeln('font not found: ',sname)
		return CCoreFont.NULL
	//auto CreateCoreFontChain(CCoreFont[] fonts)
	//	if fonts.n==1:return fonts[0]
	//	ret=CCoreFont(){fallbacks:fonts}
	//	y_baseline_per_height=0.f
	//	foreach pfnt_i in ret.fallbacks
	//		if y_baseline_per_height<pfnt_i.y_baseline_per_height:
	//			y_baseline_per_height=pfnt_i.y_baseline_per_height
	//	ret.y_baseline_per_height=y_baseline_per_height
	//	return ret
	m_filter3=float[].NULL
	m_filter5=float[].NULL
	auto CacheGlyph(TFont fnt, int ch)
		ret=CGlyphCacheItem.NULL
		draw_dxdy=float2(0.f,0.f)
		dx=0.f
		pchain=fnt.pfnt
		ci=pchain.QueryCodePoint(ch)
		if ci.fntid<0:
			//there is no glyph, return NULL
		else
			cfnt=pchain.fonts[ci.fntid-1]
			hfnt=cfnt.hfnt
			draw_dxdy=float2(cfnt.draw_dx,cfnt.draw_dy)*fnt.h
			//ci.dx already has cfnt.scale counted in
			dx=ci.dx*fnt.h
			key=int3(hfnt.id*1024+max(min(fnt.embolden+512,1023),0),__float_as_int(fnt.h*cfnt.scale),ch)
			ret=m_glyph_cache[key]
			if !ret:
				m_has_new_glyph_cache_entry=1
				dims=new float[6]
				x_aa=3
				y_aa=3
				if fnt.h<16.f:
					x_aa=5
					y_aa=5
				if !m_filter3:
					m_filter3=lanczos_filter(3,2,m_font_sharpening)
					m_filter5=lanczos_filter(5,2,m_font_sharpening)
				assert(x_aa==3||x_aa==5)
				assert(y_aa==3||y_aa==5)
				x_filter=(x_aa==3?m_filter3:m_filter5)
				y_filter=(y_aa==3?m_filter3:m_filter5)
				x_htaps=int(x_filter.n>>1)
				y_htaps=int(y_filter.n>>1)
				embolden=float(max(min(fnt.embolden,511),-512))*fnt.h*cfnt.scale
				pbitmap=FTW_GetCharacterEx(hfnt.hfnt,fnt.h*cfnt.scale,x_aa,y_aa, x_filter,y_filter,x_htaps,y_htaps, embolden, ch,dims)
				w=int(dims[2])
				h=int(dims[3])
				buf=new u8[(w+2)*(h+2)]
				for i=0:h-1
					lbase=(i+1)*(w+2)+1
					lbase_src=i*w
					for j=0:w-1
						buf[lbase+j]=__memory(u8,iptr(pbitmap)+lbase_src+j)
				ret=new CGlyphCacheItem
				if w&&h:
					ret.tex_id=CreatePackedTexture(buf,w+2,h+2)
				ret.x_draw=dims[0]
				ret.y_draw=dims[1]
				ret.w_draw=dims[4]
				ret.h_draw=float(h)
				m_glyph_cache[key]=ret
		return (ret,draw_dxdy,dx)
	auto DrawChar(TFont fnt, float x,float y,int C, int ch)
		(gcitem,draw_dxdy,dx)=CacheGlyph(fnt,ch)
		if gcitem&&gcitem.tex_id:
			y_final=y+gcitem.y_draw+draw_dxdy.y
			if m_text_y_snap:y_final=floor(y_final+0.5f)
			DrawBitmap(gcitem.tex_id, x+gcitem.x_draw+draw_dxdy.x,y_final,gcitem.w_draw,gcitem.h_draw, C)
		return dx
	////////////////
	TFont m_fast_glyph_cache_font
	//CGlyphCacheItem[int] m_fast_glyph_cache
	//CGlyphCacheItem[] m_fast_glyph_cache_ascii
	auto SetFastDrawCharFont(TFont fnt)
		//if m_fast_glyph_cache_font.h!=fnt.h||m_fast_glyph_cache_font.embolden!=fnt.embolden||iptr(m_fast_glyph_cache_font.pfnt)!=iptr(fnt.pfnt):
		//	m_fast_glyph_cache=new CGlyphCacheItem[int]
		//	m_fast_glyph_cache_ascii=new CGlyphCacheItem[128]
		m_fast_glyph_cache_font=fnt
	inline FastDrawChar(float x,float y,int C, int ch)
		return DrawChar(m_fast_glyph_cache_font,x,y,C,ch)
		/*if u32(ch)<128u:
			ret=m_fast_glyph_cache_ascii[ch]
		else
			ret=m_fast_glyph_cache[ch]
		if !ret:
			(gcitem,delta_y)=CacheGlyph(m_fast_glyph_cache_font,ch)
			ret.y_final=1.f
			if gcitem:
				if !gcitem.tex_id:
					gcitem=CGlyphCacheItem.NULL
				else
					ret.y_final=gcitem.y_draw+delta_y
			ret.gcitem=gcitem
			if u32(ch)<128u:
				m_fast_glyph_cache_ascii[ch]=ret
			else
				m_fast_glyph_cache[ch]=ret
		///////////
		gcitem=ret.gcitem
		if gcitem:
			y_final=y+ret.y_final
			if m_text_y_snap:y_final=floor(y_final+0.5f)
			DrawBitmap(gcitem.tex_id, x+gcitem.x_draw,y_final,gcitem.w_draw,gcitem.h_draw, C)
			dx=gcitem.dx
		else
			//we don't know what it looks like, don't draw
			dx=0.f
		//Writeln(x,' ',y,' ',char(ch))
		return dx*/
	////////////////
	EDT_END_ELLIPSIS=1
	EDT_EXPANDTABS=2
	EDT_WORDBREAK=4
	EDT_PREFIX_TO_UNDERLINE=8
	inline GetCharacterHeight(TFont fnt)
		return fnt.h
	inline GetFontBaseline(TFont fnt)
		return fnt.pfnt.y_baseline_per_height*fnt.h
	auto GetCharacterAdvance(TFont fnt,int ch)
		ci=fnt.pfnt.QueryCodePoint(ch)
		return ci.dx*fnt.h
	auto GetKerning(TFont fnt,int ch0,int ch1)
		ci=fnt.pfnt.QueryCodePoint(ch1)
		if ci.fntid>0:
			cfnt=fnt.pfnt.fonts[ci.fntid-1]
			return FTW_GetKerning(cfnt.hfnt.hfnt,fnt.h*cfnt.scale,ch0,ch1)
		else
			return 0.f
	auto ComputeTextLayout(TFont fnt, float w0,float h0,string s, int flags)
		//simply emulate windows drawtext
		s32=Utf8ToUnicode32(s)
		wspace=GetCharacterAdvance(fnt,int(' '))
		wtab=wspace*8.f
		hc=GetCharacterHeight(fnt)
		y_baseline=GetFontBaseline(fnt)
		y_underline=y_baseline*1.05f
		h_underline=y_baseline*0.05f
		poses=new float2[s32.n]
		x=0.f;y=0.f
		xmax=0.f
		ndrawn=s32.n
		is_underlining=0
		if flags&EDT_PREFIX_TO_UNDERLINE:
			underlines=new float4[]
		for ch,I in s32
			ch=s32[I]
			if ch=='\r':continue
			if flags&EDT_PREFIX_TO_UNDERLINE:
				if ch=='&'&&!is_underlining:
					is_underlining=1
					s32[I]=32
					continue
			if ch=='\t':
				if flags&EDT_EXPANDTABS:
					dx=min((floor(x/wtab)+1.f)*wtab,w0)-x
				else
					dx=wspace
			else if ch=='\n':
				dx=0.f
				delta_y=0.f
			else
				dx=GetCharacterAdvance(fnt,ch)
			if x&&(x>=w0||x+dx>w0)||ch=='\n':
				xbak=x
				ybak=y
				if (flags&EDT_WORDBREAK)&&IsAlnumUnicode(ch)&&!(y+hc*2>h0):
					//don't word-wrap on the last line
					pw=I-1
					for(;pw>0;pw--)
						if poses[pw].y!=y:break
						if !IsAlnumUnicode(s32[pw]):break
					pw++
					if pw<I&&!poses[pw].x:pw=I
					if pw==I:
						wx0=x
					else
						wx0=poses[pw].x
					for j=pw:I-1
						poses[j].x-=wx0
						poses[j].y=y+hc
					x-=wx0
					if y+hc*2.f>h0:
						ndrawn=pw
						x=wx0
						break
				else
					x=0.f
				y+=hc
				if y+hc>h0:
					ndrawn=I
					x=xbak
					y=ybak
					break
				if ch=='\t':
					if flags&EDT_EXPANDTABS:
						dx=min((floor(x/wtab)+1.f)*wtab,w0)-x
				xmax=w0
			if is_underlining:
				underlines.push(float4(x,y+y_underline,dx,h_underline))
				is_underlining=0
			poses[I]=float2(x,y)
			x+=dx
			xmax=max(xmax,x)
		if ndrawn<s32.n&&(flags&EDT_END_ELLIPSIS):
			U_ELLIPSIS=0x2026
			if fnt.pfnt.QueryCodePoint(U_ELLIPSIS).fntid>0:
				w_remove=GetCharacterAdvance(fnt,U_ELLIPSIS)
				s_elli=[U_ELLIPSIS]
			else
				w_remove=GetCharacterAdvance(fnt,int('.'))*3.f
				s_elli=[int('.'),int('.'),int('.')]
			while ndrawn&&poses[ndrawn-1].x+w_remove>w0&&poses[ndrawn-1].y+hc*2>h0:
				ndrawn--
				x=poses[ndrawn].x
			poses_elli=new float2[s_elli.n]
			foreach ch,I in s_elli
				poses_elli[I]=float2(x,y)
				x+=GetCharacterAdvance(fnt,ch)
		else
			poses_elli=float2[].NULL
		ret=new TPositionedText[]
		for i=0:ndrawn-1
			ch=s32[i]
			if ch!=' '&&ch!='\t'&&ch!='\r'&&ch!='\n':
				ret.push(TPositionedText(){pos:poses[i],ch:ch})
		//Writeln(__memory(int,__cast(iptr,poses)))
		if poses_elli:
			foreach ch,I in s_elli
				ret.push(TPositionedText(){pos:poses_elli[I],ch:ch})
		//return (ret,float2(min(xmax,w0),min(y+(x?hc:0.f),h0)))
		return new CTextLayout(){chars:ret,underlines:underlines,dims:float2(min(xmax,w0),min(y+(x?hc:0.f),h0))}
	////////////////
	auto LoadImage(string data)
		w=0
		h=0
		comp=0
		surf=stbi_load_from_memory(__pointer(data.d),int(data.n),&w,&h,&comp,4)
		if surf:
			ret=new int[]
			if Platform.BUILD=="debug"&&LeakDetection.isEnabled():
				ret.resize(w*h)
				__basic_api.memcpy(__pointer(ret.d),surf,w*h*sizeof(int))
				LeakDetection.realFree(surf)
			else
				ret.d=iptr(surf)
				ret.n=iptr(w*h)
				ret.sz=ret.n
		else
			ret=int[].NULL
		return (ret,w,h)
	////////////////
	auto CacheRR(float radius0,float arg,const is_border)
		radius=radius0
		if radius<=0.f:return 0
		if is_border==2:
			//shadow
			border_width=0.f
			filter_width=min(arg,radius*0.5f)
			key=int3(0x80000000,__float_as_int(-filter_width),__float_as_int(radius))
		else
			border_width=arg
			filter_width=0.f
			key=int3(0x80000000,is_border==1?__float_as_int(border_width):0xffffffff,__float_as_int(radius))
		ret=m_glyph_cache[key]
		if !ret:
			//ret=m_glyph_cache_prev[key]
			m_has_new_glyph_cache_entry=1
			rif=System.Math.ceil(radius)
			ri=int(rif)
			scale=rif/radius
			radius-=filter_width
			r2=System.Math.sqr(16.f*radius*scale)
			if is_border==1:
				rb2=System.Math.sqr(16.f*(radius-border_width)*scale)
			buf=new u8[(ri+2)*(ri+2)]
			p=0
			for y=-1:ri
				for x=-1:ri
					a=0.f
					for aa_y=0:15
						y2=System.Math.sqr(float(max(y*16+aa_y,0)))
						x2_max=r2-y2
						if !(x2_max>0.f):continue
						x_max=System.Math.sqrt(x2_max)
						if is_border==1:
							x2_max_border=rb2-y2
							if x2_max_border>=0.f:
								x_max_border=System.Math.sqrt(x2_max_border)
							else
								x_max_border=-9999.f
							a+=max(min(x_max,float((x+1)*16))-max(x_max_border,float(x*16)),0.f)
						else
							a+=max(min(x_max-float(x*16),16.f),0.f)
					a*=255.f/256.f
					buf[p++]=min(max(int(a),0),255)
			if is_border==2:
				//filter
				fwi=int(System.Math.ceil(filter_width))
				fw2=System.Math.sqr(16.f*filter_width)
				flg=fwi*2+1
				fbuf=new float[flg*flg]
				for fy=0:fwi
					for fx=0:fwi
						a=0.f
						for aa_y=0:15
							y2=System.Math.sqr(float(max(fy*16+aa_y,0)))
							x2_max=fw2-y2
							if !(x2_max>0.f):continue
							x_max=System.Math.sqrt(x2_max)
							a+=max(min(x_max-float(fx*16),16.f),0.f)
						a*=(1.f/256.f)
						fbuf[flg*(-fy+fwi)+(-fx+fwi)]=a
						fbuf[flg*(-fy+fwi)+(fx+fwi)]=a
						fbuf[flg*(fy+fwi)+(-fx+fwi)]=a
						fbuf[flg*(fy+fwi)+(fx+fwi)]=a
				nmlz=1.f/[d foreach d in fbuf].Sum()
				foreach d,I in fbuf
					fbuf[I]*=nmlz
				sz=ri+2
				buf2=new u8[sz*sz]
				for y=0:sz-1
					for x=0:sz-1
						acc=0.f
						pf=0
						for fy=-fwi:fwi
							addr=min(max(y+fy,0),sz-1)*sz
							for fx=-fwi:fwi
								C=buf[addr+min(max(x+fx,0),sz-1)]
								wt=fbuf[pf]
								acc+=float(C)*wt
								pf++
						buf2[y*sz+x]=max(min(int(acc),255),0)
				buf=buf2
			ret=new CGlyphCacheItem
			ret.tex_id=CreatePackedTexture(buf,ri+2,ri+2)
			m_glyph_cache[key]=ret
		return ret.tex_id
	auto Draw3x3(float x00,float y00,float w,float h,float radius, int bmpid,T3x3ColorDesc color,int is_border)
		//the bmp is dynamic
		//we need 16 points
		struct T3x3Point
			float x,y
			float u,v
			int C
		points=new T3x3Point[16]
		xs=float4(0.f,radius,w-radius,w)+float4(x00,x00,x00,x00)
		ys=float4(0.f,radius,h-radius,h)+float4(y00,y00,y00,y00)
		ri=System.Math.ceil(radius)
		us=float4(1.f,0.f,0.f,1.f)
		vs=float4(1.f,0.f,0.f,1.f)
		for y in crange(4)
			for x in crange(4)
				points[y*4+x].x=xs[x]
				points[y*4+x].y=ys[y]
				points[y*4+x].u=us[x]
				points[y*4+x].v=vs[y]
		if color.is_gradient:
			inline lerp(a,b,t){return a+(b-a)*t}
			//gradient - compute C at the points
			p0=color.p0
			p1=color.p1
			C0=color.C0
			C1=color.C1
			dt=p1-p0
			//Writeln(p0,' ',p1,' ',formatNumber(C0,{align:8,base:16}),' ',formatNumber(C1,{align:8,base:16}))
			dt=dt/(float2(w,h)*sqr(dt))
			p0=p0*float2(w,h)+float2(x00,y00)
			gamma=m_gamma
			inv_gamma=1.f/m_gamma
			for i=0:15
				t=dot(float2(points[i].x,points[i].y)-p0,dt)
				C_i=0
				for j in crange(4)
					f0=float((C0>>(j*8))&0xff)*(1.f/255.f)
					f1=float((C1>>(j*8))&0xff)*(1.f/255.f)
					if gamma!=1.f&&j!=3:
						f0=pow(f0,gamma)
						f1=pow(f1,gamma)
						f=min(max(lerp(f0,f1,t),0.f),1.f)
						f=pow(f,inv_gamma)
					else
						f=lerp(f0,f1,t)
					C_i+=max(min(int(f*255.f),255),0)<<(j*8)
				points[i].C=C_i
		else
			//solid color
			C=color.C0
			for i=0:15
				points[i].C=C
		//draw the quads
		inline f2i_P(float f)
			return max(min(int(f*float(m_crd16_scale)),65535),0)
		inline f2i_uv(float f)
			return max(min(int(f*32768.f),65535),0)
		for y=0:2
			for x=0:2
				if is_border&&x==1&&y==1:continue
				x0=points[y*4+x].x
				y0=points[y*4+x].y
				x1=points[(y+1)*4+(x+1)].x
				y1=points[(y+1)*4+(x+1)].y
				u0=points[y*4+x].u
				v0=points[y*4+x].v
				u1=points[(y+1)*4+(x+1)].u
				v1=points[(y+1)*4+(x+1)].v
				C0=points[y*4+x].C
				C1=points[y*4+(x+1)].C
				C2=points[(y+1)*4+(x+1)].C
				C3=points[(y+1)*4+x].C
				//else if x==1:
				//	bmpid_xy=bmpid//+2
				//else if y==1:
				//	bmpid_xy=bmpid//+1
				if y==1&&x==1:
					bmpid_xy=0
				else
					bmpid_xy=bmpid
				//clipping
				if x0<m_clip.x:
					dx=m_clip.x-x0
					t=dx/(x1-x0)
					x0=m_clip.x
					du=(u1-u0)*t
					u0+=du
				if m_clip.z<x1:
					dx=m_clip.z-x1
					t=dx/(x1-x0)
					x1=m_clip.z
					du=(u1-u0)*t
					u1+=du
				if !(x1>x0):continue
				if y0<m_clip.y:
					dy=m_clip.y-y0
					t=dy/(y1-y0)
					y0=m_clip.y
					dv=(v1-v0)*t
					v0+=dv
				if m_clip.w<y1:
					dy=m_clip.w-y1
					t=dy/(y1-y0)
					y1=m_clip.w
					dv=(v1-v0)*t
					v1+=dv
				if !(y1>y0):continue
				ix0=f2i_P(x0)
				iy0=f2i_P(y0)
				iu0=f2i_uv(u0)
				iv0=f2i_uv(v0)
				ix1=f2i_P(x1)
				iy1=f2i_P(y1)
				iu1=f2i_uv(u1)
				iv1=f2i_uv(v1)
				//if bmpid_xy==-1:
				//	//all 0.f anyway, should work as is
				//	m_vbo[n0+(VERTEX_SIZE*0+0)]=((iy0)<<16)+(ix0)
				//	m_vbo[n0+(VERTEX_SIZE*0+1)]=((iv0)<<16)+(iu0)
				//	m_vbo[n0+(VERTEX_SIZE*0+2)]=C0
				//	m_vbo[n0+(VERTEX_SIZE*1+0)]=((iy0)<<16)+(ix1)
				//	m_vbo[n0+(VERTEX_SIZE*1+1)]=((iv0)<<16)+(iu1)
				//	m_vbo[n0+(VERTEX_SIZE*1+2)]=C1
				//	m_vbo[n0+(VERTEX_SIZE*2+0)]=((iy1)<<16)+(ix1)
				//	m_vbo[n0+(VERTEX_SIZE*2+1)]=((iv1)<<16)+(iu1)
				//	m_vbo[n0+(VERTEX_SIZE*2+2)]=C2
				//	m_vbo[n0+(VERTEX_SIZE*3+0)]=((iy1)<<16)+(ix0)
				//	m_vbo[n0+(VERTEX_SIZE*3+1)]=((iv1)<<16)+(iu0)
				//	m_vbo[n0+(VERTEX_SIZE*3+2)]=C3
				//else
				vdata=int4(((iy0)<<16)+(ix0),((iy1)<<16)+(ix1),((iv0)<<16)+(iu0),((iv1)<<16)+(iu1))
				m_StretchDIBits_calls.push(TStretchDIBits(){vdata:vdata,hwnd:m_hwnd,bmpid:bmpid_xy,C:int4(C0,C1,C2,C3)})
	auto DrawRR(TRRContext ctx,float x,float y,float w,float h)
		assert(ctx.is_valid)
		Draw3x3(x,y,w,h,ctx.eff_radius, ctx.bmpid,ctx.color,0)
		if ctx.border_width>0.f:
			Draw3x3(x-ctx.border_width*0.5f,y-ctx.border_width*0.5f,w+ctx.border_width,h+ctx.border_width,ctx.eff_radius, ctx.bmpid2,ctx.border_color,1)
	auto CreateRRColorDesc(JSObject obj,string sname)
		ret=T3x3ColorDesc()
		if obj[sname].has(0):
			//gradient - compute C at the points
			p0x=obj[sname][0]["x"].as(float)
			p0y=obj[sname][0]["y"].as(float)
			ret.p0=float2(p0x,p0y)
			p1x=obj[sname][1]["x"].as(float)
			p1y=obj[sname][1]["y"].as(float)
			ret.p1=float2(p1x,p1y)
			ret.C0=obj[sname][0]["color"].or(-1)
			ret.C1=obj[sname][1]["color"].or(-1)
			ret.is_gradient=i8(1)
		else
			ret.C0=obj[sname].or(-1)
		return ret
	auto CreateRRContext(JSObject obj)
		radius=obj["round"].or(0.f)*m_pixels_per_unit
		border_width=obj["border_width"].or(0.f)*m_pixels_per_unit
		w=obj["w"].or(0.f)*m_pixels_per_unit
		h=obj["h"].or(0.f)*m_pixels_per_unit
		eff_radius=max(min(radius,min(w,h)*0.5f),border_width)
		if border_width<0.f:
			//shadowed
			bmpid=CacheRR(eff_radius,-border_width,2)
		else
			bmpid=CacheRR(eff_radius,0.f,0)
		//x=obj["x"].or(0.f)*m_pixels_per_unit
		//y=obj["y"].or(0.f)*m_pixels_per_unit
		if border_width>0.f:
			bmpid2=CacheRR(eff_radius,border_width,1)
		else
			bmpid2=0
		return TRRContext(){
			is_valid:i8(1),
			bmpid:bmpid,bmpid2:bmpid2,
			border_width:border_width,eff_radius:eff_radius,
			color:CreateRRColorDesc(obj,"color"),
			border_color:CreateRRColorDesc(obj,"border_color"),
		}
g_renderer=new CRenderer

////////////////////////////////////////////
//the timer stuff
SDL_SetInterval=__c_function(int,"SDL_SetInterval","sdl_timerw.h", "c_files","sdl_timerw.c")
SDL_ClearInterval=__c_function(int,"SDL_ClearInterval","sdl_timerw.h", "c_files","sdl_timerw.c")
//TIMER_EVENT_ID=2
FUIExtension=function(JSObject JS_UI,CUISandbox sbox,int is_real)
g_ui_exts=new FUIExtension[]
inline registerUIExtension(f)
	g_ui_exts.push(f)

inline CharToUtf8(auto s,T)
	return {'forEach':inline(fbody){
		ch0=0;nnxt=0;II=T(0)
		surrogate_1st=-1;surrogate_II=II
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					ch0=(ch&0x1f)
					nnxt=1
					if ch&0x20:
						nnxt++
						if ch&0x10:
							nnxt++
							ch0&=7
				else
					ch0=(ch0<<6)+(ch&63)
					nnxt--
				if nnxt:continue
				ch=ch0
				if u32(ch-0xd800)<0x800u:
					//surrogate pair
					if (ch&0x0400):
						//2nd
						if surrogate_1st>=0:
							ch=(surrogate_1st*0x400)+(ch&0x3ff)
							surrogate_1st=-1
							II=surrogate_II
						else
							surrogate_1st=-1
					else
						if surrogate_1st<0:
							//1st
							surrogate_1st=(ch&0x3ff)
							surrogate_II=II
							continue
						else
							surrogate_1st=-1
			else
				II=I
			fbody(ch,II,I+T(1))
	}}

inline CharToUtf8Backward(auto s,T)
	return {'forEach':inline(fbody){
		ch0=0;nshift=0;II=T(0)
		surrogate_2nd=0
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					chprefix=(ch&0x1f)
					if ch&0x20:
						if ch&0x10:
							chprefix&=7
					ch=ch0+(chprefix<<nshift)
					ch0=0
					nshift=0
				else
					ch0+=(ch&63)<<nshift
					nshift+=6
					continue
				if u32(ch-0xd800)<0x800u:
					//surrogate pair
					if ch&0x0400:
						//2nd
						surrogate_2nd=(ch&0x3ff)
						continue
					else
						//1st
						ch=surrogate_2nd+(ch&0x3ff)*0x400
						surrogate_2nd=0
			else
				II=I
			fbody(ch,II)
	}}	

inline Utf8Chars(string s)
	return CharToUtf8(s,iptr)

inline Utf8CodeAt(string s,ofs)
	ret=0
	foreach ch in (CharToUtf8({'forEach':inline(fbody){
				for i=iptr(ofs):s.n-1
					fbody(s[i],i)
			}},iptr))
		ret=ch
		break
	return ret

inline Utf8Length(int ch)
	ret=1
	if ch>=128:ret++
	if ch>=2048:ret++
	if ch>=65536:ret++
	return ret

auto createUIObject(JSObject JS_UI,CUISandbox sbox,int is_real)
	if is_real:
		g_renderer.InitFonts()
	///////////////
	auto JS=JS_UI.GetContext()
	JS_UI["fallback_font_names"]=g_renderer.m_std_fallback_fonts
	//js_fonts=JS.NewArray()
	//foreach sfont,I in g_renderer.m_std_fallback_fonts
	//	js_fonts[I]=sfont
	JS_UI["is_real"]=is_real
	JS_UI["is_mobile"]=Platform.IS_MOBILE
	obj_platform=JS.New()
	s_arch=Platform.ARCH;obj_platform["ARCH"]=s_arch
	s_build=Platform.BUILD;obj_platform["BUILD"]=s_build
	JS_UI["Platform"]=obj_platform
	if is_real:
		//"privileged" functions
		JS_UI["DrawWindow"]=function(JSContext JS){
			hwnd=JS.Param(0).or(NULL)
			g_renderer.DrawWindow(JS,hwnd,float2(0.f,0.f),float2(1.f,1.f))
			return 0
		}
		JS_UI["DrawCaret"]=function(JSContext JS){
			x=JS.Param(0).or(0.f)
			y=JS.Param(1).or(0.f)
			w=JS.Param(2).or(0.f)
			h=JS.Param(3).or(0.f)
			C=JS.Param(4).or(0)
			if w>0.f&&h>0.f&&(C&0xff000000):
				g_renderer.DrawCaret(x,y,w,h,C)
			return 0
		}
		JS_UI["ResetRenderer"]=function(JSContext JS){
			g_renderer.SetScalingFactor(JS.Param(0).or(1.f))
			g_renderer.m_gamma=JS.Param(1).or(g_renderer.m_gamma)
			return 0
		}
		JS_UI["SetPixelsPerUnit"]=function(JSContext JS){
			g_renderer.m_pixels_per_unit=JS.Param(0).or(g_renderer.m_pixels_per_unit)
			return 0
		}
		JS_UI["BeginFrame"]=function(JSContext JS){
			g_renderer.BeginFrame()
			return 0
		}
		JS_UI["EndFrame"]=function(JSContext JS){
			g_renderer.EndFrame()
			JS_UI["frame_time"]=System.Time.TicksToSeconds(g_renderer.m_frame_ticks);
			return 0
		}
		JS_UI["BeginPaint"]=function(JSContext JS){
			auto hwnd=JS.Param(0).or(NULL)
			w=0
			h=0
			SDL.detail.SDL_GL_GetDrawableSize(hwnd,&w,&h)
			if !w||!h:return 0
			g_renderer.BeginPaint(hwnd,f32(w),f32(h))
			obj=JS.Param(1).as(JSObject)
			if obj:
				obj["w"]=f32(w)/g_renderer.m_pixels_per_unit
				obj["h"]=f32(h)/g_renderer.m_pixels_per_unit
				obj["w_in_pixels"]=w
				obj["h_in_pixels"]=h
			return 0
		}
		JS_UI["_SwitchToSubWindow"]=function(JSContext JS){
			xf=JS.Param(0).or(0.f)
			yf=JS.Param(1).or(0.f)
			wf=JS.Param(2).or(0.f)
			hf=JS.Param(3).or(0.f)
			x=int(floor(xf))
			y=int(floor(yf))
			w=int(ceil(xf+wf))-x
			h=int(ceil(yf+hf))-y
			is_relative=JS.Param(4).or(0)
			is_pop=JS.Param(5).or(0)
			g_renderer.SwitchToSubWindow(x,y,w,h,is_relative,is_pop)
			return 0
		}
		//can't do that: we're not in GL when calling
		/*JS_UI["_GetCurrentSubWindow"]=function(JSContext JS){
			prev_viewport=new int[4]
			glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
			ww=0
			hw=0
			SDL.detail.SDL_GL_GetDrawableSize(g_renderer.m_hwnd,&ww,&hw)
			x=prev_viewport[0]
			y=prev_viewport[1]
			w=prev_viewport[2]
			h=prev_viewport[3]
			y=hw-y-h
			ret=JS.NewArray()
			ret[0]=float(x)/g_renderer.m_pixels_per_unit
			ret[1]=float(y)/g_renderer.m_pixels_per_unit
			ret[2]=float(w)/g_renderer.m_pixels_per_unit
			ret[3]=float(h)/g_renderer.m_pixels_per_unit
			return JS.Return(ret)
		}*/
		JS_UI["InsertJSDrawCall"]=function(JSContext JS){
			auto js_callback=JS.Param(0).as(JSObject)
			if !js_callback:return 0
			g_renderer.InsertJSDrawCall(js_callback)
			return 0
		}
		JS_UI["SDL_SetWindowIcon"]=function(JSContext JS){
			hwnd=JS.Param(0).as(__pointer)
			sname=JS.Param(1).as(string)
			//if !SDL.detail.g_is_hwnd[iptr(hwnd)]:return 0
			sdata=sbox.UIReadAll(sname)
			if !sdata:return 0
			(rgba,w,h)=g_renderer.LoadImage(sdata)
			//Writeln('LoadImage ',rgba.d,' ',w,' ',h)
			if !w||!h:return 0
			surface_icon=SDL.detail.SDL_CreateRGBSurfaceFrom(rgba,w,h,32,int(w*sizeof(int)),0x0000ff,0x00ff00,0xff0000,0xff000000)
			//Writeln(hwnd,' ',surface_icon)
			SDL.detail.SDL_SetWindowIcon(hwnd,surface_icon)
			SDL.detail.SDL_FreeSurface(surface_icon)
			rgba.discard()
			return JS.Return(1)
		}
	else
		//virtualized SDL_CreateWindow and BeginPaint
		JS_UI["SDL_CreateWindow"]=function(JSContext JS){
			w=JS.Param(3).or(1024)
			h=JS.Param(4).or(768)
			return JS.Return(new CSandboxWindow(){w:w,h:h})
		}
		JS_UI["SDL_SetWindowIcon"]=function(JSContext JS){
			return 0
		}
		JS_UI["BeginPaint"]=function(JSContext JS){
			auto hwnd=JS.Param(0).as(CSandboxWindow)
			if !hwnd:return 0
			//we need to match the ultimate viewport size, thus the ceil
			w=ceil(f32(hwnd.w)*g_renderer.m_pixels_per_unit)
			h=ceil(f32(hwnd.h)*g_renderer.m_pixels_per_unit)
			g_renderer.BeginPaint(__pointer(iptr(hwnd)),w,h)
			obj=JS.Param(1).as(JSObject)
			if obj:
				obj["w"]=f32(hwnd.w)
				obj["h"]=f32(hwnd.h)
			return 0
		}
	JS_UI["EndPaint"]=function(JSContext JS){
		g_renderer.EndPaint()
		return 0
	}
	//////////////////
	//if is_real:
	//	JS_UI["DrawBitmap"]=function(JSContext JS){
	//		bmpid=JS.Param(0).or(0)
	//		w=JS.Param(3).as(float)
	//		h=JS.Param(4).as(float)
	//		if !w:w=float(g_renderer.m_static_original_sizes[bmpid].x)
	//		if !h:h=float(g_renderer.m_static_original_sizes[bmpid].y)
	//		g_renderer.DrawBitmap(bmpid,
	//			JS.Param(1).as(float)*g_renderer.m_pixels_per_unit,JS.Param(2).as(float)*g_renderer.m_pixels_per_unit,
	//			w*g_renderer.m_pixels_per_unit,h*g_renderer.m_pixels_per_unit,
	//			int(JS.Param(5).or(u32(-1))))
	//		return 0
	//	}
	//	JS_UI["GetBitmapSize"]=function(JSContext JS){
	//		bmpid=JS.Param(0).or(0)
	//		obj=JS.Param(1).as(JSObject)
	//		if obj:
	//			obj["w_bmp"]=double(g_renderer.m_static_original_sizes[bmpid].x)
	//			obj["h_bmp"]=double(g_renderer.m_static_original_sizes[bmpid].y)
	//		return 0
	//	}
	JS_UI["PushCliprect"]=function(JSContext JS){
		x=JS.Param(0).as(float)*g_renderer.m_pixels_per_unit
		y=JS.Param(1).as(float)*g_renderer.m_pixels_per_unit
		w=JS.Param(2).as(float)*g_renderer.m_pixels_per_unit
		h=JS.Param(3).as(float)*g_renderer.m_pixels_per_unit
		g_renderer.PushCliprect(x,y,w,h)
		return 0
	}
	JS_UI["PopCliprect"]=function(JSContext JS){
		g_renderer.PopCliprect()
		return 0
	}
	JS_UI["GetCliprect"]=function(JSContext JS){
		ret=JS.New()
		ret["x"]=g_renderer.m_clip.x/g_renderer.m_pixels_per_unit
		ret["y"]=g_renderer.m_clip.y/g_renderer.m_pixels_per_unit
		ret["w"]=g_renderer.m_clip.z/g_renderer.m_pixels_per_unit
		ret["h"]=g_renderer.m_clip.w/g_renderer.m_pixels_per_unit
		return JS.Return(ret)
	}
	//////////////////
	JS_UI["CreateCoreFontByName"]=function(JSContext JS){
		return JS.Return(g_renderer.CreateCoreFontByName(sbox,JS.Param(0).as(string)))
	}
	JS_UI["SetRetardedWindingOrder"]=function(JSContext JS){
		pfnt=JS.Param(0).as(CCoreFont)
		if !pfnt:return 0
		FTW_SetRetardedWindingOrder(pfnt.hfnt)
		return 0
	}
	JS_UI["CreateFontChain"]=function(JSContext JS){
		arr=JS.Param(0).as(JSObject)
		ret=new CFontChain
		ret.cache_ascii=new TChainCacheItem[128]
		ret.cache_unicode=new TChainCacheItem[int]
		ret.fonts=new TChainFont[]
		h_up=0.f
		h_down=0.f
		n=arr.length()
		for i=0:n-1
			cfnt_i=arr[i].as(JSObject)
			hfnt=cfnt_i["hfnt"].as(CCoreFont)
			if !hfnt:continue
			scale=cfnt_i["scale"].or(1.f)
			draw_dx=cfnt_i["dx"].or(0.f)
			draw_dy=cfnt_i["dy"].or(0.f)
			ret.fonts.push(TChainFont(){
				hfnt:hfnt,
				scale:scale,
				draw_dx:draw_dx,
				draw_dy:draw_dy,
			})
			h_up_i=min(max(hfnt.y_baseline_per_height-draw_dy/scale,0.f),1.f)
			h_up=max(h_up,h_up_i*scale)
			h_down=max(h_down,1.f-h_up_i*scale)
		if !ret.fonts.n:
			return 0
		else
			base_scale=h_up+h_down
			inv_base_scale=1.f/base_scale
			ret.base_scale=base_scale
			ret.y_baseline_per_height=h_up*inv_base_scale
			for i=0:ret.fonts.n-1
				ret.fonts[i].scale*=inv_base_scale
				ret.fonts[i].draw_dx*=inv_base_scale
				ret.fonts[i].draw_dy*=inv_base_scale
				ret.fonts[i].draw_dy+=ret.y_baseline_per_height-ret.fonts[i].hfnt.y_baseline_per_height*ret.fonts[i].scale
			return JS.Return(ret)
	}
	JS_UI["FontChainToFont"]=function(JSContext JS){
		pfnt=JS.Param(0).as(CFontChain)
		if !pfnt:return 0
		h=JS.Param(1).as(float)
		embolden=JS.Param(2).as(int)
		return JS.Return(TFont(){pfnt:pfnt,h:h*pfnt.base_scale,embolden:embolden})
	}
	JS_UI["GetFontHeight"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(fnt.h)
	}
	JS_UI["_LayoutText"]=function(JSContext JS){
		//just separate text creation and draw
		attrs=JS.Param(0).as(JSObject)
		if !attrs:return 0
		fnt=attrs["font"].as(TFont)
		fnt.h*=g_renderer.m_pixels_per_unit
		if !fnt.pfnt:return 0
		w=attrs["w"].or(1e18f)*g_renderer.m_pixels_per_unit
		h=attrs["h"].or(1e18f)*g_renderer.m_pixels_per_unit
		s=attrs["text"].as(string)
		if !s:return 0
		flags=attrs["flags"].or(g_renderer.EDT_EXPANDTABS|g_renderer.EDT_WORDBREAK)
		layout=g_renderer.ComputeTextLayout(fnt, w,h,s, flags)
		dims=layout.dims
		attrs["w_text"]=dims.x/g_renderer.m_pixels_per_unit
		attrs["h_text"]=dims.y/g_renderer.m_pixels_per_unit
		attrs["__layout"]=layout
		return 0
	}
	JS_UI["DrawTextControlImmediate"]=function(JSContext JS){
		attrs=JS.Param(0).as(JSObject)
		x0=JS.Param(1).or(0.f)*g_renderer.m_pixels_per_unit
		y0=JS.Param(2).or(0.f)*g_renderer.m_pixels_per_unit
		C=int(JS.Param(3).or(u32(-1)))
		fnt=attrs["font"].as(TFont)
		if !fnt.pfnt:return 0
		fnt.h*=g_renderer.m_pixels_per_unit
		if g_renderer.m_srgb_supported:
			fnt.SmartEmbolden(C)
		flags=attrs["flags"].or(g_renderer.EDT_EXPANDTABS|g_renderer.EDT_WORDBREAK)
		s=attrs["text"].or("")
		wspace=g_renderer.GetCharacterAdvance(fnt,int(' '))
		wtab=wspace*8.f
		hc=g_renderer.GetCharacterHeight(fnt)
		y_baseline=g_renderer.GetFontBaseline(fnt)
		y_underline=y_baseline*1.05f
		h_underline=y_baseline*0.05f
		x=x0;y=y0
		xmax=0.f
		is_underlining=0
		for ch in Utf8Chars(s)
			if ch=='\r':continue
			if flags&g_renderer.EDT_PREFIX_TO_UNDERLINE:
				if ch=='&'&&!is_underlining:
					is_underlining=1
					continue
			if ch=='\t':
				if flags&g_renderer.EDT_EXPANDTABS:
					dx=(floor(x/wtab)+1.f)*wtab-x
				else
					dx=wspace
			else if ch=='\n':
				x=x0
				y+=hc
				continue
			else
				dx=g_renderer.DrawChar(fnt,x,y,C,ch)
			if is_underlining:
				g_renderer.DrawRectangle(x,y+y_underline,dx,h_underline, C)
				is_underlining=0
			x+=dx
			xmax=max(xmax,x)
		attrs["w"]=xmax
		attrs["h"]=y+(x>x0?hc:0.f)
		return 0
	}
	JS_UI["DrawTextControl"]=function(JSContext JS){
		attrs=JS.Param(0).as(JSObject)
		x0=JS.Param(1).or(0.f)*g_renderer.m_pixels_per_unit
		y0=JS.Param(2).or(0.f)*g_renderer.m_pixels_per_unit
		C=JS.Param(3).or(u32(-1))
		layout=attrs["__layout"].as(CTextLayout)
		if !layout:return 0
		fnt=attrs["font"].as(TFont)
		if !fnt.pfnt:return 0
		fnt.h*=g_renderer.m_pixels_per_unit
		if g_renderer.m_srgb_supported:
			fnt.SmartEmbolden(int(C))
		foreach li in layout.chars
			g_renderer.DrawChar(fnt,x0+li.pos.x,y0+li.pos.y,int(C),li.ch)
		if layout.underlines:
			foreach ul in layout.underlines
				g_renderer.DrawRectangle(x0+ul.x,y0+ul.y,ul.z,ul.w, int(C))
		return 0
	}
	JS_UI["DrawChar"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		fnt.h*=g_renderer.m_pixels_per_unit
		if !fnt.pfnt:return 0
		x0=JS.Param(1).or(0.f)*g_renderer.m_pixels_per_unit
		y0=JS.Param(2).or(0.f)*g_renderer.m_pixels_per_unit
		C=JS.Param(3).or(u32(-1))
		ch=JS.Param(4).or(32)
		if g_renderer.m_srgb_supported:
			fnt.SmartEmbolden(int(C))
		g_renderer.DrawChar(fnt,x0,y0,int(C),ch)
		return 0
	}
	JS_UI["RoundRect"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return 0
		ctx=g_renderer.CreateRRContext(obj)
		x=obj["x"].or(0.f)*g_renderer.m_pixels_per_unit
		y=obj["y"].or(0.f)*g_renderer.m_pixels_per_unit
		w=obj["w"].or(0.f)*g_renderer.m_pixels_per_unit
		h=obj["h"].or(0.f)*g_renderer.m_pixels_per_unit
		g_renderer.DrawRR(ctx,x,y,w,h)
		return JS.Return(obj)
	}
	//////////////////
	if is_real:
		//JS_UI["LoadPackedTexture"]=function(JSContext JS){
		//	//resource loading... inner loadResourceFile
		//	return 0
		//}
		//JS_UI["LoadStaticImages"]=function(JSContext JS){
		//	obj=JS.Param(0).as(JSObject)
		//	if obj:
		//		//g_ui_search_paths and the zip
		//		foreach sdir in sbox.m_ui_search_paths.ReverseOrder()
		//			foreach fnimage in System.IO.EnumFiles(sdir+"*",System.IO.ENUM_FILE|System.IO.ENUM_RECURSIVE)
		//				if fnimage.ToLower().EndsWith(".png")
		//					fn_nmlz=fnimage.Replace(["\\","/"]).ToLower()
		//					if obj.has(fn_nmlz):continue
		//					sdata=System.IO.ReadAll(fnimage)
		//					if sdata:
		//						bmp=g_renderer.LoadImage(sdata)
		//						obj[fn_nmlz]=g_renderer.LoadStaticBitmap(bmp)
		//		if sbox.m_ui_zip:
		//			foreach fnimage in sbox.m_ui_zip.AllFileNames()
		//				if fnimage.ToLower().EndsWith(".png")
		//					fn_nmlz=fnimage.Replace(["\\","/"]).ToLower()
		//					if obj.has(fn_nmlz):continue
		//					sdata=sbox.m_ui_zip.ReadAll(fnimage)
		//					if sdata:
		//						bmp=g_renderer.LoadImage(sdata)
		//						obj[fn_nmlz]=g_renderer.LoadStaticBitmap(bmp)
		//	return 0
		//}
	///////////////////////////////////
	//misc GL
	if is_real:
		JS_UI["Clear"]=function(JSContext JS){
			C_clear=JS.Param(0).or(u32(-1))
			g_renderer.m_clear_color=C_clear
			c0=f32(C_clear&0xffu)/255.f
			c1=f32((C_clear>>8)&0xffu)/255.f
			c2=f32((C_clear>>16)&0xffu)/255.f
			g_renderer.TestSRGB()
			if g_renderer.m_gamma!=1.f&&g_renderer.m_srgb_supported:
				c0=pow(c0,g_renderer.m_gamma)
				c1=pow(c1,g_renderer.m_gamma)
				c2=pow(c2,g_renderer.m_gamma)
			glClearColor(c0,c1,c2,f32(C_clear>>24)/255.f)
			glClearDepthf(1.f)
			glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)
			return 0
		}
		JS_UI["SetFontSharpening"]=function(JSContext JS){
			g_renderer.m_font_sharpening=JS.Param(0).or(0.f)
			g_renderer.m_filter3=lanczos_filter(3,2,g_renderer.m_font_sharpening)
			g_renderer.m_filter5=lanczos_filter(5,2,g_renderer.m_font_sharpening)
			g_renderer.m_glyph_cache_invalidated=1
			return 0
		}
		JS_UI["EmptyCache"]=function(JSContext JS){
			g_renderer.m_glyph_cache_invalidated=1
			return 0
		}
	else
		JS_UI["Clear"]=function(JSContext JS){
			C_clear=JS.Param(0).or(u32(-1))
			g_renderer.DrawRectangle(0.f,0.f,g_renderer.m_window_w,g_renderer.m_window_h, int(C_clear))
			return 0
		}
	JS_UI["GetSRGBStatus"]=function(JSContext JS){
		ret=JS.New()
		ret["gamma"]=g_renderer.m_gamma
		ret["srgb_supported"]=g_renderer.m_srgb_supported
		return JS.Return(ret)
	}
	JS_UI["SetSRGBEnabling"]=function(JSContext JS){
		g_renderer.m_srgb_supported=JS.Param(0).as(int);
		return JS.Return(g_renderer.m_srgb_supported)
	}
	///////////////////////////////////
	JS_UI["GetCharacterHeight"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(g_renderer.GetCharacterHeight(fnt))
	}
	JS_UI["GetCharacterAdvance"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(g_renderer.GetCharacterAdvance(fnt,JS.Param(1).or(int(' '))))
	}
	JS_UI["MeasureText"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		stext=JS.Param(1).as(string)
		if !fnt.pfnt||!stext:return 0
		x=0.f
		y=0.f
		w=0.f
		hc=g_renderer.GetCharacterHeight(fnt)
		foreach ch in Utf8ToUnicode32(stext)
			if ch=='\n':
				w=max(w,x)
				x=0.f
				y+=hc
			x+=g_renderer.GetCharacterAdvance(fnt,ch)
		w=max(w,x)
		ret=JS.New()
		ret["w"]=w
		ret["h"]=(y+hc)
		return JS.Return(ret)
	}
	///////////////////////////////////
	//timer
	if is_real:
		//timer_user_data=new JSObject[int]
		//sdl_badapi_hack_callback_to_timer_id=new int[iptr]
		//we need a stable handle as the native userdata
		JS_UI["setInterval"]=function(JSContext JS){
			fn=JS.Param(0).as(JSObject)
			if !fn:return 0
			interval=JS.Param(1).as(int)
			if !(interval>0):return 0
			timer_id=SDL_SetInterval(interval,__cast(__pointer,fn));
			fn[1]=timer_id
			__explicit_rc(fn,1)
			//timer_user_data[timer_id]=fn
			//sdl_badapi_hack_callback_to_timer_id[iptr(fn)]=timer_id
			//Writeln('setInterval ',interval,' -> #',timer_id)
			return JS.Return(__cast(__pointer,fn))
		}
		JS_UI["clearInterval"]=function(JSContext JS){
			ptr=JS.Param(0).as(__pointer)
			if !ptr:return 0
			fn=__cast(JSObject,ptr)
			timer_id=fn[1].as(int)
			ret=SDL_ClearInterval(timer_id,__cast(__pointer,fn));
			//Writeln('clearInterval #',timer_id,' ',ret)
			if ret:
				__explicit_rc(fn,-1)
			return JS.Return(ret)
		}
		JS_UI["getTimerFunction"]=function(JSContext JS){
			ptr=JS.Param(0).as(__pointer)
			if !ptr:return 0
			//fn=timer_user_data[sdl_badapi_hack_callback_to_timer_id[iptr(timer_id)]]
			//if !fn:return 0
			fn=__cast(JSObject,ptr)
			return JS.Return(fn)
		}
	////////////////////////////////////////////
	//leak detection
	foreach f in g_ui_exts
		f(JS_UI,sbox,is_real)
	return JS_UI

auto inflate(string sin)
	outlen=0
	ptr_ret=stbi_zlib_decode_noheader_malloc(__pointer(sin.d),sin.n, &outlen);
	ret=new string
	if Platform.BUILD=="debug"&&LeakDetection.isEnabled():
		ret.resize(outlen)
		__basic_api.memcpy(__pointer(ret.d),ptr_ret,outlen)
		LeakDetection.realFree(ptr_ret)
	else
		ret.d=iptr(ptr_ret)
		ret.n=iptr(outlen)
		ret.sz=iptr(outlen)
	return ret
	
class CZipItem
	string dat
	int method
class CZipFile
	string dat
	compressed_files=new CZipItem[string]
	auto ReadAll(string fname0)
		fname=fname0.Replace(["\\","/"]).ToLower()
		item=compressed_files[fname]
		if !item:return string.NULL
		return item.method==0?item.dat:inflate(item.dat)
	inline AllFileNames()
		return {forEach:inline(fbody){
			foreach d,k,I in compressed_files
				fbody(k,d,I)
		}}
auto ParseZip(string dat)
	MAX_COMMENT=65535
	if dat.n<22:return CZipFile.NULL
	ret=new CZipFile(){dat:dat}
	ptail=-1L
	for j=0:MAX_COMMENT
		if dat.n<22+j:break
		pos=dat.n-22-j
		if dat.substr(pos,4)=="PK\005\006":
			ptail=pos
			break
	if ptail<0L:
		if Platform.BUILD=="debug":
			Writeln('unable to parse zip file, size=',dat.n)
		return CZipFile.NULL
	//Writeln('>>> ',__pointer(ptail))
	nfiles=iptr(dat.ReadAtU(ptail+10,u16))
	ofs=iptr(dat.ReadAtU(ptail+16,u32))
	if uptr(ofs)>=uptr(dat.n):return CZipFile.NULL
	for i=0:nfiles-1
		pos0=ofs
		if uptr(pos0+46L)>=uptr(dat.n):return NULL
		nmk=dat.ReadAtU(pos0+28L,u16,3)
		szcrap=iptr(nmk[0])+iptr(nmk[1])+iptr(nmk[2])
		ofs_local=iptr(dat.ReadAtU(pos0+42L,u32))
		if uptr(pos0+46L+szcrap)>=uptr(dat.n):return NULL
		////////////
		if uptr(ofs_local+30L)>=uptr(dat.n)||uptr(ofs_local)>=uptr(dat.n):return NULL
		method=int(dat.ReadAtU(ofs_local+8L,i16))
		szdata=iptr(dat.ReadAtU(ofs_local+18L,u32))
		szname=iptr(dat.ReadAtU(ofs_local+26L,u16))
		szextra=iptr(dat.ReadAtU(ofs_local+28L,u16))
		if uptr(ofs_local+30L+szname)>=uptr(dat.n):return NULL
		sname=dat.substr(ofs_local+30L,szname)
		pfiledata=ofs_local+30L+szname+szextra
		sname=sname.Replace(["\\","/"]).ToLower()
		ret.compressed_files[sname]=new CZipItem(){dat:dat[pfiledata:pfiledata+szdata-1],method:method}
		////////////
		ofs=pos0+46L+szcrap
	return ret

if Platform.ARCH=='web':
	function() g_emscripten_mainloop
	__export("s7_emscripten_mainloop",function(){
		g_emscripten_mainloop();
	})
auto setupModuleSystem(JSContext JS,int is_real)
	__generate_json("android_activity_manifest","android:configChanges=orientation|screenSize|keyboard|keyboardHidden")
	__generate_json("include_js","res_zip.js")
	__generate_json("js_units","gui2d/ui.js")
	__generate_json("js_units","gui2d/widgets.js")
	sbox=new CUISandbox
	global=JS.GetGlobal()
	global["Duktape"]["__ui_native_hack"]=function(JSContext JS){
		mod_obj=JS.Param(0).as(JSObject)
		if !mod_obj:return 0
		createUIObject(mod_obj,sbox,is_real)
		if is_real: 
			createSDLJSObject(mod_obj,0)
			///////
			//smart texture size
			pmode=__C(__pointer,"@decl:SDL_DisplayMode @1={0}")
			SDL.detail.SDL_GetCurrentDisplayMode(0,pmode)
			w=__C(int,"((SDL_DisplayMode*)@1)->w",pmode)
			h=__C(int,"((SDL_DisplayMode*)@1)->h",pmode)
			g_renderer.m_texture_width=max(promoteToTextureSize(max(w,h)),1024)
			g_renderer.EmptyCache()
			__C(int,"@global:int s7_CB_SDLEventFilter(void* userdata, SDL_Event* pevent){\n\
				if(pevent->type==SDL_WINDOWEVENT&&pevent->window.event==SDL_WINDOWEVENT_CLOSE){\n\
					SDL_Event event_virtual_close;\n\
					memset(&event_virtual_close,0,sizeof(event_virtual_close));\n\
					event_virtual_close.user.windowID=pevent->window.windowID;\n\
					event_virtual_close.user.code=1;\n\
					event_virtual_close.type=SDL_USEREVENT;\n\
					SDL_PushEvent(&event_virtual_close);\n\
					return 0;\n\
				}\n\
				return 1;\n\
			}")
			__C(int,"SDL_SetEventFilter(s7_CB_SDLEventFilter,NULL)")
		return 0
	}
	//global["Duktape"]["__ui_load_zip"]=function(JSContext JS){
	//	s_path=JS.Param(0).or("")
	//	sbox.UILoadZip(s_path)
	//	return 0
	//}
	global["Duktape"]["__ui_add_path"]=function(JSContext JS){
		s_path=JS.Param(0).or("")
		sbox.m_ui_search_paths.push(s_path+"/")
		return 0
	}
	global["Duktape"]["modSearch"]=function(JSContext JS){
		s_modname=JS.Param(0).or("")
		s_fname=(s_modname+".js").ToLower()
		sret=sbox.UIReadAll(s_fname)
		if !sret:
			return JS.ReturnError("cannot find module '@1'".Replace(["@1",s_modname]))
		else
			return JS.Return(sret)
	}
	//timing for animation... i64 stored as boxed object
	global["Duktape"]["__ui_get_tick"]=function(JSContext JS){
		return JS.Return(System.Time.tick64())
	}
	global["Duktape"]["__ui_seconds_between_ticks"]=function(JSContext JS){
		return JS.Return(System.Time.TicksToSeconds(JS.Param(1).or(0LL)-JS.Param(0).or(0LL)))
	}
	global["Duktape"]["__byte_length"]=function(JSContext JS){
		lg=0L
		duktape.duk_dup(JS._ctx(),0)
		duktape.duk_to_lstring(JS._ctx(),-1,&lg)
		duktape.duk_pop(JS._ctx())
		return JS.Return(lg)
	}
	global["Duktape"]["__write_log"]=function(JSContext JS){
		if Platform.BUILD=="debug":
			Writeln(JS.Param(0).or(""))
		return JS.Return(0)
	}
	if Platform.ARCH=='web':
		global["Duktape"]["__EmscriptenSetMainLoop"]=function(JSContext JS){
			g_emscripten_mainloop=function(){
				obj_junk=JS["Duktape"].CallMethod(JSObject,"__EmscriptenMainLoop")
			}
			emscripten_set_main_loop=__c_function(int,"emscripten_set_main_loop","emscripten.h")
			emscripten_set_main_loop(__C(__pointer,"s7_emscripten_mainloop"),0,1)
			return 0;
		}
	global["console"]=JS.New()
	global["console"]["log"]=function(JSContext JS){
		s=new string
		for i=0:JS.GetParamCount()-1
			if i:s.push(' ')
			str=JS.Param(i).as(string)
			if str:
				s.push(str)
		Writeln(s)
		return JS.Return(0)
	}
	return sbox

}//module

inline setMSAA(int rate)
	SDL.g_msaa_rate=rate

g_rtt_flags=0
inline setRTTFlags(int flags)
	g_rtt_flags=flags

setupModuleSystem=Gui2D.detail.setupModuleSystem
registerUIExtension=Gui2D.detail.registerUIExtension
CUISandbox=Gui2D.detail.CUISandbox
CSandboxWindow=Gui2D.detail.CSandboxWindow
Utf8Chars=Gui2D.detail.Utf8Chars
g_log_file=string.NULL

auto ProvideGLFunctions()
	registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
		if is_real:
			createGLJSObject(JS_UI)
			JS_UI["GetCurrentWindowSize"]=function(JSContext JS){
				ret=JS.New()
				ret[0]=Gui2D.detail.g_renderer.m_window_w*Gui2D.detail.g_renderer.m_pixels_per_unit
				ret[1]=Gui2D.detail.g_renderer.m_window_h*Gui2D.detail.g_renderer.m_pixels_per_unit
				return JS.Return(ret)
			}
	})

auto DoFileDialog(int is_save,string filterList,string defaultPath)
	NFD_ERROR=0
	NFD_OKAY=1
	NFD_CANCEL=2
	__generate_json("c_files","nfd/nfd_common.c")
	__generate_json("h_files","nfd/nfd_common.h")
	__generate_json("h_files","nfd/common.h")
	NFD_OpenDialog=__c_function(int,"NFD_OpenDialog","nfd/nfd.h")
	NFD_SaveDialog=__c_function(int,"NFD_SaveDialog","nfd/nfd.h")
	if Platform.IS_WINDOWS:
		__generate_json("c_files","nfd/nfd_win.cpp")
	else if Platform.ARCH=="mac":
		__generate_json("c_files","nfd/nfd_cocoa.m")
	else if Platform.IS_LINUX:
		__generate_json("linux_gtk_hack","1")
		__generate_json("c_files","nfd/nfd_gtk.c")
	if filterList:
		sfilters=new(filterList)
		sfilters.push(char(0))
	if defaultPath:
		spath=(Platform.IS_WINDOWS?defaultPath.Replace(["/","\\"]):new(defaultPath))
		spath.push(char(0))
	pptr_ret=[0L]
	if is_save:
		succ=(NFD_SaveDialog(__pointer(sfilters?sfilters.d:0L),__pointer(spath?spath.d:0L),pptr_ret)==NFD_OKAY)
	else
		succ=(NFD_OpenDialog(__pointer(sfilters?sfilters.d:0L),__pointer(spath?spath.d:0L),pptr_ret)==NFD_OKAY)
	ptr_ret=__pointer(pptr_ret[0])
	if succ:
		lg=System.OS_API.strlen(ptr_ret)
		ret=new string
		if Platform.BUILD=="debug"&&LeakDetection.isEnabled():
			ret.resize(lg)
			__basic_api.memcpy(__pointer(ret.d),ptr_ret,lg)
			LeakDetection.realFree(ptr_ret)
		else
			ret.d=iptr(ptr_ret)
			ret.n=lg
			ret.sz=ret.n
		if Platform.IS_WINDOWS:
			ret=ret.Replace(["\\","/"])
	else
		ret=string.NULL
	return ret

OpenDialog=inline(filterList,defaultPath){return DoFileDialog(0,filterList,defaultPath)}
SaveDialog=inline(filterList,defaultPath){return DoFileDialog(1,filterList,defaultPath)}

UIMain=function(){
	JS=new JSContext
	//setup the UI modules and load res/* files from the platform's asset storage
	sbox=setupModuleSystem(JS,1)
	sbox.UILoadZip(string.NULL)
	/////////////
	//give control to the JS main
	sbox.UIRunJS(JS,"res/ui_main.js")
}

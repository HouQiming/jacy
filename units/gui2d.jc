//sharpening filter for font -- just downsample it differently... would it even work?
import Javascript.*
import SDL.*
import GL.*
import System.Math.*
import System.Algorithm.*
import System.Console.*

module detail{
FTW_LoadFont=__c_function(__pointer,"FTW_LoadFont","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetCharacterEx=__c_function(__pointer,"FTW_GetCharacterEx","stb_truetype.h", "c_files","stb_truetype.c")
FTW_UnloadFont=__c_function(int,"FTW_UnloadFont","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetGlyphId=__c_function(int,"FTW_GetGlyphId","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetAscent=__c_function(float,"FTW_GetAscent","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetGlyphAdvance=__c_function(float,"FTW_GetGlyphAdvance","stb_truetype.h", "c_files","stb_truetype.c")
FTW_GetKerning=__c_function(float,"FTW_GetKerning","stb_truetype.h", "c_files","stb_truetype.c")
FTW_SetRetardedWindingOrder=__c_function(int,"FTW_SetRetardedWindingOrder","stb_truetype.h", "c_files","stb_truetype.c")
stbi_write_png_to_mem=__c_function(__pointer,"stbi_write_png_to_mem","stb_image_write.h", "c_files","stb_image_write.c")
stbi_free_image_write=__c_function(__pointer,"stbi_free_image_write","stb_image_write.h", "c_files","stb_image_write.c")
stbi_load_from_memory=__c_function(__pointer,"stbi_load_from_memory","stb_image.h", "c_files","stb_image.c")
stbi_zlib_decode_malloc=__c_function(__pointer,"stbi_zlib_decode_malloc","stb_image.h", "c_files","stb_image.c")
stbi_zlib_decode_noheader_malloc=__c_function(__pointer,"stbi_zlib_decode_noheader_malloc","stb_image.h", "c_files","stb_image.c")
osal_mmap_res_zip=__c_function(__pointer,"osal_mmap_res_zip","spaprt_portable.h")
class CFinalBuffers
	tex0=int[].NULL
	//vbo1 is the transp stuff
	vbo0=int[].NULL
	vbo1=int[].NULL
	nv0=0
	nv1=0
	w0=0
	h0=0
	hreal=0
	zmax=0

auto promoteToTextureSize(int w0)
	//w|=w>>16
	w=w0-1
	w|=w>>1
	w|=w>>2
	w|=w>>4
	w|=w>>8
	w++
	return w

class CBinPacker
	m_wbig=0
	m_hbig=0
	m_skyline=int3[].NULL
	auto __init__(int w)
		m_wbig=w
		m_hbig=0
		m_skyline=[int3(0,w, 0)]
	auto Pack(int w,int h,int dryrun)
		PACKING_Y_TOLERANCE=24
		skyline=m_skyline
		sups=new int[]
		p0=0
		pa0=0
		cands=new int2[]
		foreach sitem,I in skyline
			while sups.n>p0&&skyline[sups.back()].z<=sitem.z:
				sups.pop()
			sups.push(int(I))
			if p0>0:
				ximin=skyline[sups[p0-1]].x+skyline[sups[p0-1]].y
			else
				ximin=0
			while pa0<I&&skyline[pa0].x+skyline[pa0].y<=sitem.x+sitem.y-w:
				xi=skyline[pa0].x
				if xi>=ximin:
					while p0<sups.n&&sups[p0]<pa0:
						p0++
					hbase=skyline[sups[p0]].z
					assert(!cands.n||cands.back().x<=xi)
					if !cands.n||cands.back().y>hbase:
						cands.push(int2(xi,hbase))
				pa0++
			////////////////
			xi=skyline[pa0].x
			if xi+w<=sitem.x+sitem.y://.wbig:
				while p0<sups.n&&sups[p0]<pa0:
					p0++
				hbase=skyline[sups[p0]].z
				assert(!cands.n||cands.back().x<=xi)
				if !cands.n||cands.back().y>hbase:
					cands.push(int2(xi,hbase))
			while p0<sups.n-1&&skyline[sups[p0]].x+skyline[sups[p0]].y<=sitem.x+sitem.y-w:
				p0++
			hbase=skyline[sups[p0]].z
			xi=sitem.x+sitem.y-w
			if xi>=0:
				assert(!cands.n||cands.back().x<=xi)
				if !cands.n||cands.back().y>hbase:
					cands.push(int2(xi,hbase))
		xbest=-1
		ybest=-1
		if cands.n:
			y_base=cands.back().y
			y_ok=y_base+((h*PACKING_Y_TOLERANCE+31)>>6)
			for i=0:cands.n-1
				if cands[i].y<=y_ok:
					xbest=cands[i].x
					ybest=cands[i].y
					break
		if xbest>=0&&!dryrun:
			//go up!
			skyline2=new int3[]
			did=0
			foreach sitem,I in skyline
				if sitem.x+sitem.y<=xbest||sitem.x>=xbest+w:
					skyline2.push(sitem)
				else
					if sitem.x<xbest:
						skyline2.push(int3(sitem.x,xbest-sitem.x,sitem.z))
					if !did:
						did=1
						skyline2.push(int3(xbest,w,ybest+h))
					if xbest+w<sitem.x+sitem.y:
						skyline2.push(int3(xbest+w,sitem.x+sitem.y-(xbest+w),sitem.z))
			m_skyline=skyline2
			m_hbig=max(m_hbig,ybest+h)
		return int2(xbest,ybest)

auto IsAlnumUnicode(int ch)
	if ch>=192:
		if ch>=0x3000&&ch<=0x301f&&ch!=0x3005&&ch!=0x3006:return 0
		if ch>=0x2000&&ch<=0x206f:return 0
		if ch>=0xff00&&ch<0xff5f:
			return u32(ch-(0xfee0+0x30))<10u||u32(ch-(0xfee0+0x41))<26u||u32(ch-(0xfee0+0x61))<26u
		if ch>=0xff5f&&ch<0xff65:
			return 0
		return 1
	else
		return u32(ch-0x30)<10u||u32(ch-0x41)<26u||u32(ch-0x61)<26u

///////////////////////
/*
vbo / tex caching:
	same vbo + tex for all windows
	any window changed = redraw everything
*/
struct TBitmap
	rgba=int[].NULL
	w=0
	h=0

struct TTextureSubImage
	x=0
	y=0
	w=0
	h=0

struct TStretchDIBits
	vdata=int4()
	hwnd=NULL
	bmpid=0
	C=int4()
	pos=0

struct TDrawCall
	hwnd=NULL
	pv=0
	nv=0
	crd16_scale=0
	window_w=0.f
	window_h=0.f
	JSObject js_callback
	function() native_callback

//slow, we're not expecting to run it every frame
auto resampleBitmap(TBitmap bmp0, float gamma, int mipmap_level)
	if mipmap_level==0:
		bmp=bmp0
	else
		inv_gamma=new float[256]
		for i=1:255
			inv_gamma[i]=pow(float(i)/255.f,gamma)
		assert(mipmap_level>0)
		rcp_gamma=1.f/gamma
		img_src=bmp0.rgba
		w_src=bmp0.w
		h_src=bmp0.h
		w_tar=(w_src+(1<<mipmap_level)-1)>>mipmap_level
		h_tar=(h_src+(1<<mipmap_level)-1)>>mipmap_level
		max_knots=(1<<mipmap_level)+1
		wt_x=new float[max_knots]
		wt_y=new float[max_knots]
		inline triangleFilter(float[] wt_x,int w_src,int w_tar)
			return {
				forEach:inline(fbody){
					rcp_zoom=f32(w_src)/f32(w_tar)
					zoom=f32(w_tar)/f32(w_src)
					for x=0:w_tar-1
						auto x0f=f32(x  )*rcp_zoom;auto x0_src=int(floor(x0f))
						auto x1f=f32(x+1)*rcp_zoom;auto x1_src=int(floor(x1f))
						for i=x0_src+1:x1_src-1
							wt_x[i-x0_src]=zoom
						n_knots=x1_src-x0_src+1
						if n_knots==1:
							wt_x[0]=(x1f-x0f)*zoom
						else
							wt_x[0]=(f32(x0_src+1)-x0f)*zoom
							wt_x[n_knots-1]=(x1f-f32(x1_src))*zoom
						fbody(x0_src,x1_src)
				}
			}	
		img_tar=new int[w_tar*h_tar]
		p=0
		for y0,y1 in triangleFilter(wt_y,h_src,h_tar)
			for x0,x1 in triangleFilter(wt_x,w_src,w_tar)
				C=float4(0.f,0.f,0.f,0.f)
				for i=y0:y1
					wi=wt_x[i-y0]
					base=i*w_src
					for j=x0:x1
						wij=wt_x[j-x0]*wi
						Cij=u32(img_src[base+j])
						for k in crange(4)
							C[k]+=inv_gamma[(Cij>>(k*8))&0xffu]*wij
				if gamma!=1.f:
					for k in crange(4)
						C[k]=pow(C[k],rcp_gamma)
				Cret=0
				for k in crange(4)
					Cret+=max(min(int(C[k]*255.f),255),0)<<(k*8)
				img_tar[p++]=Cret
		bmp=TBitmap(){rgba:img_tar,w:w_tar,h:h_tar}
	//pad the edges
	w=bmp.w
	h=bmp.h
	img_padded=new int[(w+2)*(h+2)]
	for i=0:h-1
		lbase=(w+2)*(i+1)
		copy(img_padded[lbase+1:],bmp.rgba[w*i:w*(i+1)-1])
		img_padded[lbase+0]=img_padded[lbase+1]
		img_padded[lbase+w+1]=img_padded[lbase+w]
	for i=0:w+1
		img_padded[i]=img_padded[i+(w+2)]
		img_padded[(w+2)*(h+1)+i]=img_padded[(w+2)*h+i]
	return TBitmap(){rgba:img_padded,w:w+2,h:h+2}

auto packTextures(TBitmap[] texs,int wimg_min,int is_fast)
	srtid=new int[texs.n]
	for i=0:srtid.n-1
		srtid[i]=int(i)
	srtid.Sortby(inline(id){return int2(texs[id].w,texs[id].h)})
	packings=new TTextureSubImage[srtid.n]
	wimg=wimg_min
	foreach tex_i in texs
		wimg=max(wimg,tex_i.w)
	wimg=promoteToTextureSize(wimg)
	pack_order=new int[texs.n]
	ppo=0
	bp=new CBinPacker(wimg)
	i0=0;i1=int(texs.n)
	while i0<i1
		if is_fast:
			id=srtid[--i1]
		else
			xy0=bp.Pack(texs[srtid[i0]].w,texs[srtid[i0]].h,1)
			xy1=bp.Pack(texs[srtid[i1-1]].w,texs[srtid[i1-1]].h,1)
			if xy0.y<xy1.y||xy0.y==xy1.y&&xy0.x<=xy1.x:
				id=i0
				i0++
			else
				id=i1-1
				i1--
			id=srtid[id]
		titem=texs[id]
		xy=bp.Pack(titem.w,titem.h,0)
		packings[id]=TTextureSubImage(){x:xy.x, y:xy.y, w:titem.w, h:titem.h}
		pack_order[ppo]=id;ppo++
	himg=promoteToTextureSize(bp.m_hbig)
	//actually create the static portion of the texture
	tex0=new int[wimg*himg]
	foreach id in pack_order
		titem=texs[id]
		buf=titem.rgba
		px=packings[id].x
		py=packings[id].y
		for i=0:titem.h-1
			copy(tex0[(py+i)*wimg+px:],buf[i*titem.w:(i+1)*titem.w-1])
	return (TBitmap(){rgba:tex0,w:wimg,h:himg},packings)

class CCoreFont
	id=0
	hfnt=NULL
	sdata=string.NULL
	fallbacks=CCoreFont[].NULL
	y_baseline_per_height=0.f
	auto __done__()
		FTW_UnloadFont(hfnt)
		hfnt=NULL
	
struct TFont
	pfnt=CCoreFont.NULL
	h=0.f
	embolden=0
	auto SmartEmbolden(int m_color)
		embolden+=int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*3000.f/h)

//struct TGlyphCacheItem
class CGlyphCacheItem
	TBitmap bmp
	int tex_id
	float dx
	float x_draw,y_draw,w_draw

struct TFastGlyphCacheItem
	CGlyphCacheItem gcitem
	float y_final

struct TPositionedText
	pos=float2()
	ch=0

class CTextLayout
	TPositionedText[] chars
	//x0, y, w, h
	float4[] underlines
	float2 dims

class CSandboxWindow
	int w,h

class CUISandbox
	m_ui_search_paths=new string[]
	CZipFile m_ui_zip
	auto UIReadAll(string s_fname)
		foreach spath in m_ui_search_paths.ReverseOrder()
			sfn_i=spath+s_fname
			if System.IO.FileExists(sfn_i):
				return System.IO.ReadAll(sfn_i)
		if m_ui_zip:
			return m_ui_zip.ReadAll(s_fname)
		return string.NULL
	auto UILoadZip(string szipname)
		arr_res_zip=szipname
		if !arr_res_zip||!arr_res_zip.n:
			if Platform.ARCH=='android'||Platform.ARCH=='ios'||Platform.ARCH=='mac':
				if Platform.ARCH=='android':
					__generate_json("c_files","zipres.c")
					__generate_json("android_system_libnames","android")
				else if Platform.ARCH=='ios'||Platform.ARCH=='mac':
					__generate_json("objc_files","zipres_ios.m")
				sz=0L
				pzip=osal_mmap_res_zip(&sz)
				if pzip:
					arr_res_zip=new string
					arr_res_zip.__bind(1,iptr(pzip),iptr(sz))
			else
				arr_res_zip=System.IO.ReadAll(System.Env.GetExecutablePath()+"res.zip")
		m_ui_zip=ParseZip(arr_res_zip)
	auto UIRunJS(JSContext JS,string fn)
		err=JS.evalVoid(UIReadAll(fn),fn)
		if Platform.BUILD=="debug":
			if err:
				Writeln(err["stack"].or(""))

class IRendererHook
	function() BeginFrame
	function() EndFrame
	function() OnFirstDraw

//the DC singleton
class CRenderer
	//////////////
	//current status
	m_hwnd=NULL
	COORD_MAX=65535
	VERTEX_SIZE=3
	m_clip=float4()
	m_clip_stack=new float4[]
	//////////////
	//use int ids natively and leave the map stuff to js
	m_static_textures=new TBitmap[]
	m_static_packings=TTextureSubImage[].NULL
	m_static_original_sizes=new int2[]
	m_static_packed_bmp=TBitmap()
	//m_screen_dpi=96
	//m_design_dpi=96
	m_pixels_per_unit=1.f
	m_font_sharpening=0.f
	m_gamma=2.2f
	m_mipmap_level=0
	m_text_y_snap=1
	m_texture_width=1024
	//////////////
	m_dynamic_textures=TBitmap[].NULL
	m_dynamic_packings=TTextureSubImage[].NULL
	m_dynamic_packed_bmp=TBitmap()
	m_StretchDIBits_calls=TStretchDIBits[].NULL
	m_texture_downloaded=0
	//////////////
	//single vbo for simplicity
	m_vbo=new int[]
	m_drawcall_start=0
	m_crd16_scale=1
	m_window_w=1.f
	m_window_h=1.f
	m_uv16_scale=1
	m_drawcalls=new TDrawCall[]
	//////////////
	m_texid=0u
	m_srgb_supported=-1
	m_tex_is_srgb=0
	m_texture_height=0
	m_tech=new GLTechnique
	m_caret_tech=new GLTechnique
	//m_vboid=0u
	//m_vbo_size=0
	//////////////
	//the dpis are not necessarily dpis
	//inline SetDesignDPI(int dpi)
	//	m_design_dpi=dpi
	//auto SetScreenDPI(int dpi)
	auto SetScalingFactor(float scale)
		m_static_textures=new TBitmap[]
		m_static_packings=TTextureSubImage[].NULL
		m_pixels_per_unit=scale
		//m_screen_dpi=dpi
		//create a pure white bmp
		//img3x3=new int[9]
		//for i=0:8
		//	img3x3[i]=-1
		//LoadStaticBitmap(TBitmap(){rgba:img3x3,w:3,h:3})
		LoadStaticBitmap(TBitmap(){rgba:[-1],w:1,h:1})
		//LoadStaticBitmap(TBitmap(){rgba:[0xff0000ff],w:1,h:1})
		////////
		m_mipmap_level=0
		sdpi=1.f
		while sdpi*2.f<=m_pixels_per_unit
			sdpi*=2.f
			m_mipmap_level++
		//m_pixels_per_unit=f32(m_screen_dpi)/f32(m_design_dpi)
	//////////////////////////
	auto SavePNG(string fn, int[] img,int w,int h)
		len=0
		spng=stbi_write_png_to_mem(img,w*4,w,h,4,&len)
		if !spng:
			assert(0)
			return
		spng_str=__ptrToString(spng,len)
		System.IO.CreateFile(fn).Write(spng_str)
		stbi_free_image_write(spng)
	//dpi-resampling only makes sense when we don't intend to zoom it
	//if we do, set dpi to 0
	auto LoadStaticBitmap(TBitmap bmp_original)
		m_static_original_sizes.push(int2(bmp_original.w,bmp_original.h))
		bmp=resampleBitmap(bmp_original,m_gamma,m_mipmap_level)
		m_static_textures.push(bmp)
		return int(m_static_textures.n)-1
	auto PackStaticBitmaps()
		//coulddo: cache precomputed per-DPI textures
		/////////
		//bmp_tex=TBitmap()
		//(bmp_tex,m_static_packings)=packTextures(m_static_textures,m_texture_width,0)
		(m_static_packed_bmp,m_static_packings)=packTextures(m_static_textures,m_texture_width,0)
		m_texture_width=max(m_texture_width,m_static_packed_bmp.w)
		m_uv16_scale=32768/m_texture_width
		m_static_textures=NULL
		//m_static_packed_bmp=bmp_tex
		//SavePNG("$static.png",bmp_tex.rgba,bmp_tex.w,bmp_tex.h)
	//////////////
	m_tick0=0LL
	m_frame_ticks=0LL
	m_hooks=new IRendererHook[]
	auto BeginFrame()
		//Writeln('----------------')
		m_drawcalls.clear()
		m_vbo.clear()
		m_glyph_cache_prev=m_glyph_cache
		if m_glyph_cache_invalidated:
			m_glyph_cache_prev.discard()
			m_glyph_cache_invalidated=0
		m_glyph_cache=new CGlyphCacheItem[int3]
		m_fast_glyph_cache_font=TFont()
		m_has_new_glyph_cache_entry=0
		m_dynamic_textures=new TBitmap[]
		m_dynamic_packings=TTextureSubImage[].NULL
		m_StretchDIBits_calls=new TStretchDIBits[]
		m_dynamic_packed_bmp=TBitmap()
		m_dynamic_packings=TTextureSubImage[].NULL
		m_tick0=System.Time.tick64()
		foreach hk in m_hooks
			if hk.BeginFrame:hk.BeginFrame()
	auto EndFrame()
		foreach hk in m_hooks.ReverseOrder()
			if hk.EndFrame:hk.EndFrame()
		//pack m_dynamic_textures and apply the dynamic drawcalls
		if m_StretchDIBits_calls.n:
			//tick0=System.Time.tick64()
			(m_dynamic_packed_bmp,m_dynamic_packings)=packTextures(m_dynamic_textures,m_texture_width,1)
			//SavePNG("$dynamic.png",m_dynamic_packed_bmp.rgba,m_dynamic_packed_bmp.w,m_dynamic_packed_bmp.h)
			foreach scall in m_StretchDIBits_calls
				packed=m_dynamic_packings[scall.bmpid]
				n0=scall.pos
				vdata=scall.vdata
				u0=__int_as_float(0x4b000000+1+packed.x)-8388608.f
				v0=__int_as_float(0x4b000000+1+packed.y+m_static_packed_bmp.h)-8388608.f
				du=__int_as_float(0x4b000000-2+packed.w)-8388608.f
				dv=__int_as_float(0x4b000000-2+packed.h)-8388608.f
				//clip_u0=f32(vdata.z&0xffff)/32768.f
				//clip_v0=f32(u32(vdata.z)>>16)/32768.f
				//clip_u1=f32(vdata.w&0xffff)/32768.f
				//clip_v1=f32(u32(vdata.w)>>16)/32768.f
				clip_u0=__int_as_float((vdata.z&0xffff)+0x43800000)-256.f
				clip_v0=__int_as_float(int(u32(vdata.z)>>16)+0x43800000)-256.f
				clip_u1=__int_as_float((vdata.w&0xffff)+0x43800000)-256.f
				clip_v1=__int_as_float(int(u32(vdata.w)>>16)+0x43800000)-256.f
				u1=u0+du*clip_u1
				v1=v0+dv*clip_v1
				u0=u0+du*clip_u0
				v0=v0+dv*clip_v0
				inline f2i_uv(float f)
					//return max(min(int(f*float(m_uv16_scale)),65535),0)
					return max(min(__float_as_int(f*float(m_uv16_scale)+8388608.f)-0x4b000000,65535),0)
				u0i=f2i_uv(u0)
				v0i=(f2i_uv(v0)<<16)
				u1i=f2i_uv(u1)
				v1i=(f2i_uv(v1)<<16)
				m_vbo[n0+(VERTEX_SIZE*0+0)]=vdata.x
				m_vbo[n0+(VERTEX_SIZE*0+1)]=v0i+u0i
				m_vbo[n0+(VERTEX_SIZE*0+2)]=scall.C[0]
				m_vbo[n0+(VERTEX_SIZE*1+0)]=(vdata.x&0xffff0000)+(vdata.y&0xffff)
				m_vbo[n0+(VERTEX_SIZE*1+1)]=v0i+u1i
				m_vbo[n0+(VERTEX_SIZE*1+2)]=scall.C[1]
				m_vbo[n0+(VERTEX_SIZE*2+0)]=vdata.y
				m_vbo[n0+(VERTEX_SIZE*2+1)]=v1i+u1i
				m_vbo[n0+(VERTEX_SIZE*2+2)]=scall.C[2]
				m_vbo[n0+(VERTEX_SIZE*3+0)]=(vdata.x&0xffff)+(vdata.y&0xffff0000)
				m_vbo[n0+(VERTEX_SIZE*3+1)]=v1i+u0i
				m_vbo[n0+(VERTEX_SIZE*3+2)]=scall.C[3]
				//Writeln(u0,' ',v0,' ',du,' ',dv,' ',formatNumber(u32(scall.C),{base:16,align:8}))
			m_dynamic_textures=NULL
			m_StretchDIBits_calls=NULL
			//dt=System.Time.tick64()-tick0
			//Writeln('dyntex=',formatNumber(System.Time.TicksToSeconds(dt)*1000.,{frac:2}),'ms')
		else
			m_dynamic_packed_bmp=TBitmap()
			m_dynamic_packings=TTextureSubImage[].NULL
		m_frame_ticks=System.Time.tick64()-m_tick0
		m_texture_downloaded=0
	inline texsubimage_format()
		if m_srgb_supported&&IS_OPENGL_ES:
			return GL_SRGB_ALPHA
		else
			return GL_RGBA
	auto TestSRGB()
		if m_srgb_supported<0:
			if IS_OPENGL_ES:
				m_srgb_supported=!!SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_sRGB")
			else
				m_srgb_supported=!!(SDL.detail.SDL_GL_ExtensionSupported("GL_EXT_texture_sRGB")&&SDL.detail.SDL_GL_ExtensionSupported("GL_ARB_framebuffer_sRGB"))
				//if Platform.ARCH=="linux32"||Platform.ARCH=="linux64":
				//	if m_srgb_supported:
				//		is_capable=0
				//		glGetIntegerv(GL_FRAMEBUFFER_SRGB_CAPABLE_EXT,&is_capable)
				//		if !is_capable:
				//			m_srgb_supported=0
			//m_srgb_supported=0
	auto debugDumpVBO()
		Writeln('=========== Draw')
		inline i2f_P(int i)
			return (__int_as_float(i+0x4b000000)-8388608.f)/float(m_crd16_scale)
		inline i2f_uv(int i)
			return (__int_as_float(i+0x4b000000)-8388608.f)/float(m_uv16_scale)
		for i=0:VERTEX_SIZE:m_vbo.n-VERTEX_SIZE
			P_x=i2f_P(m_vbo[i]&0xffff)
			P_y=i2f_P((m_vbo[i]>>16)&0xffff)
			u=i2f_uv(m_vbo[i+1]&0xffff)
			v=i2f_uv((m_vbo[i+1]>>16)&0xffff)
			Writeln(formatNumber(P_x,{frac:1}),' ',formatNumber(P_y,{frac:1}),' ',formatNumber(u,{frac:3}),' ',formatNumber(v,{frac:3}),' ',
				formatNumber(u32(m_vbo[i+2]),{base:16,align:8}))
			if ((i/VERTEX_SIZE)&3)==3:
				Writeln('-------')
	auto DrawWindow(__pointer hwnd_onlydraw,float2 translation,float2 scale)
		TestSRGB()
		if !m_texture_downloaded:
			m_texture_downloaded=1
			texture_height_needed=m_static_packed_bmp.h
			if m_dynamic_packings:
				texture_height_needed+=m_dynamic_packed_bmp.h
			texture_height_needed=promoteToTextureSize(texture_height_needed)
			if texture_height_needed>m_texture_height:
				if m_texid:
					glDeleteTextures(1,&m_texid)
					m_texid=0u
				m_texture_height=texture_height_needed
				if m_srgb_supported:
					m_tex_is_srgb=1
					m_texid=glCreateTexture(GL_SRGB_ALPHA,m_texture_width,m_texture_height, GL_LINEAR,GL_CLAMP_TO_EDGE,GL_CLAMP_TO_EDGE,NULL)
					if !m_texid:
						m_srgb_supported=0
						if !IS_OPENGL_ES:
							glDisable(GL_FRAMEBUFFER_SRGB_EXT)
				if !m_texid:
					m_tex_is_srgb=0
					m_texid=glCreateTexture(GL_RGBA8,m_texture_width,m_texture_height, GL_LINEAR,GL_CLAMP_TO_EDGE,GL_CLAMP_TO_EDGE,NULL)
				if Platform.BUILD=="debug"&&!m_texid:
					__basic_api.spapReportError("failed to create a @1x@2 UI texture - too many, too large, or too irregularly-shaped images\0".Replace(["@1",string(m_texture_width),"@2",string(m_texture_height)]))
				glBindTexture(GL_TEXTURE_2D,m_texid)
				glGetError()
				glTexSubImage2D(GL_TEXTURE_2D,0,0,0,m_static_packed_bmp.w,m_static_packed_bmp.h,texsubimage_format(),GL_UNSIGNED_BYTE,__pointer(m_static_packed_bmp.rgba.d))
				if texsubimage_format()!=GL_RGBA&&m_srgb_supported&&glGetError()!=GL_NO_ERROR:
					glTexSubImage2D(GL_TEXTURE_2D,0,0,0,m_static_packed_bmp.w,m_static_packed_bmp.h,GL_RGBA,GL_UNSIGNED_BYTE,__pointer(m_static_packed_bmp.rgba.d))
				glBindTexture(GL_TEXTURE_2D,0u)
			if m_dynamic_packings:
				glBindTexture(GL_TEXTURE_2D,m_texid)
				glTexSubImage2D(GL_TEXTURE_2D,0,0,m_static_packed_bmp.h,m_dynamic_packed_bmp.w,m_dynamic_packed_bmp.h,texsubimage_format(),GL_UNSIGNED_BYTE,__pointer(m_dynamic_packed_bmp.rgba.d))
				if texsubimage_format()!=GL_RGBA&&m_srgb_supported&&glGetError()!=GL_NO_ERROR:
					glTexSubImage2D(GL_TEXTURE_2D,0,0,m_static_packed_bmp.h,m_dynamic_packed_bmp.w,m_dynamic_packed_bmp.h,GL_RGBA,GL_UNSIGNED_BYTE,__pointer(m_static_packed_bmp.rgba.d))
				glBindTexture(GL_TEXTURE_2D,0u)
			m_dynamic_packed_bmp=TBitmap()
			m_dynamic_packings=TTextureSubImage[].NULL
			////////////////
			//do the vbo in
			//if m_vbo_size<int(m_vbo.n):
			//	if m_vboid:
			//		glDeleteBuffers(1,&m_vboid)
			//	m_vbo_size=int(m_vbo.n)
			//	glGenBuffers(1,&m_vboid)
			//	glBindBuffer(GL_ARRAY_BUFFER,m_vboid)
			//	glBufferData(GL_ARRAY_BUFFER,m_vbo_size*sizeof(int),NULL,GL_STREAM_DRAW)
			//	glBindBuffer(GL_ARRAY_BUFFER,0u)
			/////////////////////
			foreach hk in m_hooks.ReverseOrder()
				if hk.OnFirstDraw:hk.OnFirstDraw()
		glDisable(GL_DEPTH_TEST)
		glEnable(GL_BLEND)
		if !IS_OPENGL_ES&&m_srgb_supported:
			glGetError()
			glEnable(GL_FRAMEBUFFER_SRGB_EXT)
			err=glGetError()
			if err!=GL_NO_ERROR:
				m_srgb_supported=0
		//glEnable(GL_TEXTURE_2D)
		glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)
		//debugDumpVBO()
		foreach dc in m_drawcalls
			if dc.hwnd==hwnd_onlydraw||!hwnd_onlydraw:
				if dc.js_callback:
					dc.js_callback.Call(JSObject)
					continue
				if dc.native_callback:
					dc.native_callback()
					continue
				if !m_tech.m_prg:
					m_tech.SetVarying("vec2 uv;vec4 C;")
					m_tech.SetVertexShader("
					void main(){
						vec2 P_scr=P*scale.xy;
						uv=uv_vert*scale.zw;
						"+(m_srgb_supported?"C=vec4(pow(C_vert.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_vert.w);":"C=C_vert;")+"
						gl_Position=vec4(P_scr.x+trans.x,P_scr.y+trans.y,1.0,1.0);
					}")
					if m_srgb_supported&&!m_tex_is_srgb:
						m_tech.SetFragmentShader("void main(){vec4 C_tex=texture2D(tex0,uv).aaaa;gl_FragColor=vec4(pow(C_tex.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_tex.w)*C;}")
					else
						m_tech.SetFragmentShader("void main(){gl_FragColor=texture2D(tex0,uv).aaaa*C;}")
				pslice=m_vbo[dc.pv:]
				m_tech.SetVertexPointer("P", 2,GL_UNSIGNED_SHORT,0, VERTEX_SIZE*sizeof(int),pslice.d)
				m_tech.SetVertexPointer("uv_vert", 2,GL_UNSIGNED_SHORT,0, VERTEX_SIZE*sizeof(int),pslice.d+1*sizeof(int))
				m_tech.SetVertexPointer("C_vert", 4,GL_UNSIGNED_BYTE,1, VERTEX_SIZE*sizeof(int),pslice.d+2*sizeof(int))
				scale_scr=float2(scale.x*2.f/f32(dc.window_w),-scale.y*2.f/f32(dc.window_h))
				m_tech.SetUniform("scale",float4(scale_scr.x/f32(dc.crd16_scale),scale_scr.y/f32(dc.crd16_scale), 1.f/f32(m_texture_width*m_uv16_scale),1.f/f32(m_texture_height*m_uv16_scale)))
				m_tech.SetUniform("trans",float2(-1.f,1.f)+translation*scale_scr)
				m_tech.SetTexture2D("tex0", m_texid)
				m_tech.Draw(0u,GL_QUADS,dc.nv)
	auto DrawCaret(float x,float y,float w,float h,int C)
		m_caret_tech.SetVarying("vec4 C;")
		m_caret_tech.SetVertexShader("
		void main(){
			vec2 P_scr=P*scale;
			"+(m_srgb_supported?"C=vec4(pow(C_vert.xyz,vec3("+formatNumber(m_gamma,{frac:7})+")),C_vert.w);":"C=C_vert;")+"
			gl_Position=vec4(P_scr.x-1.0,1.0-P_scr.y,1.0,1.0);
		}")
		mini_vbo=[
			__float_as_int(x),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y),
			__float_as_int(x+w),__float_as_int(y+h),
			__float_as_int(x),__float_as_int(y+h),
			C,C,C,C]
		m_caret_tech.SetFragmentShader("void main(){gl_FragColor=C;}")
		m_caret_tech.SetVertexPointer("P", 2,GL_FLOAT,0, 2*sizeof(int),mini_vbo.d)
		m_caret_tech.SetVertexPointer("C_vert", 4,GL_UNSIGNED_BYTE,1, sizeof(int),mini_vbo.d+8*sizeof(float))
		prev_viewport=new int[4]
		glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
		m_caret_tech.SetUniform("scale",float2(2.f/f32(prev_viewport[2]),2.f/f32(prev_viewport[3])))
		m_caret_tech.Draw(0u,GL_QUADS,4)
		mini_vbo.discard()
		//only draw caret for the last drawcall
	//////////////
	//avoid caching the resampled / original bitmaps - batched loadStaticResources
	auto BeginPaint(__pointer hwnd,float w,float h)
		if m_static_textures:
			PackStaticBitmaps()
		m_hwnd=hwnd
		m_clip=float4(0.f,0.f,w,h)
		m_clip_stack.clear()
		m_crd16_scale=max(65536/promoteToTextureSize(int(ceil(max(w,h)))+1),1)
		m_drawcall_start=int(m_vbo.n)
		m_window_w=w
		m_window_h=h
	auto FlushDrawcall()
		//create a drawcall
		if m_window_w&&m_window_h&&m_drawcall_start<int(m_vbo.n):
			m_drawcalls.push(TDrawCall(){
				hwnd:m_hwnd,
				pv:m_drawcall_start,
				nv:(int(m_vbo.n)-m_drawcall_start)/VERTEX_SIZE,
				crd16_scale:m_crd16_scale,
				window_w:m_window_w,
				window_h:m_window_h})
		m_drawcall_start=int(m_vbo.n)
	auto EndPaint()
		FlushDrawcall()
		//and to allow caret / progress overlay - videos
		//refer to the same vbo using different drawcalls
		m_hwnd=NULL
		m_clip=float4()
		m_clip_stack.clear()
	auto InsertJSDrawCall(JSObject js_callback)
		FlushDrawcall()
		m_drawcalls.push(TDrawCall(){hwnd:m_hwnd,js_callback:js_callback})
	auto InsertNativeDrawCall(function() native_callback)
		FlushDrawcall()
		m_drawcalls.push(TDrawCall(){hwnd:m_hwnd,native_callback:native_callback})
	auto SwitchToSubWindow(int x0,int y0,int w0,int h0,int is_relative,int is_pop)
		ww=0
		hw=0
		SDL.detail.SDL_GL_GetDrawableSize(m_hwnd,&ww,&hw)
		x=x0
		y=y0
		w=w0
		h=h0
		//if w<=0:
		//	x=0
		//	w=ww
		//if h<=0:
		//	y=0
		//	h=hw
		InsertNativeDrawCall(function(){
			//if Platform.ARCH=="linux32"||Platform.ARCH=="linux64":
			//	glFinish()
			if is_relative:
				prev_viewport=new int[4]
				glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
				glViewport(prev_viewport[0]+x,prev_viewport[1]+prev_viewport[3]-y-h,w,h)
			else
				glViewport(x,hw-y-h,w,h)
		})
		if is_pop:
			m_clip=m_clip_stack.pop()
		else
			m_clip_stack.push(m_clip)
			m_clip=float4(0.f,0.f,float(w),float(h))
		//m_clip_stack.clear()
		m_crd16_scale=max(65536/promoteToTextureSize(max(w,h)+1),1)
		m_drawcall_start=int(m_vbo.n)
		m_window_w=f32(w)
		m_window_h=f32(h)
	inline PushCliprect(float x,float y,float w,float h)
		m_clip_stack.push(m_clip)
		m_clip=float4(max(m_clip.x,x),max(m_clip.y,y),min(m_clip.z,x+w),min(m_clip.w,y+h))
	inline PopCliprect()
		m_clip=m_clip_stack.pop()
	auto _DrawBitmap(int hbmp, float x0,float y0,float w0,float h0, int C, int is_static)
		if is_static:
			packed=m_static_packings[hbmp]
			//Writeln(m_clip,' ',packed,' ',x0,' ',y0,' ',w0,' ',h0)
			u0=float(packed.x+1)
			v0=float(packed.y+1)
			cu=float(packed.w-2)
			cv=float(packed.h-2)
		else
			//packed=m_dynamic_packings[hbmp]
			u0=0.f
			v0=0.f
			cu=f32(m_texture_width)
			cv=f32(m_texture_width)
		x=x0;y=y0;w=w0;h=h0
		if x<m_clip.x:
			dx=m_clip.x-x
			t=dx/w
			x=m_clip.x;w-=dx
			du=cu*t
			u0+=du;cu-=du
		if m_clip.z<x+w:
			dx=m_clip.z-x
			t=dx/w
			w=dx
			cu*=t
		//use negated tests against NaN
		if !(cu>0.f)||!(x+w>x):return
		if y<m_clip.y:
			dy=m_clip.y-y
			t=dy/h
			y=m_clip.y;h-=dy
			dv=cv*t
			v0+=dv;cv-=dv
		if m_clip.w<y+h:
			dy=m_clip.w-y
			t=dy/h
			h=dy
			cv*=t
		if !(cv>0.f)||!(y+h>y):return
		inline f2i_P(float f)
			//return max(min(int(f*float(m_crd16_scale)),65535),0)
			return max(min(__float_as_int(f*float(m_crd16_scale)+8388608.f)-0x4b000000,65535),0)
		inline f2i_uv(float f)
			//return max(min(int(f*float(m_uv16_scale)),65535),0)
			return max(min(__float_as_int(f*float(m_uv16_scale)+8388608.f)-0x4b000000,65535),0)
		//assert(x>=m_clip.x&&x<=m_clip.z)
		//assert(x+w>=m_clip.x&&x+w<=m_clip.z)
		//assert(y>=m_clip.y&&y<=m_clip.w)
		//assert(y+h>=m_clip.y&&y+h<=m_clip.w)
		ix0=f2i_P(x)
		iy0=f2i_P(y)
		iu0=f2i_uv(u0)
		iv0=f2i_uv(v0)
		ix1=f2i_P(x+w)
		iy1=f2i_P(y+h)
		iu1=f2i_uv(u0+cu)
		iv1=f2i_uv(v0+cv)
		if is_static:
			n0=m_vbo.n
			m_vbo.resize(n0+VERTEX_SIZE*4)
			m_vbo[n0+(VERTEX_SIZE*0+0)]=((iy0)<<16)+(ix0)
			m_vbo[n0+(VERTEX_SIZE*0+1)]=((iv0)<<16)+(iu0)
			m_vbo[n0+(VERTEX_SIZE*0+2)]=C
			m_vbo[n0+(VERTEX_SIZE*1+0)]=((iy0)<<16)+(ix1)
			m_vbo[n0+(VERTEX_SIZE*1+1)]=((iv0)<<16)+(iu1)
			m_vbo[n0+(VERTEX_SIZE*1+2)]=C
			m_vbo[n0+(VERTEX_SIZE*2+0)]=((iy1)<<16)+(ix1)
			m_vbo[n0+(VERTEX_SIZE*2+1)]=((iv1)<<16)+(iu1)
			m_vbo[n0+(VERTEX_SIZE*2+2)]=C
			m_vbo[n0+(VERTEX_SIZE*3+0)]=((iy1)<<16)+(ix0)
			m_vbo[n0+(VERTEX_SIZE*3+1)]=((iv1)<<16)+(iu0)
			m_vbo[n0+(VERTEX_SIZE*3+2)]=C
		else
			vdata=int4(((iy0)<<16)+(ix0),((iy1)<<16)+(ix1),((iv0)<<16)+(iu0),((iv1)<<16)+(iu1))
			n0=m_vbo.n
			m_vbo.resize(n0+VERTEX_SIZE*4)
			m_StretchDIBits_calls.push(TStretchDIBits(){vdata:vdata,hwnd:m_hwnd,bmpid:hbmp,C:int4(C,C,C,C),pos:int(n0)})
		//Writeln(x,' ',y,' ',w,' ',h,' ',m_vbo.n)
	inline DrawBitmap(int hbmp, float x0,float y0,float w0,float h0, int C)
		_DrawBitmap(hbmp,x0,y0,w0,h0,C,1)
	auto CreateTransientBitmap(TBitmap bmp0,const is_pre_padded)
		if is_pre_padded:
			m_dynamic_textures.push(bmp0)
		else
			bmp=resampleBitmap(bmp0,m_gamma,0)
			m_dynamic_textures.push(bmp)
		return int(m_dynamic_textures.n)-1
	auto StretchDIBits(TBitmap bmp, float x0,float y0,float w0,float h0, int C)
		//allow rotation here for the long thin?
		m_dynamic_textures.push(bmp)
		_DrawBitmap(int(m_dynamic_textures.n)-1,x0,y0,w0,h0,C,0)
	//////////////
	m_glyph_cache_prev=new CGlyphCacheItem[int3]
	m_glyph_cache=new CGlyphCacheItem[int3]
	m_glyph_cache_invalidated=0
	m_has_new_glyph_cache_entry=0
	m_font_paths=string[].NULL
	m_std_fallback_fonts=new string[]
	m_font_unique_id=0
	auto CreateCoreFontFromData(string sdata)
		hfnt=FTW_LoadFont(sdata,sdata.n)
		if hfnt:
			return CCoreFont(){hfnt:hfnt,sdata:sdata,id:m_font_unique_id++,y_baseline_per_height:FTW_GetAscent(hfnt,1)}
		else
			return CCoreFont.NULL
	auto InitFonts()
		if !m_font_paths:
			m_font_paths=new string[]
			if Platform.ARCH==('android'):
				//android font path
				m_font_paths.push(('/system/fonts/'))
				m_std_fallback_fonts.push(('DroidSansFallback'))
			else if Platform.ARCH==('ios'):
				//there is no longer a default font on iOS, you must provide one
				m_std_fallback_fonts.push('res/fonts/opensans.ttf')
				//m_font_paths.push(('/System/Library/Fonts/'))
				//m_font_paths.push(('/System/Library/Fonts/Cache/'))
				//foreach spath in m_font_paths
				//	Writeln('*** searching for iOS fonts at '+spath)
				//	foreach fnfont in System.IO.EnumFiles(spath+"*",System.IO.ENUM_FILE)
				//		Writeln(fnfont)
				//Writeln('*** listing iOS files')
				//foreach fnfont in System.IO.EnumFiles("/*",System.IO.ENUM_FILE|System.IO.ENUM_RECURSIVE)
				//	Writeln(fnfont)
				//m_std_fallback_fonts.push(('Helvetica'))
				//m_std_fallback_fonts.push(('STHeiti-Medium'))
				//m_std_fallback_fonts.push(('LastResort'))
			else if Platform.ARCH==('mac'):
				m_font_paths.push(('/Library/Fonts/'))
				m_font_paths.push(('/System/Library/Fonts/'))
				m_font_paths.push(('/System/Library/Fonts/Cache/'))
				m_std_fallback_fonts.push(('Helvetica'))
				m_std_fallback_fonts.push(('STHeiti Medium'))
				m_std_fallback_fonts.push(('LastResort'))
			else if Platform.IS_UNIX:
				//linux doesn't have standard fonts
				m_font_paths.push(('/usr/share/fonts/truetype/droid/'))
				m_std_fallback_fonts.push(('DroidSansFallbackFull'))
			else
				m_font_paths.push(System.Env.ExpandEnvironmentStrings(("%windir%\\fonts\\")))
				found_arialuni=0
				foreach spath in m_font_paths
					foreach fnfont in System.IO.EnumFiles(spath+"ArialUni.*",System.IO.ENUM_FILE)
						found_arialuni=1
						break
					if found_arialuni:break
				if found_arialuni:
					m_std_fallback_fonts.push(('ArialUni'))
				else
					m_std_fallback_fonts.push(('Arial'))
	auto CreateCoreFontByName(CUISandbox sbox,string sname)
		//JS: core font caching, file font embedding
		//and fallbacks... depend on caching - just put m_std_fallback_fonts into JS as an array
		sdata=sbox.UIReadAll(sname)
		if sdata:
			ret=CreateCoreFontFromData(sdata)
			if ret:return ret
		foreach spath in m_font_paths
			//Writeln(spath,' ',sname)
			foreach fnfont in System.IO.EnumFiles(spath+sname+".*",System.IO.ENUM_FILE)
				//Writeln('>>> ',fnfont)
				sdata=System.IO.ReadAll(fnfont)
				if sdata:
					ret=CreateCoreFontFromData(sdata)
					if ret:return ret
		return CCoreFont.NULL
	auto CreateCoreFontChain(CCoreFont[] fonts)
		ret=CCoreFont(){fallbacks:fonts}
		y_baseline_per_height=0.f
		foreach pfnt_i in ret.fallbacks
			if y_baseline_per_height<pfnt_i.y_baseline_per_height:
				y_baseline_per_height=pfnt_i.y_baseline_per_height
		ret.y_baseline_per_height=y_baseline_per_height
		return ret
	auto CreateFont(CCoreFont pfnt,float h,int embolden)
		return TFont(){pfnt:pfnt,h:h,embolden:embolden}
	auto CacheGlyph(TFont fnt, int ch)
		embolden=float(max(min(fnt.embolden,511),-512))*fnt.h
		x_aa=3
		y_aa=3
		//if fnt.h<32:x_aa=3
		//no matter how large the font is, x_aa always makes it sharper
		//if fnt.h<128.f:
		//x_aa=3
		if fnt.h<16.f:
			x_aa=5
			y_aa=5
		ret=CGlyphCacheItem.NULL
		delta_y=0.f
		pfnt=fnt.pfnt
		if pfnt.fallbacks:
			//look up the fallback chain
			fnt_i=fnt
			foreach pfnt_i in pfnt.fallbacks
				fnt_i.pfnt=pfnt_i
				(ret,delta_y_original)=CacheGlyph(fnt_i,ch)
				if ret:
					delta_y=(pfnt.y_baseline_per_height-pfnt_i.y_baseline_per_height)*fnt.h+delta_y_original
					break
		else
			//it doesn't have the glyph, fallback
			//need this to avoid re-renders
			key=int3(pfnt.id*1024+max(min(fnt.embolden+512,1023),0),__float_as_int(fnt.h),ch)
			//Writeln('above ret=m_glyph_cache[key]')
			ret=m_glyph_cache[key]
			//Writeln('below ret=m_glyph_cache[key]')
			if !ret&&FTW_GetGlyphId(pfnt.hfnt,ch):
				ret=m_glyph_cache_prev[key]
				if !ret:
					m_has_new_glyph_cache_entry=1
					dims=new float[6]
					//pbitmap=FTW_GetCharacterEx(pfnt.hfnt,fnt.h,x_aa, embolden, ch,dims)
					//font_sharpening=m_font_sharpening*max(min(1.f-(fnt.h-16.f)/16.f,1.f),0.f)
					font_sharpening=m_font_sharpening
					lanczos_filter=function(int aa,int szwnd){
						auto htap=aa*szwnd
						auto ret=new float[htap*2+1]
						auto scale=float(PI)/float(aa)
						auto scale2=float(PI)/float(aa*szwnd)
						////////
						//sinc
						for i=1:htap
							auto x=scale*float(i)
							//auto x2=scale2*float(i)
							//v=sin(x)*sin(x2)/(x*x2)
							v=sin(x)/x
							ret[htap+i]=v
							ret[htap-i]=v
						ret[htap]=1.f
						////////
						//sharpening
						auto scale=font_sharpening
						auto lap=new float[ret.n]
						for i=1:ret.n-2
							lap[i]=ret[i]*2.f-ret[i-1]-ret[i+1]
						for i=0:ret.n-1
							ret[i]+=lap[i]*scale
						////////
						//windowing
						for i=1:htap
							auto x2=scale2*float(i)
							v=sin(x2)/x2
							ret[htap+i]*=v
							ret[htap-i]*=v
						////////
						auto wgt=0.f
						for i=0:ret.n-1
							wgt+=ret[i]
						wgt=1.f/wgt
						for i=0:ret.n-1
							ret[i]*=wgt
						return ret
					}
					box_filter=function(int aa){
						auto ret=new float[aa]
						auto val=1.f/float(aa)
						for i=0:aa-1
							ret[i]=val
						return ret
					}
					x_filter=lanczos_filter(x_aa,2)
					y_filter=lanczos_filter(y_aa,2)
					//x_filter=box_filter(x_aa)
					//y_filter=box_filter(y_aa)
					x_htaps=int(x_filter.n>>1)
					y_htaps=int(y_filter.n>>1)
					pbitmap=FTW_GetCharacterEx(pfnt.hfnt,fnt.h,x_aa,y_aa, x_filter,y_filter,x_htaps,y_htaps, embolden, ch,dims)
					w=int(dims[2])
					h=int(dims[3])
					//font_gamma_map=new int[256]
					//for i=0:255
					//	//font_gamma_map[i]=int((1.f-pow(1.f-float(i)/255.f,1.f/2.2f))*255.f)
					//	font_gamma_map[i]=int((pow(float(i)/255.f,1.f/2.2f))*255.f)
					//pad it with zeros
					rgba=new int[(w+2)*(h+2)]
					for i=0:h-1
						lbase=(i+1)*(w+2)+1
						lbase_src=i*w
						for j=0:w-1
							//rgba[lbase+j]=(font_gamma_map[int(__memory(u8,iptr(pbitmap)+lbase_src+j))]<<24)|0xffffff
							rgba[lbase+j]=(int(__memory(u8,iptr(pbitmap)+lbase_src+j))<<24)|0xffffff
					ret=new CGlyphCacheItem
					ret.bmp.rgba=rgba
					ret.bmp.w=w+2
					ret.bmp.h=h+2
					ret.x_draw=dims[0]
					ret.y_draw=dims[1]
					ret.w_draw=dims[4]
					ret.dx=dims[5]
				//assert(!!rgba)
				//assert(!!ret.bmp.rgba)
				//Writeln('>>> ',ret.bmp,' ',ch)
				ret.tex_id=CreateTransientBitmap(ret.bmp,1)
				m_glyph_cache[key]=ret
		return (ret,delta_y)
	auto DrawChar(TFont fnt, float x,float y,int C, int ch)
		(gcitem,delta_y)=CacheGlyph(fnt,ch)
		if !gcitem:
			//we don't know what it looks like, don't draw
			return
		if !gcitem.bmp.w||!gcitem.bmp.h:return
		y_final=y+gcitem.y_draw+delta_y
		if m_text_y_snap:y_final=floor(y_final+0.5f)
		_DrawBitmap(gcitem.tex_id, x+gcitem.x_draw,y_final,gcitem.w_draw,float(gcitem.bmp.h-2), C, 0)
		//Writeln(x,' ',y,' ',char(ch))
	////////////////
	TFont m_fast_glyph_cache_font
	TFastGlyphCacheItem[int] m_fast_glyph_cache
	TFastGlyphCacheItem[] m_fast_glyph_cache_ascii
	auto SetFastDrawCharFont(TFont fnt)
		if m_fast_glyph_cache_font.h!=fnt.h||m_fast_glyph_cache_font.embolden!=fnt.embolden||iptr(m_fast_glyph_cache_font.pfnt)!=iptr(fnt.pfnt):
			m_fast_glyph_cache=new TFastGlyphCacheItem[int]
			m_fast_glyph_cache_ascii=new TFastGlyphCacheItem[256]
		m_fast_glyph_cache_font=fnt
	auto FastDrawChar(float x,float y,int C, int ch)
		if u32(ch)<256u:
			ret=m_fast_glyph_cache_ascii[ch]
		else
			ret=m_fast_glyph_cache[ch]
		if !ret.gcitem&&!ret.y_final:
			(gcitem,delta_y)=CacheGlyph(m_fast_glyph_cache_font,ch)
			ret.y_final=1.f
			if gcitem:
				if !gcitem.bmp.w||!gcitem.bmp.h:
					gcitem=CGlyphCacheItem.NULL
				else
					ret.y_final=gcitem.y_draw+delta_y
			ret.gcitem=gcitem
			if u32(ch)<256u:
				m_fast_glyph_cache_ascii[ch]=ret
			else
				m_fast_glyph_cache[ch]=ret
		///////////
		gcitem=ret.gcitem
		if !gcitem:
			//we don't know what it looks like, don't draw
			return
		y_final=y+ret.y_final
		if m_text_y_snap:y_final=floor(y_final+0.5f)
		_DrawBitmap(gcitem.tex_id, x+gcitem.x_draw,y_final,gcitem.w_draw,float(gcitem.bmp.h-2), C, 0)
		//Writeln(x,' ',y,' ',char(ch))
	////////////////
	EDT_END_ELLIPSIS=1
	EDT_EXPANDTABS=2
	EDT_WORDBREAK=4
	EDT_PREFIX_TO_UNDERLINE=8
	auto GetCharacterHeight(TFont fnt)
		pfnt=fnt.pfnt
		delta_y=0.f
		if pfnt.fallbacks:
			//look up the fallback chain
			fnt_i=fnt
			foreach pfnt_i in pfnt.fallbacks
				fnt_i.pfnt=pfnt_i
				delta_y=max(delta_y,(pfnt.y_baseline_per_height-pfnt_i.y_baseline_per_height)*fnt.h)
		return fnt.h+delta_y
	auto GetFontBaseline(TFont fnt)
		pfnt=fnt.pfnt
		return pfnt.y_baseline_per_height*fnt.h
	auto SearchGlyph(CCoreFont pfnt,int ch)
		ret_tuple=(CCoreFont.NULL,0)
		if pfnt.fallbacks:
			//look up the fallback chain
			foreach pfnt_i in pfnt.fallbacks
				ret_tuple=SearchGlyph(pfnt_i,ch)
				if ret_tuple[0]:return ret_tuple
		else
			gid=FTW_GetGlyphId(pfnt.hfnt,ch)
			if gid:
				ret_tuple[0]=pfnt
				ret_tuple[1]=gid
		return ret_tuple
	auto GetCharacterAdvance(TFont fnt,int ch)
		(pfnt,gid)=SearchGlyph(fnt.pfnt,ch)
		if pfnt:
			return FTW_GetGlyphAdvance(pfnt.hfnt,fnt.h,gid)
		else
			return 0.f
	auto GetKerning(TFont fnt,int ch0,int ch1)
		(pfnt,gid)=SearchGlyph(fnt.pfnt,ch0)
		if pfnt:
			return FTW_GetKerning(pfnt.hfnt,fnt.h,ch0,ch1)
		else
			return 0.f
	auto ComputeTextLayout(TFont fnt, float w0,float h0,string s, int flags)
		//simply emulate windows drawtext
		s32=Utf8ToUnicode32(s)
		wspace=GetCharacterAdvance(fnt,int(' '))
		wtab=wspace*8.f
		hc=GetCharacterHeight(fnt)
		y_baseline=GetFontBaseline(fnt)
		y_underline=y_baseline*1.05f
		h_underline=y_baseline*0.05f
		poses=new float2[s32.n]
		x=0.f;y=0.f
		xmax=0.f
		ndrawn=s32.n
		is_underlining=0
		if flags&EDT_PREFIX_TO_UNDERLINE:
			underlines=new float4[]
		for ch,I in s32
			ch=s32[I]
			if ch=='\r':continue
			if flags&EDT_PREFIX_TO_UNDERLINE:
				if ch=='&'&&!is_underlining:
					is_underlining=1
					s32[I]=32
					continue
			if ch=='\t':
				if flags&EDT_EXPANDTABS:
					dx=min((floor(x/wtab)+1.f)*wtab,w0)-x
				else
					dx=wspace
			else if ch=='\n':
				dx=0.f
				delta_y=0.f
			else
				(gc_I,delta_y)=CacheGlyph(fnt,ch)
				if gc_I:
					dx=gc_I.dx
				else
					dx=0.f
			if x&&(x>=w0||x+dx>w0)||ch=='\n':
				xbak=x
				ybak=y
				if (flags&EDT_WORDBREAK)&&IsAlnumUnicode(ch)&&!(y+hc*2>h0):
					//don't word-wrap on the last line
					pw=I-1
					for(;pw>0;pw--)
						if poses[pw].y!=y:break
						if !IsAlnumUnicode(s32[pw]):break
					pw++
					if pw<I&&!poses[pw].x:pw=I
					if pw==I:
						wx0=x
					else
						wx0=poses[pw].x
					for j=pw:I-1
						poses[j].x-=wx0
						poses[j].y=y+hc
					x-=wx0
					if y+hc*2.f>h0:
						ndrawn=pw
						x=wx0
						break
				else
					x=0.f
				y+=hc
				if y+hc>h0:
					ndrawn=I
					x=xbak
					y=ybak
					break
				if ch=='\t':
					if flags&EDT_EXPANDTABS:
						dx=min((floor(x/wtab)+1.f)*wtab,w0)-x
				xmax=w0
			if is_underlining:
				underlines.push(float4(x,y+y_underline,dx,h_underline))
				is_underlining=0
			poses[I]=float2(x,y)
			x+=dx
			xmax=max(xmax,x)
		if ndrawn<s32.n&&(flags&EDT_END_ELLIPSIS):
			U_ELLIPSIS=0x2026
			if FTW_GetGlyphId(fnt.pfnt.hfnt,U_ELLIPSIS):
				w_remove=CacheGlyph(fnt,U_ELLIPSIS)[0].dx
				s_elli=[U_ELLIPSIS]
			else
				w_remove=CacheGlyph(fnt,int('.'))[0].dx*3.f
				s_elli=[int('.'),int('.'),int('.')]
			while ndrawn&&poses[ndrawn-1].x+w_remove>w0&&poses[ndrawn-1].y+hc*2>h0:
				ndrawn--
				x=poses[ndrawn].x
			poses_elli=new float2[s_elli.n]
			foreach ch,I in s_elli
				poses_elli[I]=float2(x,y)
				x+=CacheGlyph(fnt,ch)[0].dx
		else
			poses_elli=float2[].NULL
		ret=new TPositionedText[]
		for i=0:ndrawn-1
			ch=s32[i]
			if ch!=' '&&ch!='\t'&&ch!='\r'&&ch!='\n':
				ret.push(TPositionedText(){pos:poses[i],ch:ch})
		//Writeln(__memory(int,__cast(iptr,poses)))
		if poses_elli:
			foreach ch,I in s_elli
				ret.push(TPositionedText(){pos:poses_elli[I],ch:ch})
		//return (ret,float2(min(xmax,w0),min(y+(x?hc:0.f),h0)))
		return new CTextLayout(){chars:ret,underlines:underlines,dims:float2(min(xmax,w0),min(y+(x?hc:0.f),h0))}
	////////////////
	auto LoadImage(string data)
		w=0
		h=0
		comp=0
		surf=stbi_load_from_memory(__pointer(data.d),int(data.n),&w,&h,&comp,4)
		if !surf:return TBitmap()
		ret=new int[]
		ret.d=iptr(surf)
		ret.n=iptr(w*h)
		ret.sz=ret.n
		return TBitmap(){rgba:ret,w:w,h:h}
	////////////////
	auto CacheRR(float radius0,float arg,const is_border)
		radius=radius0
		if radius<=0.f:return 0
		if is_border==2:
			//shadow
			border_width=0.f
			filter_width=min(arg,radius*0.5f)
			key=int3(0x80000000,__float_as_int(-filter_width),__float_as_int(radius))
		else
			border_width=arg
			filter_width=0.f
			key=int3(0x80000000,is_border==1?__float_as_int(border_width):0xffffffff,__float_as_int(radius))
		ret=m_glyph_cache[key]
		if !ret:
			ret=m_glyph_cache_prev[key]
			if !ret:
				m_has_new_glyph_cache_entry=1
				rif=System.Math.ceil(radius)
				ri=int(rif)
				scale=rif/radius
				radius-=filter_width
				r2=System.Math.sqr(16.f*radius*scale)
				if is_border==1:
					rb2=System.Math.sqr(16.f*(radius-border_width)*scale)
				rgba=new int[(ri+2)*(ri+2)]
				p=0
				for y=-1:ri
					for x=-1:ri
						a=0.f
						for aa_y=0:15
							y2=System.Math.sqr(float(max(y*16+aa_y,0)))
							x2_max=r2-y2
							if !(x2_max>0.f):continue
							x_max=System.Math.sqrt(x2_max)
							if is_border==1:
								x2_max_border=rb2-y2
								if x2_max_border>=0.f:
									x_max_border=System.Math.sqrt(x2_max_border)
								else
									x_max_border=-9999.f
								a+=max(min(x_max,float((x+1)*16))-max(x_max_border,float(x*16)),0.f)
							else
								a+=max(min(x_max-float(x*16),16.f),0.f)
						a*=255.f/256.f
						rgba[p++]=(int(a)<<24)+0xffffff
				if is_border==2:
					//filter
					fwi=int(System.Math.ceil(filter_width))
					fw2=System.Math.sqr(16.f*filter_width)
					flg=fwi*2+1
					fbuf=new float[flg*flg]
					for fy=0:fwi
						for fx=0:fwi
							a=0.f
							for aa_y=0:15
								y2=System.Math.sqr(float(max(fy*16+aa_y,0)))
								x2_max=fw2-y2
								if !(x2_max>0.f):continue
								x_max=System.Math.sqrt(x2_max)
								a+=max(min(x_max-float(fx*16),16.f),0.f)
							a*=(1.f/256.f)
							fbuf[flg*(-fy+fwi)+(-fx+fwi)]=a
							fbuf[flg*(-fy+fwi)+(fx+fwi)]=a
							fbuf[flg*(fy+fwi)+(-fx+fwi)]=a
							fbuf[flg*(fy+fwi)+(fx+fwi)]=a
					nmlz=1.f/[d foreach d in fbuf].Sum()
					foreach d,I in fbuf
						fbuf[I]*=nmlz
					sz=ri+2
					rgba2=new int[sz*sz]
					for y=0:sz-1
						for x=0:sz-1
							acc=float4(0.f,0.f,0.f,0.f)
							pf=0
							for fy=-fwi:fwi
								addr=min(max(y+fy,0),sz-1)*sz
								for fx=-fwi:fwi
									C=rgba[addr+min(max(x+fx,0),sz-1)]
									wt=fbuf[pf]
									for i in crange(4)
										acc[i]+=float((C>>(i*8))&255)*wt
									pf++
							C=0
							for i in crange(4)
								C+=max(min(int(acc[i]),255),0)<<(i*8)
							rgba2[y*sz+x]=C
					rgba=rgba2
				ret=new CGlyphCacheItem
				ret.bmp.rgba=rgba
				ret.bmp.w=ri+2
				ret.bmp.h=ri+2
			ret.tex_id=CreateTransientBitmap(ret.bmp,1)
			//rgba_edge=new int[]
			//for i=0:2
			//	rgba_edge.push(ret.bmp.rgba[0:ret.bmp.w-1])
			//tex_id2=CreateTransientBitmap(TBitmap(){rgba:rgba_edge,w:ret.bmp.w,h:3},1)
			//tex_id2=CreateTransientBitmap(TBitmap(){rgba:ret.bmp.rgba[1:ret.bmp.w-2],w:ret.bmp.w-2,h:1},0)
			//assert(tex_id2==ret.tex_id+1)
			//tex_id2=CreateTransientBitmap(TBitmap(){rgba:ret.bmp.rgba[1:ret.bmp.w-2],w:1,h:ret.bmp.w-2},0)
			m_glyph_cache[key]=ret
		return ret.tex_id
	auto Draw3x3(float x00,float y00,float w,float h,float radius, int bmpid,JSObject obj,string sname,int is_border)
		//the bmp is dynamic
		//we need 16 points
		struct T3x3Point
			float x,y
			float u,v
			int C
		points=new T3x3Point[16]
		xs=float4(0.f,radius,w-radius,w)+float4(x00,x00,x00,x00)
		ys=float4(0.f,radius,h-radius,h)+float4(y00,y00,y00,y00)
		ri=System.Math.ceil(radius)
		us=float4(1.f,0.f,0.f,1.f)
		vs=float4(1.f,0.f,0.f,1.f)
		for y in crange(4)
			for x in crange(4)
				points[y*4+x].x=xs[x]
				points[y*4+x].y=ys[y]
				points[y*4+x].u=us[x]
				points[y*4+x].v=vs[y]
		if obj[sname].has(0):
			inline lerp(a,b,t){return a+(b-a)*t}
			//gradient - compute C at the points
			p0x=obj[sname][0]["x"].as(float)
			p0y=obj[sname][0]["y"].as(float)
			p0=float2(p0x,p0y)
			p1x=obj[sname][1]["x"].as(float)
			p1y=obj[sname][1]["y"].as(float)
			p1=float2(p1x,p1y)
			C0=obj[sname][0]["color"].or(-1)
			C1=obj[sname][1]["color"].or(-1)
			dt=p1-p0
			//Writeln(p0,' ',p1,' ',formatNumber(C0,{align:8,base:16}),' ',formatNumber(C1,{align:8,base:16}))
			dt=dt/(float2(w,h)*sqr(dt))
			p0=p0*float2(w,h)+float2(x00,y00)
			gamma=m_gamma
			inv_gamma=1.f/m_gamma
			for i=0:15
				t=dot(float2(points[i].x,points[i].y)-p0,dt)
				C_i=0
				for j in crange(4)
					f0=float((C0>>(j*8))&0xff)*(1.f/255.f)
					f1=float((C1>>(j*8))&0xff)*(1.f/255.f)
					if gamma!=1.f&&j!=3:
						f0=pow(f0,gamma)
						f1=pow(f1,gamma)
						f=min(max(lerp(f0,f1,t),0.f),1.f)
						f=pow(f,inv_gamma)
					else
						f=lerp(f0,f1,t)
					C_i+=max(min(int(f*255.f),255),0)<<(j*8)
				points[i].C=C_i
		else
			//solid color
			C=obj[sname].or(-1)
			for i=0:15
				points[i].C=C
		//draw the quads
		inline f2i_P(float f)
			return max(min(int(f*float(m_crd16_scale)),65535),0)
		inline f2i_uv(float f)
			return max(min(int(f*32768.f),65535),0)
		for y=0:2
			for x=0:2
				if is_border&&x==1&&y==1:continue
				x0=points[y*4+x].x
				y0=points[y*4+x].y
				x1=points[(y+1)*4+(x+1)].x
				y1=points[(y+1)*4+(x+1)].y
				u0=points[y*4+x].u
				v0=points[y*4+x].v
				u1=points[(y+1)*4+(x+1)].u
				v1=points[(y+1)*4+(x+1)].v
				C0=points[y*4+x].C
				C1=points[y*4+(x+1)].C
				C2=points[(y+1)*4+(x+1)].C
				C3=points[(y+1)*4+x].C
				//else if x==1:
				//	bmpid_xy=bmpid//+2
				//else if y==1:
				//	bmpid_xy=bmpid//+1
				if y==1&&x==1:
					bmpid_xy=-1
				else
					bmpid_xy=bmpid
				//clipping
				if x0<m_clip.x:
					dx=m_clip.x-x0
					t=dx/(x1-x0)
					x0=m_clip.x
					du=(u1-u0)*t
					u0+=du
				if m_clip.z<x1:
					dx=m_clip.z-x1
					t=dx/(x1-x0)
					x1=m_clip.z
					du=(u1-u0)*t
					u1+=du
				if !(x1>x0):continue
				if y0<m_clip.y:
					dy=m_clip.y-y0
					t=dy/(y1-y0)
					y0=m_clip.y
					dv=(v1-v0)*t
					v0+=dv
				if m_clip.w<y1:
					dy=m_clip.w-y1
					t=dy/(y1-y0)
					y1=m_clip.w
					dv=(v1-v0)*t
					v1+=dv
				if !(y1>y0):continue
				n0=m_vbo.n
				m_vbo.resize(n0+VERTEX_SIZE*4)
				ix0=f2i_P(x0)
				iy0=f2i_P(y0)
				iu0=f2i_uv(u0)
				iv0=f2i_uv(v0)
				ix1=f2i_P(x1)
				iy1=f2i_P(y1)
				iu1=f2i_uv(u1)
				iv1=f2i_uv(v1)
				if bmpid_xy==-1:
					//all 0.f anyway, should work as is
					m_vbo[n0+(VERTEX_SIZE*0+0)]=((iy0)<<16)+(ix0)
					m_vbo[n0+(VERTEX_SIZE*0+1)]=((iv0)<<16)+(iu0)
					m_vbo[n0+(VERTEX_SIZE*0+2)]=C0
					m_vbo[n0+(VERTEX_SIZE*1+0)]=((iy0)<<16)+(ix1)
					m_vbo[n0+(VERTEX_SIZE*1+1)]=((iv0)<<16)+(iu1)
					m_vbo[n0+(VERTEX_SIZE*1+2)]=C1
					m_vbo[n0+(VERTEX_SIZE*2+0)]=((iy1)<<16)+(ix1)
					m_vbo[n0+(VERTEX_SIZE*2+1)]=((iv1)<<16)+(iu1)
					m_vbo[n0+(VERTEX_SIZE*2+2)]=C2
					m_vbo[n0+(VERTEX_SIZE*3+0)]=((iy1)<<16)+(ix0)
					m_vbo[n0+(VERTEX_SIZE*3+1)]=((iv1)<<16)+(iu0)
					m_vbo[n0+(VERTEX_SIZE*3+2)]=C3
				else
					vdata=int4(((iy0)<<16)+(ix0),((iy1)<<16)+(ix1),((iv0)<<16)+(iu0),((iv1)<<16)+(iu1))
					m_StretchDIBits_calls.push(TStretchDIBits(){vdata:vdata,hwnd:m_hwnd,bmpid:bmpid_xy,C:int4(C0,C1,C2,C3),pos:int(n0)})
g_renderer=new CRenderer

////////////////////////////////////////////
//the timer stuff
SDL_SetInterval=__c_function(int,"SDL_SetInterval","sdl_timerw.h", "c_files","sdl_timerw.c")
SDL_ClearInterval=__c_function(int,"SDL_ClearInterval","sdl_timerw.h", "c_files","sdl_timerw.c")
//TIMER_EVENT_ID=2
FUIExtension=function(JSObject JS_UI,CUISandbox sbox,int is_real)
g_ui_exts=new FUIExtension[]
inline registerUIExtension(f)
	g_ui_exts.push(f)

auto createUIObject(JSObject JS_UI,CUISandbox sbox,int is_real)
	if is_real:
		g_renderer.InitFonts()
	///////////////
	auto JS=JS_UI.GetContext()
	JS_UI["fallback_font_names"]=g_renderer.m_std_fallback_fonts
	//js_fonts=JS.NewArray()
	//foreach sfont,I in g_renderer.m_std_fallback_fonts
	//	js_fonts[I]=sfont
	JS_UI["is_real"]=is_real
	JS_UI["is_mobile"]=Platform.IS_MOBILE
	obj_platform=JS.New()
	s_arch=Platform.ARCH;obj_platform["ARCH"]=s_arch
	s_build=Platform.BUILD;obj_platform["BUILD"]=s_build
	JS_UI["Platform"]=obj_platform
	if is_real:
		//"privileged" functions
		JS_UI["DrawWindow"]=function(JSContext JS){
			hwnd=JS.Param(0).or(NULL)
			g_renderer.DrawWindow(hwnd,float2(0.f,0.f),float2(1.f,1.f))
			return 0
		}
		JS_UI["DrawCaret"]=function(JSContext JS){
			x=JS.Param(0).or(0.f)
			y=JS.Param(1).or(0.f)
			w=JS.Param(2).or(0.f)
			h=JS.Param(3).or(0.f)
			C=JS.Param(4).or(0)
			if w>0.f&&h>0.f&&(C&0xff000000):
				g_renderer.DrawCaret(x,y,w,h,C)
			return 0
		}
		JS_UI["ResetRenderer"]=function(JSContext JS){
			g_renderer.SetScalingFactor(JS.Param(0).or(1.f))
			g_renderer.m_gamma=JS.Param(1).or(g_renderer.m_gamma)
			return 0
		}
		JS_UI["SetPixelsPerUnit"]=function(JSContext JS){
			g_renderer.m_pixels_per_unit=JS.Param(0).or(g_renderer.m_pixels_per_unit)
			return 0
		}
		JS_UI["BeginFrame"]=function(JSContext JS){
			g_renderer.BeginFrame()
			return 0
		}
		JS_UI["EndFrame"]=function(JSContext JS){
			g_renderer.EndFrame()
			JS_UI["frame_time"]=System.Time.TicksToSeconds(g_renderer.m_frame_ticks);
			return 0
		}
		JS_UI["BeginPaint"]=function(JSContext JS){
			auto hwnd=JS.Param(0).or(NULL)
			w=0
			h=0
			SDL.detail.SDL_GL_GetDrawableSize(hwnd,&w,&h)
			if !w||!h:return 0
			g_renderer.BeginPaint(hwnd,f32(w),f32(h))
			obj=JS.Param(1).as(JSObject)
			if obj:
				obj["w"]=f32(w)/g_renderer.m_pixels_per_unit
				obj["h"]=f32(h)/g_renderer.m_pixels_per_unit
				obj["w_in_pixels"]=w
				obj["h_in_pixels"]=h
			return 0
		}
		JS_UI["_SwitchToSubWindow"]=function(JSContext JS){
			x=int(ceil(JS.Param(0).or(0.f)))
			y=int(ceil(JS.Param(1).or(0.f)))
			w=int(floor(JS.Param(2).or(0.f)))
			h=int(floor(JS.Param(3).or(0.f)))
			is_relative=JS.Param(4).or(0)
			is_pop=JS.Param(5).or(0)
			g_renderer.SwitchToSubWindow(x,y,w,h,is_relative,is_pop)
			return 0
		}
		//can't do that: we're not in GL when calling
		/*JS_UI["_GetCurrentSubWindow"]=function(JSContext JS){
			prev_viewport=new int[4]
			glGetIntegerv(GL_VIEWPORT,__pointer(prev_viewport.d));
			ww=0
			hw=0
			SDL.detail.SDL_GL_GetDrawableSize(g_renderer.m_hwnd,&ww,&hw)
			x=prev_viewport[0]
			y=prev_viewport[1]
			w=prev_viewport[2]
			h=prev_viewport[3]
			y=hw-y-h
			ret=JS.NewArray()
			ret[0]=float(x)/g_renderer.m_pixels_per_unit
			ret[1]=float(y)/g_renderer.m_pixels_per_unit
			ret[2]=float(w)/g_renderer.m_pixels_per_unit
			ret[3]=float(h)/g_renderer.m_pixels_per_unit
			return JS.Return(ret)
		}*/
		JS_UI["InsertJSDrawCall"]=function(JSContext JS){
			auto js_callback=JS.Param(0).as(JSObject)
			if !js_callback:return 0
			g_renderer.InsertJSDrawCall(js_callback)
			return 0
		}
	else
		//virtualized SDL_CreateWindow and BeginPaint
		JS_UI["SDL_CreateWindow"]=function(JSContext JS){
			w=JS.Param(3).or(1024)
			h=JS.Param(4).or(768)
			return JS.Return(new CSandboxWindow(){w:w,h:h})
		}
		JS_UI["BeginPaint"]=function(JSContext JS){
			auto hwnd=JS.Param(0).as(CSandboxWindow)
			if !hwnd:return 0
			//we need to match the ultimate viewport size, thus the ceil
			w=ceil(f32(hwnd.w)*g_renderer.m_pixels_per_unit)
			h=ceil(f32(hwnd.h)*g_renderer.m_pixels_per_unit)
			g_renderer.BeginPaint(__pointer(iptr(hwnd)),w,h)
			obj=JS.Param(1).as(JSObject)
			if obj:
				obj["w"]=f32(hwnd.w)
				obj["h"]=f32(hwnd.h)
			return 0
		}
	JS_UI["EndPaint"]=function(JSContext JS){
		g_renderer.EndPaint()
		return 0
	}
	//////////////////
	//todo: dynamic bmp drawing - create an object, store cached dynid in there, wipe at BeginFrame
	if is_real:
		JS_UI["DrawBitmap"]=function(JSContext JS){
			bmpid=JS.Param(0).or(0)
			w=JS.Param(3).as(float)
			h=JS.Param(4).as(float)
			if !w:w=float(g_renderer.m_static_original_sizes[bmpid].x)
			if !h:h=float(g_renderer.m_static_original_sizes[bmpid].y)
			g_renderer.DrawBitmap(bmpid,
				JS.Param(1).as(float)*g_renderer.m_pixels_per_unit,JS.Param(2).as(float)*g_renderer.m_pixels_per_unit,
				w*g_renderer.m_pixels_per_unit,h*g_renderer.m_pixels_per_unit,
				int(JS.Param(5).or(u32(-1))))
			return 0
		}
		JS_UI["GetBitmapSize"]=function(JSContext JS){
			bmpid=JS.Param(0).or(0)
			obj=JS.Param(1).as(JSObject)
			if obj:
				obj["w_bmp"]=double(g_renderer.m_static_original_sizes[bmpid].x)
				obj["h_bmp"]=double(g_renderer.m_static_original_sizes[bmpid].y)
			return 0
		}
	JS_UI["PushCliprect"]=function(JSContext JS){
		x=JS.Param(0).as(float)*g_renderer.m_pixels_per_unit
		y=JS.Param(1).as(float)*g_renderer.m_pixels_per_unit
		w=JS.Param(2).as(float)*g_renderer.m_pixels_per_unit
		h=JS.Param(3).as(float)*g_renderer.m_pixels_per_unit
		g_renderer.PushCliprect(x,y,w,h)
		return 0
	}
	JS_UI["PopCliprect"]=function(JSContext JS){
		g_renderer.PopCliprect()
		return 0
	}
	JS_UI["GetCliprect"]=function(JSContext JS){
		ret=JS.New()
		ret["x"]=g_renderer.m_clip.x/g_renderer.m_pixels_per_unit
		ret["y"]=g_renderer.m_clip.y/g_renderer.m_pixels_per_unit
		ret["w"]=g_renderer.m_clip.z/g_renderer.m_pixels_per_unit
		ret["h"]=g_renderer.m_clip.w/g_renderer.m_pixels_per_unit
		return JS.Return(ret)
	}
	//////////////////
	JS_UI["CreateCoreFontByName"]=function(JSContext JS){
		return JS.Return(g_renderer.CreateCoreFontByName(sbox,JS.Param(0).as(string)))
	}
	JS_UI["SetRetardedWindingOrder"]=function(JSContext JS){
		pfnt=JS.Param(0).as(CCoreFont)
		if !pfnt:return 0
		FTW_SetRetardedWindingOrder(pfnt.hfnt)
		return 0
	}
	JS_UI["CreateCoreFontChain"]=function(JSContext JS){
		arr=JS.Param(0).as(JSObject)
		n=arr.length()
		narr=new CCoreFont[]
		for i=0:n-1
			narr_i=arr[i].as(CCoreFont)
			if narr_i:
				narr.push(narr_i)
		if narr.n:
			return JS.Return(g_renderer.CreateCoreFontChain(narr))
		else
			return 0
	}
	JS_UI["CoreFontToFont"]=function(JSContext JS){
		pfnt=JS.Param(0).as(CCoreFont)
		if !pfnt:return 0
		h=JS.Param(1).as(float)
		embolden=JS.Param(2).as(int)
		ret=g_renderer.CreateFont(pfnt,h,embolden)
		assert(!!ret.pfnt)
		return JS.Return(ret)
	}
	JS_UI["GetFontHeight"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(fnt.h)
	}
	JS_UI["_LayoutText"]=function(JSContext JS){
		//just separate text creation and draw
		attrs=JS.Param(0).as(JSObject)
		if !attrs:return 0
		fnt=attrs["font"].as(TFont)
		fnt.h*=g_renderer.m_pixels_per_unit
		if !fnt.pfnt:return 0
		w=attrs["w"].or(1e18f)*g_renderer.m_pixels_per_unit
		h=attrs["h"].or(1e18f)*g_renderer.m_pixels_per_unit
		s=attrs["text"].as(string)
		if !s:return 0
		flags=attrs["flags"].or(g_renderer.EDT_EXPANDTABS|g_renderer.EDT_WORDBREAK)
		layout=g_renderer.ComputeTextLayout(fnt, w,h,s, flags)
		dims=layout.dims
		attrs["w_text"]=dims.x/g_renderer.m_pixels_per_unit
		attrs["h_text"]=dims.y/g_renderer.m_pixels_per_unit
		attrs["__layout"]=layout
		return 0
	}
	JS_UI["DrawTextControl"]=function(JSContext JS){
		attrs=JS.Param(0).as(JSObject)
		x0=JS.Param(1).or(0.f)*g_renderer.m_pixels_per_unit
		y0=JS.Param(2).or(0.f)*g_renderer.m_pixels_per_unit
		C=JS.Param(3).or(u32(-1))
		layout=attrs["__layout"].as(CTextLayout)
		if !layout:return 0
		fnt=attrs["font"].as(TFont)
		fnt.h*=g_renderer.m_pixels_per_unit
		if !fnt.pfnt:return 0
		foreach li in layout.chars
			fnt_li=fnt
			if g_renderer.m_srgb_supported:
				fnt_li.SmartEmbolden(li.ch)
			g_renderer.DrawChar(fnt_li,x0+li.pos.x,y0+li.pos.y,int(C),li.ch)
		if layout.underlines:
			foreach ul in layout.underlines
				g_renderer.DrawBitmap(0, x0+ul.x,y0+ul.y,ul.z,ul.w, int(C))
		return 0
	}
	JS_UI["DrawChar"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		fnt.h*=g_renderer.m_pixels_per_unit
		if !fnt.pfnt:return 0
		x0=JS.Param(1).or(0.f)*g_renderer.m_pixels_per_unit
		y0=JS.Param(2).or(0.f)*g_renderer.m_pixels_per_unit
		C=JS.Param(3).or(u32(-1))
		ch=JS.Param(4).or(32)
		g_renderer.DrawChar(fnt,x0,y0,int(C),ch)
		return 0
	}
	JS_UI["RoundRect"]=function(JSContext JS){
		obj=JS.Param(0).as(JSObject)
		if !obj:return 0
		radius=obj["round"].or(0.f)*g_renderer.m_pixels_per_unit
		border_width=obj["border_width"].or(0.f)*g_renderer.m_pixels_per_unit
		w=obj["w"].or(0.f)*g_renderer.m_pixels_per_unit
		h=obj["h"].or(0.f)*g_renderer.m_pixels_per_unit
		eff_radius=max(min(radius,min(w,h)*0.5f),border_width)
		if border_width<0.f:
			//shadowed
			bmpid=g_renderer.CacheRR(eff_radius,-border_width,2)
		else
			bmpid=g_renderer.CacheRR(eff_radius,0.f,0)
		x=obj["x"].or(0.f)*g_renderer.m_pixels_per_unit
		y=obj["y"].or(0.f)*g_renderer.m_pixels_per_unit
		g_renderer.Draw3x3(x,y,w,h,eff_radius, bmpid,obj,"color",0)
		if border_width>0.f:
			bmpid=g_renderer.CacheRR(eff_radius,border_width,1)
			g_renderer.Draw3x3(x-border_width*0.5f,y-border_width*0.5f,w+border_width,h+border_width,eff_radius, bmpid,obj,"border_color",1)
		return JS.Return(obj)
	}
	//////////////////
	if is_real:
		JS_UI["LoadPackedTexture"]=function(JSContext JS){
			//todo: create a jsobject of the file names, set mipmap name in debug mode
			//resource loading... inner loadResourceFile
			return 0
		}
		JS_UI["LoadStaticImages"]=function(JSContext JS){
			obj=JS.Param(0).as(JSObject)
			if obj:
				//g_ui_search_paths and the zip
				foreach sdir in sbox.m_ui_search_paths.ReverseOrder()
					foreach fnimage in System.IO.EnumFiles(sdir+"*",System.IO.ENUM_FILE|System.IO.ENUM_RECURSIVE)
						if fnimage.ToLower().EndsWith(".png")
							fn_nmlz=fnimage.Replace(["\\","/"]).ToLower()
							if obj.has(fn_nmlz):continue
							sdata=System.IO.ReadAll(fnimage)
							if sdata:
								bmp=g_renderer.LoadImage(sdata)
								obj[fn_nmlz]=g_renderer.LoadStaticBitmap(bmp)
				if sbox.m_ui_zip:
					foreach fnimage in sbox.m_ui_zip.AllFileNames()
						if fnimage.ToLower().EndsWith(".png")
							fn_nmlz=fnimage.Replace(["\\","/"]).ToLower()
							if obj.has(fn_nmlz):continue
							sdata=sbox.m_ui_zip.ReadAll(fnimage)
							if sdata:
								bmp=g_renderer.LoadImage(sdata)
								obj[fn_nmlz]=g_renderer.LoadStaticBitmap(bmp)
			return 0
		}
	///////////////////////////////////
	//misc GL
	if is_real:
		JS_UI["Clear"]=function(JSContext JS){
			C_clear=JS.Param(0).or(u32(-1))
			c0=f32(C_clear&0xffu)/255.f
			c1=f32((C_clear>>8)&0xffu)/255.f
			c2=f32((C_clear>>16)&0xffu)/255.f
			g_renderer.TestSRGB()
			if g_renderer.m_gamma!=1.f&&g_renderer.m_srgb_supported:
				c0=pow(c0,g_renderer.m_gamma)
				c1=pow(c1,g_renderer.m_gamma)
				c2=pow(c2,g_renderer.m_gamma)
			glClearColor(c0,c1,c2,f32(C_clear>>24)/255.f)
			glClearDepthf(1.f)
			glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT)
			return 0
		}
		JS_UI["SetFontSharpening"]=function(JSContext JS){
			g_renderer.m_font_sharpening=JS.Param(0).or(0.f)
			g_renderer.m_glyph_cache_invalidated=1
			return 0
		}
	else
		JS_UI["Clear"]=function(JSContext JS){
			C_clear=JS.Param(0).or(u32(-1))
			g_renderer.DrawBitmap(0, 0.f,0.f,g_renderer.m_window_w,g_renderer.m_window_h, int(C_clear))
			return 0
		}
	JS_UI["GetSRGBStatus"]=function(JSContext JS){
		ret=JS.New()
		ret["gamma"]=g_renderer.m_gamma
		ret["srgb_supported"]=g_renderer.m_srgb_supported
		return JS.Return(ret)
	}
	///////////////////////////////////
	JS_UI["GetCharacterHeight"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(g_renderer.GetCharacterHeight(fnt))
	}
	JS_UI["GetCharacterAdvance"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		if !fnt.pfnt:return 0
		return JS.Return(g_renderer.GetCharacterAdvance(fnt,JS.Param(1).or(int(' '))))
	}
	JS_UI["MeasureText"]=function(JSContext JS){
		fnt=JS.Param(0).as(TFont)
		stext=JS.Param(1).as(string)
		if !fnt.pfnt||!stext:return 0
		x=0.f
		y=0.f
		w=0.f
		hc=g_renderer.GetCharacterHeight(fnt)
		foreach ch in Utf8ToUnicode32(stext)
			if ch=='\n':
				w=max(w,x)
				x=0.f
				y+=hc
			x+=g_renderer.GetCharacterAdvance(fnt,ch)
		w=max(w,x)
		ret=JS.New()
		ret["w"]=w
		ret["h"]=(y+hc)
		return JS.Return(ret)
	}
	///////////////////////////////////
	//timer
	if is_real:
		timer_user_data=new JSObject[int]
		sdl_badapi_hack_callback_to_timer_id=new int[iptr]
		JS_UI["setInterval"]=function(JSContext JS){
			fn=JS.Param(0).as(JSObject)
			if !fn:return 0
			interval=JS.Param(1).as(int)
			if !(interval>0):return 0
			timer_id=SDL_SetInterval(interval,__pointer(fn));
			timer_user_data[timer_id]=fn
			sdl_badapi_hack_callback_to_timer_id[iptr(fn)]=timer_id
			return JS.Return(timer_id)
		}
		JS_UI["clearInterval"]=function(JSContext JS){
			timer_id=JS.Param(0).as(int)
			fn=timer_user_data[timer_id]
			if !fn:return 0
			sdl_badapi_hack_callback_to_timer_id[iptr(fn)]=0
			SDL_ClearInterval(timer_id,__pointer(fn));
			timer_user_data[timer_id]=JSObject.NULL
			return JS.Return(1)
		}
		JS_UI["getTimerFunction"]=function(JSContext JS){
			timer_id=JS.Param(0).as(__pointer)
			if !timer_id:return 0
			fn=timer_user_data[sdl_badapi_hack_callback_to_timer_id[iptr(timer_id)]]
			if !fn:return 0
			return JS.Return(fn)
		}
	foreach f in g_ui_exts
		f(JS_UI,sbox,is_real)
	return JS_UI

auto inflate(string sin)
	outlen=0
	ptr_ret=stbi_zlib_decode_noheader_malloc(__pointer(sin.d),sin.n, &outlen);
	ret=new string
	ret.d=iptr(ptr_ret)
	ret.n=iptr(outlen)
	ret.sz=iptr(outlen)
	return ret
	
class CZipItem
	string dat
	int method
class CZipFile
	string dat
	compressed_files=new CZipItem[string]
	auto ReadAll(string fname0)
		fname=fname0.Replace(["\\","/"]).ToLower()
		item=compressed_files[fname]
		if !item:return string.NULL
		return item.method==0?item.dat:inflate(item.dat)
	inline AllFileNames()
		return {forEach:inline(fbody){
			foreach d,k,I in compressed_files
				fbody(k,d,I)
		}}
auto ParseZip(string dat)
	MAX_COMMENT=65535
	if dat.n<22:return CZipFile.NULL
	ret=new CZipFile(){dat:dat}
	ptail=-1L
	for j=0:MAX_COMMENT
		if dat.n<22+j:break
		pos=dat.n-22-j
		if dat.substr(pos,4)=="PK\005\006":
			ptail=pos
			break
	if ptail<0L:
		if Platform.BUILD=="debug":
			Writeln('unable to parse zip file, size=',dat.n)
		return CZipFile.NULL
	nfiles=iptr(dat.ReadAt(ptail+10,u16))
	ofs=iptr(dat.ReadAt(ptail+16,u32))
	if uptr(ofs)>=uptr(dat.n):return CZipFile.NULL
	for i=0:nfiles-1
		pos0=ofs
		if uptr(pos0+46L)>=uptr(dat.n):return NULL
		nmk=dat.ReadAt(pos0+28L,u16,3)
		szcrap=iptr(nmk[0])+iptr(nmk[1])+iptr(nmk[2])
		ofs_local=iptr(dat.ReadAt(pos0+42L,u32))
		if uptr(pos0+46L+szcrap)>=uptr(dat.n):return NULL
		////////////
		if uptr(ofs_local+30L)>=uptr(dat.n)||uptr(ofs_local)>=uptr(dat.n):return NULL
		method=int(dat.ReadAt(ofs_local+8L,i16))
		szdata=iptr(dat.ReadAt(ofs_local+18L,u32))
		szname=iptr(dat.ReadAt(ofs_local+26L,u16))
		szextra=iptr(dat.ReadAt(ofs_local+28L,u16))
		if uptr(ofs_local+30L+szname)>=uptr(dat.n):return NULL
		sname=dat.substr(ofs_local+30L,szname)
		pfiledata=ofs_local+30L+szname+szextra
		sname=sname.Replace(["\\","/"]).ToLower()
		ret.compressed_files[sname]=new CZipItem(){dat:dat[pfiledata:pfiledata+szdata-1],method:method}
		////////////
		ofs=pos0+46L+szcrap
	return ret

auto setupModuleSystem(JSContext JS,int is_real)
	__generate_json("include_js","res_zip.js")
	__generate_json("js_units","gui2d/ui.js")
	__generate_json("js_units","gui2d/widgets.js")
	sbox=new CUISandbox
	global=JS.GetGlobal()
	global["Duktape"]["__ui_native_hack"]=function(JSContext JS){
		mod_obj=JS.Param(0).as(JSObject)
		if !mod_obj:return 0
		createUIObject(mod_obj,sbox,is_real)
		if is_real: 
			createSDLJSObject(mod_obj,0)
			///////
			//smart texture size
			pmode=__C(__pointer,"@decl:SDL_DisplayMode @1={0}")
			SDL.detail.SDL_GetCurrentDisplayMode(0,pmode)
			w=__C(int,"((SDL_DisplayMode*)@1)->w",pmode)
			h=__C(int,"((SDL_DisplayMode*)@1)->h",pmode)
			m_texture_width=max(promoteToTextureSize(max(w,h)),1024)
			__C(int,"@global:int s7_CB_SDLEventFilter(void* userdata, SDL_Event* pevent){\n\
				if(pevent->type==SDL_WINDOWEVENT&&pevent->window.event==SDL_WINDOWEVENT_CLOSE){\n\
					SDL_Event event_virtual_close;\n\
					memset(&event_virtual_close,0,sizeof(event_virtual_close));\n\
					event_virtual_close.user.windowID=pevent->window.windowID;\n\
					event_virtual_close.user.code=1;\n\
					event_virtual_close.type=SDL_USEREVENT;\n\
					SDL_PushEvent(&event_virtual_close);\n\
					return 0;\n\
				}\n\
				return 1;\n\
			}")
			__C(int,"SDL_SetEventFilter(s7_CB_SDLEventFilter,NULL)")
		return 0
	}
	global["Duktape"]["__ui_load_zip"]=function(JSContext JS){
		s_path=JS.Param(0).or("")
		sbox.UILoadZip(s_path)
		return 0
	}
	global["Duktape"]["__ui_add_path"]=function(JSContext JS){
		s_path=JS.Param(0).or("")
		sbox.m_ui_search_paths.push(s_path+"/")
		return 0
	}
	//todo: sandbox search paths
	global["Duktape"]["modSearch"]=function(JSContext JS){
		s_modname=JS.Param(0).or("")
		s_fname=(s_modname+".js").ToLower()
		sret=sbox.UIReadAll(s_fname)
		if !sret:
			return JS.ReturnError("cannot find module '@1'".Replace(["@1",s_modname]))
		else
			return JS.Return(sret)
	}
	//timing for animation... i64 stored as boxed object
	global["Duktape"]["__ui_get_tick"]=function(JSContext JS){
		return JS.Return(System.Time.tick64())
	}
	global["Duktape"]["__ui_seconds_between_ticks"]=function(JSContext JS){
		return JS.Return(System.Time.TicksToSeconds(JS.Param(1).or(0LL)-JS.Param(0).or(0LL)))
	}
	global["Duktape"]["__byte_length"]=function(JSContext JS){
		lg=0L
		duktape.duk_dup(JS._ctx(),0)
		duktape.duk_to_lstring(JS._ctx(),-1,&lg)
		duktape.duk_pop(JS._ctx())
		return JS.Return(lg)
	}
	global["Duktape"]["__write_log"]=function(JSContext JS){
		if Platform.BUILD=="debug":
			Writeln(JS.Param(0).or(""))
		return JS.Return(0)
	}
	return sbox

}//module

setupModuleSystem=Gui2D.detail.setupModuleSystem
registerUIExtension=Gui2D.detail.registerUIExtension
registerRenderingHook=inline(a){Gui2D.detail.g_renderer.m_hooks.push(getInterface(a,Gui2D.detail.IRendererHook))}
CUISandbox=Gui2D.detail.CUISandbox
CSandboxWindow=Gui2D.detail.CSandboxWindow

auto ProvideGLFunctions()
	registerUIExtension(function(JSObject JS_UI,CUISandbox sbox,int is_real){
		if is_real:
			createGLJSObject(JS_UI)
			JS_UI["GetCurrentWindowSize"]=function(JSContext JS){
				ret=JS.New()
				ret[0]=Gui2D.detail.g_renderer.m_window_w*Gui2D.detail.g_renderer.m_pixels_per_unit
				ret[1]=Gui2D.detail.g_renderer.m_window_h*Gui2D.detail.g_renderer.m_pixels_per_unit
				return JS.Return(ret)
			}
	})

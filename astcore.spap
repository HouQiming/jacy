//coulddo: whether s7rc is necessary
import "system.spap"
import "ctobj.spap"
import "util.spap"
import System.Algorithm.*
import System.Console.*
import System.Math.*
import Util.*
import Ctobj.*

ENABLE_FEM_DSL=1
ENABLE_GVN=1
ENABLE_DEADELIM=1
DEBUG_MONITOR_REACH=0
DEBUG_REACH_LOG=0
DEBUG_EVAL_LOG=0
DEBUG_DUMP_RC=0
DEBUG_DUMP_FLATTEN=0
DEBUG_DUMP_USER_FLAGS=0
DEBUG_DUMP_DERIV=0
DEBUG_TRAP_MEMBER_NOT_FOUND=0
DEBUG_DUMP_SSA=0
DEBUG_DUMP_DEADELIM=0
DEBUG_DUMP_PASSES=1//todo
DEBUG_DUMP_GVN_DETAILS=0
DEBUG_DUMP_SCCP=0
///////////////
DERIV_HAS_REUSABLE_COMPONENTS=0x80000000

fcompiler_callback=function(PExpression,int):TSCCPValue

g_inited_astcore=0
//g_builtin_scope=PCTObject(0)
g_cbobj_reach_fn_only=PCTObject(0)
g_cbobj_expand_inline_oneval=PCTObject(0)
g_cbobj_function_used_oneval=PCTObject(0)
g_cbobj_template_instantiation_oneval=PCTObject(0)
g_cbobj_generated_function_oncgen=PCTObject(0)
g_cbobj_cimport_cgen=PCTObject(0)

fdummy_callback=function(PExpression pecall,int expr_oplevel){return TSCCPValue(){'tid':g_vtid_UNINIT}}

auto citeexpr(PExpression pe)
	epos0=readPool(pe+1)
	epos1=readPool(pe+2)
	if !epos0:
		return dumpExpr(pe,fcolorer_callback.NULL)
	if epos1<0:
		paepos=epos0
		for(;;)
			assert(readPool(paepos)==g_tid_TAdvancedEpos)
			epos0=readPool(paepos+1)
			epos1=readPool(paepos+2)
			if epos0&0x80000000:
				paepos=epos1
			else
				break
	return cite_raw(epos0,epos1)

auto errorAtAEPos(int type0,PCTObject paepos0,string serr0)
	type=type0
	paepos=paepos0
	serr=serr0
	if Platform.BUILD=="debug":
		arv=new int[int]
	while paepos:
		if Platform.BUILD=="debug":
			if arv[paepos]:
				Writeln('epos loop! ',paepos)
				assert(0)
			arv[paepos]=1
		assert(readPool(paepos)==g_tid_TAdvancedEpos)
		epos0=readPool(paepos+1)
		epos1=readPool(paepos+2)
		if epos0&0x80000000:
			//it's an inline nested thing
			paepos=(epos0&0x7fffffff)
			if readPool(epos1)==g_tid_TAdvancedEpos:
				//it's the parent-epos combo, show the error
				assert(readPool(epos1+1)>=0)
				error(type,readPool(epos1+1),readPool(epos1+2),serr)
			else
				//it's the parent-inline combo, reset the error but don't show it
				assert(readPool(epos1)==g_tid_TFunction)
				type=ETYPE_NOTE
				serr="within expanded inline function '@1'".Replace("@1",dumpFunction(epos1))
		else
			//it's a normal epos
			paepos=0
			error(type,epos0,epos1,serr)

auto errorAtExpr(int type,PExpression pe,string serr)
	if !g_expr_errored[pe]:
		if g_names_resolved:
			//only keep one error at each leaf location
			paepos0=readPool(pe+1)
			assert(readPool(paepos0)==g_tid_TAdvancedEpos)
			if readPool(paepos0+1)<0:
				paepos0=readPool(paepos0+2)
			if g_expr_errored[0x80000000|paepos0]:return
			g_expr_errored[0x80000000|paepos0]=1
			paepos0=readPool(pe+1)
			errorAtAEPos(type,paepos0,serr)
		else
			error(type,readPool(pe+1),readPool(pe+2),serr)
		//generate the template notes
		for(pei=pe;pei;)
			pe_parent=readPool(pei+EXPR_OFS_CALLER)
			if isBuiltin(pei,g_id_function):
				val=getExprValue(pei)
				assert(val.tid==g_vtid_CTVAL)
				pobjfn=val.val
				pobjfn_template=readPool(pobjfn+FUNCTION_OFS_TEMPLATE)
				if pobjfn_template:
					errorAtAEPos(ETYPE_NOTE,readPool(pobjfn+FUNCTION_OFS_TEMPLATE_EPOS0),"during instantiation of '@1'".Replace(["@1",dumpFunction(pobjfn_template)]))
			pei=pe_parent
		g_expr_errored[pe]=1

auto getDotMember(PExpression pecall,int do_err)
	peobj=readPool(pecall+EXPR_OFS_ARGS+0)
	val_obj=getExprValue(peobj)
	if val_obj.tid==g_vtid_STR||val_obj.tid==g_vtid_CTVAL:
		//constant string dotted, force into rtvar
		pobj_str_var=PCTObject(0)
		if isExpr(peobj,EFLAG_VARIABLE):
			pobj_str_var=getVariable(peobj)
		else if isExpr(peobj,EFLAG_FCALL):
			pobjfn=getExprFunction(peobj)
			if pobjfn:
				pobj_str_var=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
		if pobj_str_var:
			//dotted const strings / functions become vars
			//if val_obj.tid==g_vtid_STR:
			//	t=getStdObject(pecall,STDTYPE_STRING)
			//else
			t=getValueTypeEx(pecall,val_obj)
			if !t:return 0
			fstore_eval_core_ex(pecall,pobj_str_var,TSCCPValue(){tid:g_vtid_RTVAR,'val':t},1)
	pe_member_name=readPool(pecall+EXPR_OFS_ARGS+1)
	id_member=getExprValueAs(pe_member_name,g_vtid_STR)
	if !id_member:
		pobj_member=getExprValueAs(pe_member_name,g_vtid_CTVAL)
		if isVariable(pobj_member):
			return pobj_member
		else
			return 0
	t=getExprType(peobj)
	if !t||!tisclass(t):
		val=getExprValue(peobj)
		if val.tid!=g_vtid_UNINIT&&do_err:
			if DEBUG_TRAP_MEMBER_NOT_FOUND:
				Writeln('-------------------');Writeln(dumpExpr(pecall,NULL))
				Writeln('-------------------');Writeln(dumpExpr(g_pe_top,NULL))
				assert(0)
			if t:
				errorAtExpr(ETYPE_ERROR,pecall,"only class-typed expressions can have members ('@3'), but '@1' is of type '@2'".Replace(["@1",citeexpr(peobj),"@2",dumpType(t),"@3",getIdString(id_member)]))
			else
				errorAtExpr(ETYPE_ERROR,pecall,"only class-typed expressions can have members ('@2'), but '@1' is of an invalid type".Replace(["@1",citeexpr(peobj),"@2",getIdString(id_member)]))
			//Writeln(">>> "+dumpExpr(pecall,fcolor_abbrv_blocks))
			//Writeln('top='+dumpExpr(g_pe_top,fcolor_reach_eval))
			//assert(0)
			setnop(pecall)
		return 0
	setFunctionUsed(t)//dotted-but-never-newed class
	if !id_member:
		pobj_member=getExprValueAs(pe_member_name,g_vtid_CTVAL)
		//direct dot
		if pobj_member&&isVariable(pobj_member):
			return pobj_member
	pf_class=t
	pobj_member=lookupFunctionVariable(pf_class,id_member)
	if !pobj_member&&do_err:
		errorAtExpr(ETYPE_ERROR,pecall,"class '@1' doesn't have member '@2'".Replace(["@1",dumpType(t),"@2",getIdString(id_member)]))
		//assert(0)
		//assert(id_member!=g_id_operator_bracket)
		if DEBUG_TRAP_MEMBER_NOT_FOUND:
			Writeln('-------------------');Writeln(dumpExpr(pecall,NULL))
			Writeln('-------------------');Writeln(dumpExpr(g_pe_top,NULL))
			assert(0)
		return 0
	//cache the result
	//writePool(pe_member_name,EFLAG_CTVAL+pobj_member)
	return pobj_member

inline fstore_eval_core(PExpression pecall,PCTObject pobj_var,PExpression pe_value,int test_return)
	val_new=getExprValue(pe_value)
	return fstore_eval_core_ex(pecall,pobj_var,val_new,test_return)
	
auto fstore_eval_core_ex(PExpression pecall,PCTObject pobj_var,TSCCPValue val_new,int test_return)
	vv=readPoolTyped(pobj_var,TVariable)
	val_old=TSCCPValue()
	val_old.tid=vv.tid
	val_old.val=vv.val
	val_final=mergeValues(pecall,val_old,val_new, pobj_var|0x80000000,pecall)
	//Writeln(getIdString(ervar.v.key),' <- ',getIdString(val_old.tid),' || ',getIdString(val_new.tid))
	force_changed=0
	if val_final.tid==g_vtid_CTVAL:
		//but if it's a function
		pobj=val_final.val
		pobjfn=getAsFunction(pobj)
		if pobjfn:
			value_time_new=readPool(pobjfn+FUNCTION_OFS_VALUE_TIME)
			if vv.value_time<value_time_new||val_old.tid!=val_final.tid||val_old.val!=val_final.val:
				vv.value_time=value_time_new
				force_changed=1
			//if val_old.tid==val_final.tid&&val_old.val==val_final.val:
			//	Writeln(getIdString(ervar.v.key),' ',vv.value_time,' ',value_time_new)
			//	if force_changed:
			//		Writeln('force_changed! ',getIdString(ervar.v.key))
	if val_old.tid==val_final.tid&&val_old.val==val_final.val&&!force_changed:
		//it didn't change
		return TSCCPValue(){tid:g_vtid_UNINIT}
	if g_readable_c_code&&pobj_var:
		//if it's a function, try to set the function's name
		vid=readPool(pobj_var+VAR_OFS_ID)
		if val_final.tid==g_vtid_CTVAL:
			pobj=val_final.val
			pobjfn=getAsFunction(pobj)
			if pobjfn:
				id_name=readPool(pobjfn+FUNCTION_OFS_NAME)
				if !id_name:
					writePool(pobjfn+FUNCTION_OFS_NAME,vid)
	//write back and invalidate all users
	vv.tid=val_final.tid
	vv.val=val_final.val
	writePoolTyped(pobj_var,vv)
	if DEBUG_EVAL_LOG:
		Write('changed - queueeval ',dumpObject(pobj_var),' ',getIdString(val_old.tid),' -> ',getIdString(val_final.tid))
		//if vv.id==getid('length')&&val_final.tid==g_vtid_RTVAR:
		//	assert(0)
		//if pobj_var==1102774:
		//	Writeln('top='+dumpExpr(g_pe_top,fcolor_reach_eval))
		//	assert(0)
		if val_final.tid==g_vtid_CNS:
			Write(' ',dumpConst(Util.g_const_values[val_final.val]))
		else if val_final.tid==g_vtid_STR:
			Write(' ',getIdString(val_final.val))
		else if val_final.tid==g_vtid_CTVAL:
			Write(' ',dumpObject(val_final.val))
		else if val_final.tid==g_vtid_RTVAR:
			Write(' ',dumpType(val_final.val))
		Writeln()
	queueEvalUsers(pobj_var)
	idvar=readPool(pobj_var+VAR_OFS_ID)
	if test_return:
		if idvar==g_id_return:
			pobjfn=getOwningFunction(pecall)
			if pobjfn:
				pvar_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
				if pobj_var==pvar_return:
					queueEvalFunction(pobjfn)
		if idvar==g_id_finalizer&&val_new.tid==g_vtid_CTVAL&&readPool(val_new.val)==g_tid_TFunction:
			pobjfn=getOwningFunction(pecall)
			if tisrealclass(pobjfn):
				setFunctionUsed(val_new.val)
			else
				id_ccnv=getCcnv(pobjfn)
				if id_ccnv==g_id_struct:
					//coulddo: support it
					errorAtExpr(ETYPE_WARNING,pecall,"__done__ is not supported in a struct")
				else
					errorAtExpr(ETYPE_WARNING,pecall,"__done__ is pointless in an ordinary function")
	return TSCCPValue(){'tid':g_vtid_UNINIT}

auto lockValueCheck(PExpression pe,int id_error_message)
	writePool(pe+EXPR_OFS_CALLER,0)
	return call(g_id_assert_ctval,pe,exprstr(id_error_message))

inline getFCallNArgs(PExpression pe)
	ret=readPool(pe)
	assert((ret&EFLAG_MASK)==EFLAG_FCALL&&!EFLAG_FCALL)
	return ret

auto computeConstIfBranch(PExpression pecall,TSCCPValue val_cond)
	n_args=getFCallNArgs(pecall)
	cns_branch=1
	for i=2:2:n_args-2
		val_i=getExprValue(readPool(pecall+EXPR_OFS_ARGS+i))
		if isValueZero(val_i):
			if isValueZero(val_cond):
				cns_branch=i+1
				break
		else
			if val_cond.tid==val_i.tid&&val_cond.val==val_i.val:
				cns_branch=i+1
				break
	//handle shared case values
	while cns_branch<n_args&&readPool(readPool(pecall+EXPR_OFS_ARGS+cns_branch))==EFLAG_STRING+g_id_case:
		cns_branch+=2
	if cns_branch>=n_args:
		cns_branch=1
	return cns_branch

ftransformer_callback=function(PExpression):PExpression
inline transformCode(PExpression pesrc, ftransformer_callback ftransformer, PExpression[] as_before,PExpression pe_replacement,PExpression[] as_after)
	return transformCodeEx(pesrc, ftransformer, as_before,pe_replacement,as_after, 1)

inline replaceExpr(PExpression pesrc, PExpression pe_replacement)
	return transformCode(pesrc,ftransformer_callback.NULL, PExpression[].NULL,pe_replacement,PExpression[].NULL)

auto transformCodeEx(PExpression pesrc, ftransformer_callback ftransformer, PExpression[] as_before,PExpression pe_replacement,PExpression[] as_after, int queue_reach)
	if !ftransformer&&(!as_before||!as_before.n)&&!pe_replacement&&(!as_after||!as_after.n):
		return pesrc
	pecaller=readPool(pesrc+EXPR_OFS_CALLER)
	nargs_caller=readPool(pecaller)&~EFLAG_MASK
	if pesrc<=0:
		arg_id=~pesrc
	else
		arg_id=-2
		for i=-1:nargs_caller-1
			if readPool(pecaller+EXPR_OFS_ARGS+i)==pesrc:
				arg_id=i
				break
		if arg_id<-1:
			assert(0)
			return 0
	assert(u32(arg_id)<u32(nargs_caller)||arg_id==-1)
	/////////////
	pe_block_level=promoteToBlockLevel(pesrc)
	peold=readPool(pecaller+EXPR_OFS_ARGS+arg_id)
	epos0=readPool(peold+1)
	epos1=readPool(peold+2)
	writePool(peold+EXPR_OFS_CALLER,0)
	pe_real_replacement=peold
	pe_transformed=PExpression(0)
	if pe_replacement:
		if ftransformer:
			pe_transformed=ftransformer(pe_real_replacement)
		pe_real_replacement=pe_replacement
	/////////////
	//create the new thing
	need_temp=(pesrc!=pe_block_level&&as_after&&as_after.n&&!isExpr(pe_real_replacement,EFLAG_VARIABLE))
	pv_temp=PCTObject(0)
	pe_block_mid0=PExpression(0)
	if need_temp:
		pf_owner=getOwningFunction(pecaller)
		pv_temp=makevar(pf_owner)
		val=getExprValue(pe_real_replacement)
		writePool(pv_temp+0,val.tid)
		writePool(pv_temp+1,val.val)
		//writePool(pe_real_replacement+1,epos0)
		//writePool(pe_real_replacement+2,epos1)
		fillepos(pe_real_replacement,epos0,epos1)
		pe_block_mid0=call(g_id_store,exprvar(pv_temp),pe_real_replacement)
		writePool(pv_temp+VAR_OFS_DEFINING_STORE,pe_block_mid0)
		pe_real_replacement=exprvar(pv_temp)
		//writePool(pe_real_replacement+1,epos0)
		//writePool(pe_real_replacement+2,epos1)
	else
		pe_block_mid0=0
	/////
	writePool(pe_real_replacement+EXPR_OFS_CALLER,pecaller)
	//writePool(pe_real_replacement+1,epos0)
	//writePool(pe_real_replacement+2,epos1)
	fillepos(pe_real_replacement,epos0,epos1)
	writePool(pecaller+EXPR_OFS_ARGS+arg_id,pe_real_replacement)
	if queue_reach:
		sccpQueueReach(pe_real_replacement)
	/////
	//todo: more efficient arg searching
	pe_fnblock=exprvar(g_symbols[g_id_block].user_slot)
	pe_new_block=poolCode(TExpression(){'flags_n_args':EFLAG_FCALL})
	g_ctobject_pool.push(pe_fnblock)
	if as_before:g_ctobject_pool.push(as_before)
	if pe_transformed:
		sccpQueueReach(pe_transformed)//avoid assertion failure
		g_ctobject_pool.push(pe_transformed)
	if pe_block_mid0:g_ctobject_pool.push(pe_block_mid0)
	if pe_block_level==pesrc:
		g_ctobject_pool.push(pe_real_replacement)
	if as_after:g_ctobject_pool.push(as_after)
	if pe_block_level!=pesrc:
		g_ctobject_pool.push(pe_block_level)
	else
		pe_block_level=pe_real_replacement
	pe_block_level_caller=readPool(pe_block_level+EXPR_OFS_CALLER)
	n_args=(g_ctobject_pool.n-(pe_new_block+EXPR_OFS_ARGS))
	if n_args==1:
		pe_new_block=readPool(pe_new_block+EXPR_OFS_ARGS+0)
	else
		writePool(pe_new_block,int(EFLAG_FCALL+n_args))
	//replace pe_block_level with pe_new_block
	pe_new_block=insertCallAt(pe_block_level_caller,pe_block_level,function(PExpression pe){return pe_new_block})
	if queue_reach:
		sccpQueueReach(pe_new_block)
	for i=0:n_args-1
		writePool(readPool(pe_new_block+EXPR_OFS_ARGS+i)+EXPR_OFS_CALLER,pe_new_block)
	//Writeln("TT>> "+dumpExpr(pe_new_block,function(PExpression pe_test){
	//	if pe_test==pe_block_level||pe_test==pesrc:return 9;
	//	if pe_test==pecaller:return 11;
	//	return fcolor_reach_eval(pe_test)
	//}))
	return pe_new_block

auto queueCodeGen(PCTObject pobjfn)
	if !(getFFlag(pobjfn)&FFLAG_CGEN_QUEUED):
		assert(getCcnv(pobjfn)!=g_id_inline&&getCcnv(pobjfn)!=g_id_inline_loopbody)
		setFFlag(pobjfn,FFLAG_CGEN_QUEUED)
		g_gencode_queue.push(readPool(pobjfn+FUNCTION_OFS_PEDECL))
		if Platform.BUILD=="debug":
			if !(!isExpr(readPool(pobjfn+FUNCTION_OFS_CODE),EFLAG_FCALL)||testUserFlag(readPool(pobjfn+FUNCTION_OFS_CODE),QUEUE_FLAG_REACH)):
				if !(getFFlag(pobjfn)&FFLAG_IMPORTED):
					Writeln('queueing unreached function: ',dumpFunction(pobjfn))
					assert(0)
		//assert(!isExpr(readPool(pobjfn+FUNCTION_OFS_PEDECL),EFLAG_STRING))
		//Writeln('queueCodeGen: ',dumpObject(pobjfn))

auto setParameterSlotTypes(PCTObject pobjfn)
	pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	n_funcargs=((readPool(pe_decl)&~EFLAG_MASK)-2)>>1
	p_param_values=readPool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
	for i=0:n_funcargs-1
		t=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+1+i*2),g_vtid_CTVAL)
		if t:
			writePool(p_param_values+i*3+0,g_vtid_RTVAR)
			writePool(p_param_values+i*3+1,t)
			pe_ldparam=readPool(p_param_values+i*3+2)
			if pe_ldparam:
				sccpQueueEval(pe_ldparam)

auto fcolor_user_flags(PExpression pe)
	val=getExprValue(pe)
	if val.tid==g_vtid_UNINIT:
		if !testUserFlag(pe,QUEUE_FLAG_REACH):
			if isBuiltin(pe,g_id_block):
				return -2
			else
				return -1
	if isBuiltin(pe,g_id_function):
		return -2
	c=7
	if isExpr(pe,EFLAG_VARIABLE):
		pobj_var=getVariable(pe)
		if pobj_var:
			if testUserFlag(pobj_var,1):
				c-=1
			if testUserFlag(pobj_var,2):
				c-=2
			return c
	if testUserFlag(pe,1):
		c-=1
	if testUserFlag(pe,2):
		c-=2
	return c

auto getLIObjectStringPair(PCTObject pobj)
	id_str0=0
	id_str1=0
	key=int2(0x80000000+pobj,0x80000001)
	if readPool(pobj)==g_tid_TFunction:
		id_str_stored=readEPosHash(key)
		if !id_str_stored:
			id_str_stored=getid(dumpFunction(pobj)+"\n")
			writeEPosHash(key,id_str_stored)
		id_str0=id_str_stored
	else
		assert(readPool(pobj)==g_tid_TAdvancedEpos)
		epos0=readPool(pobj+1)
		assert(epos0>0)
		(id_fn0,ln0,col0)=getLineInfo(epos0)
		id_str0=id_fn0
		id_str_stored=readEPosHash(key)
		if !id_str_stored:
			epos1=readPool(pobj+2)
			(id_fn1,ln1,col1)=getLineInfo(epos1)
			//Writeln(getIdString(id_fn0),' ',getIdString(id_fn1),' ',epos0,' ',epos1)
			assert(id_fn0==id_fn1)
			if ln0==ln1:
				id_str_stored=getid(FormatAsText(':',ln0+1,',',col0+1,'-',col1+1,': '))
			else
				id_str_stored=getid(FormatAsText(':',ln0+1,',',col0+1,'-',ln1+1,',',col1+1,': '))
			writeEPosHash(key,id_str_stored)
		id_str1=id_str_stored
	return int2(id_str0,id_str1)

auto genLIString(string buf,int id)
	if !readEPosHash(int2(0x80000000+id,0x80000002)):
		g_debug_file_info_buffer.push('static const char s7_Df')
		g_debug_file_info_buffer.push(toBase32(id))
		g_debug_file_info_buffer.push('[]="')
		g_debug_file_info_buffer.push(genString(getIdString(id)))
		g_debug_file_info_buffer.push('";')
		writeEPosHash(int2(0x80000000+id,0x80000002),1)
	buf.push("s7_Df")
	buf.push(toBase32(id))

if Platform.BUILD=="debug":
	g_li_arv=new int[int]
auto getLineInfoId(PCTObject paepos)
	if Platform.BUILD=="debug":
		if g_li_arv[paepos]:
			Writeln('epos loop! ',paepos)
			assert(0)
		g_li_arv[paepos]=1
	key=int2(0x80000000+paepos,0x80000000)
	lid=readEPosHash(key)
	if !lid:
		assert(readPool(paepos)==g_tid_TAdvancedEpos)
		epos0=readPool(paepos+1)
		lid_next=0
		if epos0&0x80000000:
			lid_next=getLineInfoId(epos0&0x7fffffff)
			id_strs=getLIObjectStringPair(readPool(paepos+2))
		else
			id_strs=getLIObjectStringPair(paepos)
		if id_strs.y:
			g_debug_line_info_buffer.push('{')
			genLIString(g_debug_line_info_buffer,id_strs.y)
			if lid_next:
				g_debug_line_info_buffer.push(',s7_DL+')
				g_debug_line_info_buffer.push(string(lid_next-1))
			g_debug_line_info_buffer.push('},')
			lid_next=++g_current_line_info_id
		g_debug_line_info_buffer.push('{')
		genLIString(g_debug_line_info_buffer,id_strs.x)
		if lid_next:
			g_debug_line_info_buffer.push(',s7_DL+')
			g_debug_line_info_buffer.push(string(lid_next-1))
		g_debug_line_info_buffer.push('},')
		lid=++g_current_line_info_id
		writeEPosHash(key,lid)
	return lid
	
auto genLineInfoExpr(PExpression pecall)
	//we set a leaf to the spapAddCallStack structure
	//nested epos should form a pre-built tree, print epos and print func ops, addcallstack chains a print fun
	//just "print string", could share pointers
	paepos0=readPool(pecall+1)
	if !paepos0:
		g_code_buffer.push('0')
		return
	if Platform.BUILD=="debug":
		g_li_arv=new int[int]
	lid=getLineInfoId(paepos0)
	g_code_buffer.push("s7_Dd.li=s7_DL+")
	SWrite(g_code_buffer,lid-1)

inline parameterTypeCheck(PCTObject t_expected,PCTObject t)
	if t_expected==t:return 1
	if tisbuiltin(t_expected)&&tisbuiltin(t):
		ct_expected=readPool(t_expected+1)
		ct=readPool(t+1)
		if ct_expected==const_type(CTYPE_INT,Util.bitSize())&&ct==const_type(CTYPE_INT,32):
			//iptr always matches i32
			return 1
	return 0

auto getReturnLabel(PCTObject pf)
	id_ret=readPool(pf+FUNCTION_OFS_RETURN_LABEL_CACHE)
	if !id_ret:
		id_ret=catid(g_id_return_,getid(toBase32(pf)))
		writePool(pf+FUNCTION_OFS_RETURN_LABEL_CACHE,id_ret)
	return id_ret

inline isReturnJump(PExpression pe)
	if isBuiltin(pe,g_id_blockex):
		flags_id=readPool(readPool(pe+EXPR_OFS_ARGS+0))
		if (flags_id&EFLAG_MASK)==EFLAG_STRING:
			return isTempId(flags_id-EFLAG_STRING)
		else
			return 0
	else
		return 0

auto makeAdvEpos(int epos0,int epos1)
	assert(epos1>0)
	epos_new=readEPosHash(int2(epos0,epos1))
	if !epos_new:
		epos_new=poolObject(TAdvancedEpos(){'epos0':epos0,'epos1':epos1})
		writeEPosHash(int2(epos0,epos1),epos_new)
	return epos_new

auto expr_C_const(string sdata)
	vid=int(g_ctobject_pool.n)
	s_c_code=new string
	s_c_code.push("@raw:long long s7_CD")
	s_c_code.push(toBase32(vid))
	s_c_code.push("[]={")
	nalg=(sdata.n&-8)
	buf64=sdata[:nalg-1].ConvertToAsBinary(i64)
	for i=0:buf64.n-1
		if s_c_code.back()!='{':
			s_c_code.push(',')
		s_c_code.push(string(buf64[i]))
		s_c_code.push('LL')
	tail=0LL
	for i=nalg:sdata.n-1
		tail|=i64(u8(sdata[i]))<<(int(i-nalg)*8)
	if s_c_code.back()!='{':
		s_c_code.push(',')
	s_c_code.push(string(tail))
	s_c_code.push('LL')
	s_c_code.push('};')
	return call(g_id_C_wrap,exprctval(getBuiltinType(CTYPE_POINTER)),exprstr(getid(s_c_code)),expriptr(vid))

g_varifyDblMembers_called=new int[PCTObject]
auto varifyDblMembers(PExpression pecall,PCTObject t)
	if !t||!tisclass(t):return
	if g_varifyDblMembers_called[t]:return
	g_varifyDblMembers_called[t]=1
	if DEBUG_DUMP_DERIV:
		Writeln('varifyDblMembers: ',dumpType(t))
	p_members=readPool(t+FUNCTION_OFS_PMEMBER_LIST)
	n_members=readPool(t+FUNCTION_OFS_NMEMBER_LIST)
	for i=0:n_members-1
		id_member=readPool(p_members+i)
		if id_member==g_id_this||id_member==g_id_return:continue
		pobj_member=lookupFunctionVariable(t,id_member)
		t_i=getVariableType(pobj_member)
		//Writeln(getIdString(readPool(pobj_member)),' ',dumpType(t_i),' ',getIdString(id_member))
		if readPool(pobj_member)==g_vtid_CNS:
			if tisctype(t_i,CTYPE_FLOAT):
				if DEBUG_DUMP_DERIV:
					Writeln('varify: ',dumpType(t_i),' ',getIdString(id_member))
				fstore_eval_core_ex(pecall,pobj_member,TSCCPValue(){'tid':g_vtid_RTVAR,'val':t_i},0)
		else
			varifyDblMembers(pecall,t_i)

g_json_pool=new int[][int]
		
g_id_error_class_cannot_change=getid("expression '@1' is used as a class and has to hold a constant value")
g_id_error_template_cannot_change=getid("expression '@1' is used as a template function and has to hold a constant value")
g_id_error_inline_cannot_change=getid("expression '@1' is used as an inline function and has to hold a constant value")
g_id_error_const_cannot_change=getid("expression '@1' is used as a template parameter and has to hold a constant value")
g_id_error_int_cannot_change=getid("expression '@1' is used as a constant integer and has to hold a constant value")

g_id_symderiv=getid("symbolicDerivative")
g_id_option_exclusive=getid("<exclusive>")
g_id_ANM_decompose=getid("__ANM_decompose")
g_id_make_polynomial=getid("__make_polynomial")
g_id_deriv=getid("_deriv")
//g_id_deriv_prefix=getid("_deriv_")
g_id_deriv_callback=getid("_deriv_callback")
g_id_deriv_pulling_masks=getid("_deriv_pulling_masks")
g_id_deriv_reusable_components=getid("_deriv_reusable_components")
g_id__=getid("_")
g_id_powd=getid("powd")
g_id_gvn_ctunique=getid(">gvn_ctunique")
g_fakectval_gvn_cns=0
g_fakectval_gvn_str=0

g_cid_null=getid_const(CTYPE_POINTER,0LL)

auto coreInit()
	if g_inited_astcore:return
	g_inited_astcore=1
	g_fakectval_gvn_cns=int(g_ctobject_pool.n);g_ctobject_pool.push(0)
	g_fakectval_gvn_str=int(g_ctobject_pool.n);g_ctobject_pool.push(0)
	//g_builtin_scope=ONew()
	/////////////////////
	freach_fn_only=function(PExpression pecall,int expr_oplevel){
		sccpQueueReach(readPool(pecall+EXPR_OFS_FUNCTION))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fexpand_inline_oneval=function(PExpression pecall,int expr_oplevel){
		//todo: translate some param epos intrinsic in g_id_report_error calls
		//type check
		//Writeln('fexpand_inline_oneval')
		pobjfn=getExprFunction(pecall)
		//Writeln('expanding: ',dumpFunction(pobjfn))
		n_args=getFCallNArgs(pecall)
		n_funcargs=getNumberOfArguments(pobjfn)
		if n_args<n_funcargs:
			sfname=new(getIdString(readPool(pobjfn+FUNCTION_OFS_NAME)))
			//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
			//Writeln("bad inline - "+dumpExpr(pecall,fcolor_abbrv_blocks))
			//assert(0)
			errorAtExpr(ETYPE_ERROR,pecall,"inline function '@1' takes @2 arguments, but only @3 are provided".Replace([
				"@1",sfname,
				"@2",string(n_funcargs),
				"@3",string(n_args)
			]))
			setnop(pecall)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
		for i=0:n_funcargs-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			t_expected=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+i*2+1),g_vtid_CTVAL)
			if !t_expected:continue
			t=getExprType(pe_argi)
			if !t:continue
			if !parameterTypeCheck(t_expected,t):
				errorAtExpr(ETYPE_ERROR,pe_argi,"parameter #@3 type mismatch for @4: '@1' expected but '@2' provided".Replace(["@1",dumpType(t_expected),"@2",dumpType(t),"@3",string(i),"@4",dumpFunction(pobjfn)]))
				setnop(pecall)
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		//actual expanding
		fn=readPoolTyped(pobjfn,TFunction)
		pf_owner=getOwningFunction(pecall)
		assert(!!pf_owner)
		var_map=new PCTObject[PCTObject]
		var_map[pobjfn]=pf_owner
		pe_func=readPool(pecall+EXPR_OFS_FUNCTION)
		pe_this=0
		pe_store_this=0
		pe_expanded=cloneExprEx(fn.code,var_map,CLONE_WIPE_TO_UNREACHED|CLONE_VARS|CLONE_KEEP_VAR_IDS)
		/////////
		//old epos plus function
		epos_parent=0x80000000+makeAdvEpos(0x80000000+readPool(pecall+1),pobjfn)
		fnest_eposes=function(PExpression pe){
			epos_old=readPool(pe+1)
			assert(epos_old>=0)
			if epos_old:
				//strip previous inline callstacks
				while readPool(epos_old)==g_tid_TAdvancedEpos&&readPool(epos_old+1)<0
					epos_old=readPool(epos_old+2)
				writePool(pe+1,makeAdvEpos(epos_parent,epos_old))
			return 1
		}
		dfsExpr(pe_expanded,fnest_eposes)
		/////////
		if isBuiltin(pe_func,g_id_dot):
			//assert(0)
			//Writeln(">>> "+dumpExpr(pecall,fcolor_abbrv_blocks))
			pe_this=readPool(pe_func+EXPR_OFS_ARGS+0)
			pv_this=rcGetVariableIfExprIsOne(pe_this)
			if !pv_this:
				pv_this=makevar(pf_owner)
				writePool(pv_this+0,g_vtid_RTVAR)
				writePool(pv_this+1,getExprType(pe_this))
				pe_store_this=call(g_id_store,exprvar(pv_this),pe_this)
				writePool(pv_this+VAR_OFS_DEFINING_STORE,pe_store_this)
			pf_class=getOwningFunction(readPool(fn.pe_decl+EXPR_OFS_CALLER))
			//var_map[pf_class]=~pv_this
			freplace_class_members=function(PExpression pe){
				if isExpr(pe,EFLAG_VARIABLE):
					auto pobj_var=getVariable(pe)
					if readPool(pobj_var+VAR_OFS_OWNER)==pf_class:
						auto idvar=readPool(pobj_var+VAR_OFS_ID)
						assert(!!idvar)
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						//if idvar==getid("f0"):
						//	Writeln(dumpType(pf_class),' ',dumpObject(pf_owner))
						//	Writeln(">>>f0!\n"+dumpExpr(pe_expanded,NULL))
						//	assert(0)
						if idvar==g_id_this:
							//this
							writePool(pe,EFLAG_VARIABLE+pv_this)
						else if isBuiltin(pecaller,g_id_store)&&pe==readPool(pecaller+EXPR_OFS_ARGS+0):
							//stdot
							pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
							fcreate_stdot=function(PExpression pe_store){
								//return call(g_id_stdot,exprvar(pv_this),exprstr(idvar),readPool(pe_store+EXPR_OFS_ARGS+1))
								return call(g_id_stdot,exprvar(pv_this),exprctval(pobj_var),readPool(pe_store+EXPR_OFS_ARGS+1))
							}
							insertCallAt(pecaller_caller,pecaller,fcreate_stdot)
						else
							//dot
							fcreate_dot=function(PExpression pe_var){
								return call(g_id_dot,exprvar(pv_this),exprctval(pobj_var))
							}
							insertCallAt(pecaller,pe,fcreate_dot)
						return 0
				//else if isBuiltin(pe,g_id_function):
				//	return 0
				return 1
			}
			if pf_class&&tisclass(pf_class):
				dfsExpr(pe_expanded,freplace_class_members)
		pvar_return=var_map[fn.pvar_return]
		n_args_call=(readPool(pecall)&~EFLAG_MASK)
		prototype_mismatch=0
		//the scoping is fine for inline calls: the inline function itself has to be defined at some ancestor of the current scope
		//we could use wiped code, what we really need is a "scope jumper" to skip the things in-between
		//so it's scope-jumper + pre-resolved parameter exprs
		//bind parameters - ldparam replacement
		//n_funcargs=(nargs_pecode-2)>>1
		pvar_arg_ret=new PCTObject[] //shouldn't use gencode: lackof decl
		pv_arguments=PCTObject(0)
		id_return_label=getReturnLabel(pobjfn)
		need_return_scope=0
		fdetect_returns=function(PExpression pe){
			if isBuiltin(pe,g_id_blockex)&&readPool(readPool(pe+EXPR_OFS_ARGS+0))==EFLAG_STRING+id_return_label:
				need_return_scope=1
			return 1
		}
		freplace_args=function(PExpression pe_store_i){
			if isBuiltin(pe_store_i,g_id_function):
				if !need_return_scope:
					dfsExpr(pe_store_i,fdetect_returns)
				return 0
			//if isReturnJump(pe_store_i):
			if isBuiltin(pe_store_i,g_id_blockex)&&readPool(readPool(pe_store_i+EXPR_OFS_ARGS+0))==EFLAG_STRING+id_return_label:
				need_return_scope=1
			if isBuiltin(pe_store_i,g_id_store):
				pe_var_i=readPool(pe_store_i+EXPR_OFS_ARGS+0)
				pe_code_i=readPool(pe_store_i+EXPR_OFS_ARGS+1)
				if isBuiltin(pe_code_i,g_id_ldparam):
					paramid=getExprValueAs(readPool(pe_code_i+EXPR_OFS_ARGS+0),g_vtid_CNS)
					if !(u32(paramid)<u32(n_args_call)):
						prototype_mismatch=1+paramid
						return 0
					pe_param=readPool(pecall+EXPR_OFS_ARGS+paramid)
					//writePool(pe_param+EXPR_OFS_CALLER,0)
					pvar=getVariable(pe_var_i)
					writePool(pvar+VAR_OFS_USER_FLAGS,readPool(pvar+VAR_OFS_USER_FLAGS)&~VAR_FLAG_PARAM)
					if pvar:pvar_arg_ret.push(pvar)
					//bind the param
					//no premature param reach
					insertCallAt(pe_store_i,pe_code_i,function(){return pe_param})
					//sccpQueueReach()
					return 0
			if isExpr(pe_store_i,EFLAG_VARIABLE):
				//translating the arguments
				pv=getVariable(pe_store_i)
				if pv&&readPool(pv+VAR_OFS_ID)==g_id_arguments:
					as=PExpression[].NULL
					if !pv_arguments:
						pv_arguments=makevar(pf_owner)
						writePool(pv_arguments+VAR_OFS_ID,gettempid(g_id_arguments))
						pe_arguments_tuple=makeTuple(n_args_call)
						as=new PExpression[]
						as.push(call(g_id_store,exprvar(pv_arguments),pe_arguments_tuple))
						writePool(pv_arguments+VAR_OFS_DEFINING_STORE,as[0])
						for i=0:n_args_call-1
							if i<pvar_arg_ret.n:
								pe_call_argi=exprvar(pvar_arg_ret[i])
							else
								pe_call_argi=cloneExpr(readPool(pecall+EXPR_OFS_ARGS+i))
							as.push(call(g_id_stdot,exprvar(pv_arguments),exprstr(getTupleId(i)),pe_call_argi))
					transformCodeEx(pe_store_i,NULL,as,exprvar(pv_arguments),NULL,0)
				return 0
			return 1
		}
		dfsExpr(pe_expanded,freplace_args)
		if prototype_mismatch:
			//it's doomed
			errorAtExpr(ETYPE_ERROR,pecall,"the caller failed to provide parameter #@1 for @2".Replace(["@1",string(prototype_mismatch-1),"@2",dumpFunction(pobjfn)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//get return variable
		//pecheck=call(g_id_assert_ctval,exprvar())
		//writePool(pecheck+EXPR_OFS_EPOS+0,readPool(pecall+EXPR_OFS_EPOS+0))
		//writePool(pecheck+EXPR_OFS_EPOS+1,readPool(pecall+EXPR_OFS_EPOS+1))
		pecallee=readPool(pecall+EXPR_OFS_FUNCTION+0)
		//writePool(pecallee+EXPR_OFS_CALLER,0)
		pe_check=lockValueCheck(cloneExpr(pecallee),g_id_error_inline_cannot_change)
		if pvar_return:
			pe_return_value=exprvar(pvar_return)
			pvar_arg_ret.push(pvar_return)
			//return should be the only sensitive name that needs demolishing - an inline can't have a this
			writePool(pvar_return+VAR_OFS_ID,gettempid(g_id_return))
		else
			pe_return_value=expriptr(0)
		pvar_arg_ret.Sort()
		pvar_arg_ret.Unique()
		need_optimization=0
		if !need_return_scope:
			cnt_ass=new int[PCTObject]
			cnt_use=new int[PCTObject]
			auto fcount_ass_use(PExpression pe,int delta)
				delta_recurse=delta
				if isBuiltin(pe,g_id_function):
					delta_recurse=2
				if isBuiltin(pe,g_id_store):
					auto pvar=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
					auto pe_ass0=cnt_ass[pvar]
					if !pe_ass0:
						cnt_ass[pvar]=pe
					else if pe_ass0!=-1:
						cnt_ass[pvar]=-1
				else if isExpr(pe,EFLAG_VARIABLE):
					cnt_use[getVariable(pe)]+=delta_recurse
				if isExpr(pe,EFLAG_FCALL):
					n_args=getFCallNArgs(pe)
					for i=-1:n_args-1
						fcount_ass_use(readPool(pe+EXPR_OFS_ARGS+i),delta_recurse)
			fcount_ass_use(pe_expanded,1)
			fcount_ass_use(pe_return_value,1)
			//do single-ass single-use optimization, return can get optimized too -- single-ass return must be the last
			do_optimization=new PExpression[PCTObject]
			setnop_jobs=new PExpression[]
			foreach pvar in pvar_arg_ret
				pe_ass=cnt_ass[pvar]
				pe_value=readPool(pe_ass+EXPR_OFS_ARGS+1)
				if pe_ass&&pe_ass!=-1&&(cnt_use[pvar]==2||isExpr(pe_value,EFLAG_CONST)||isExpr(pe_value,EFLAG_VARIABLE)):
					//optimize!
					setnop_jobs.push(pe_ass)
					if cnt_use[pvar]>2:
						pe_ass|=0x80000000
					do_optimization[pvar]=pe_ass
					need_optimization=1
		if need_return_scope:
			pe_expanded=call(g_id_blockex,exprstr(g_id_blockex),exprstr(id_return_label),pe_expanded)
		//if g_enable_debug_instrumentation:
		//	epos0=readPool(pecall+1)
		//	epos1=readPool(pecall+2)
		//	pe_expanded=fillepos(call(g_id_block,call(g_id_callstack,exprctval(pobjfn),expriptr(0)),pe_expanded,call(g_id_callstack,expriptr(0))),epos0,epos1)
		if pe_store_this:
			as_before=[pe_check,pe_store_this,pe_expanded]
		else
			as_before=[pe_check,pe_expanded]
		pecaller_original=readPool(pecall+EXPR_OFS_CALLER)
		pe_final=transformCode(pecall,ftransformer_callback.NULL, as_before,pe_return_value,PExpression[].NULL)
		//somehow we're needing this - test_js0.spap
		if testUserFlag(pecaller_original,QUEUE_FLAG_REACH):
			sccpQueueEval(pecaller_original)
		if need_optimization:
			foptimize_single_ass=function(PExpression pe){
				//if isBuiltin(pe,g_id_function):
				//	return 0
				if isExpr(pe,EFLAG_VARIABLE):
					auto pvar=getVariable(pe)
					auto pe_ass=do_optimization[pvar]
					auto pecaller=readPool(pe+EXPR_OFS_CALLER)
					auto need_dup=(pe_ass&0x80000000)
					pe_ass&=0x7fffffff
					if pe_ass&&pe_ass!=pecaller:
						pe_replace_with=readPool(pe_ass+EXPR_OFS_ARGS+1)
						//assert(!!pe_replace_with)
						//writePool(pe_ass+EXPR_OFS_ARGS+1,0)
						//Writeln('pe_ass>>> ',dumpExpr(pe_ass,NULL))
						//Writeln('pe>>> ',dumpExpr(pe,NULL))
						if need_dup:
							pe_replace_with=cloneExpr(pe_replace_with)
							writePool(pe_replace_with+EXPR_OFS_EPOS+0,readPool(pe+EXPR_OFS_EPOS+0))
							writePool(pe_replace_with+EXPR_OFS_EPOS+1,readPool(pe+EXPR_OFS_EPOS+1))
						else
							do_optimization[pvar]=0
							//setnop(pe_ass)
						//no premature param reach, but we need to reach the return value
						//wipeepos(pe_replace_with)
						insertCallAt(pecaller,pe,function(){return pe_replace_with})
						if pvar==pvar_return:
							//Writeln('return reach: '+dumpExpr(pe_replace_with,fcolor_reach_eval))
							sccpQueueReach(pe_replace_with)
							if testUserFlag(pecaller,QUEUE_FLAG_REACH):
								flag_pe_replacement=(readPool(pe_replace_with)&EFLAG_MASK)
								if flag_pe_replacement==EFLAG_CONST||flag_pe_replacement==EFLAG_STRING||flag_pe_replacement==EFLAG_CTVAL:
									//when const returning inline gets optimized, we need to queue the const user
									sccpQueueEval(pecaller)
					return 0
				return 1
			}
			dfsExpr(pe_final,foptimize_single_ass)
			foreach pe in setnop_jobs
				setnop(pe)
		setnop(pecall)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fget_function_return_value=function(PCTObject pobjfn,PExpression pecall){
		if setFunctionUsed(pobjfn):
			//we KNOW we'll need to eval again
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		else
			pobj_var=getReturnVariable(pobjfn)
			if !pobj_var:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			val_return=readPoolTyped(pobj_var,TSCCPValue)
			if val_return.tid==g_vtid_UNINIT:
				//need to re-eval after the return type gets determined
				addFunctionUser(pobjfn,pecall|0x80000000)
			//use type deduction once the return type is deducted
			//treturn=getValueType(val_return)
			//return TSCCPValue(){'tid':g_vtid_RTVAR,'val':treturn}
			return val_return
	}
	fnormal_function_oneval=function(PExpression pecall,int expr_oplevel){
		//__init__ test
		pobjfn=getExprFunction(pecall)
		assert(!!pobjfn)
		setFunctionUsed(pobjfn)
		n_args=getFCallNArgs(pecall)
		n_funcargs=getNumberOfArguments(pobjfn)
		if (getCcnv(pobjfn)==g_id_class||getCcnv(pobjfn)==g_id_struct):
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			if isBuiltin(pecaller,g_id_new):
				//ditch whatever parent new when we're sure it's a new or an init call
				pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
				insertCallAt(pecaller_caller,pecaller,function(){return pecall})
				setnop(pecaller)
				pecaller=pecaller_caller
				sccpQueueEval(pecaller)
			if n_args>n_funcargs:
				//it is really an init call, do the necessary translations
				//lock the callee
				pe_check=lockValueCheck(cloneExpr(readPool(pecall+EXPR_OFS_FUNCTION)),g_id_error_class_cannot_change)
				is_stored=0
				if isBuiltin(pecaller,g_id_store):
					//parent-is-a-store case - no temp
					pv_temp=getVariable(readPool(pecaller+EXPR_OFS_ARGS+0))
					is_stored=1
				else
					//copy it to temp first
					pf_owner=getOwningFunction(pecall)
					pv_temp=makevar(pf_owner)
					writePool(pv_temp,g_vtid_UNINIT)
				writePool(pecall,EFLAG_FCALL+n_funcargs)
				as_init=new PExpression[1+n_args-n_funcargs]
				as_init[0]=call(g_id_dot,exprvar(pv_temp),exprstr(g_id_init))
				for i=n_funcargs:n_args-1
					as_init[1+i-n_funcargs]=readPool(pecall+EXPR_OFS_ARGS+i)
					writePool(as_init[1+i-n_funcargs]+EXPR_OFS_CALLER,0)
				pe_init_call=fillepos(indcall(as_init),readPool(pecall+EXPR_OFS_EPOS+0),readPool(pecall+EXPR_OFS_EPOS+1))
				if is_stored:
					transformCode(pecaller,ftransformer_callback.NULL, [pe_check],0,[pe_init_call])
				else
					transformCode(pecall,function(PExpression pe){return fillepos(call(g_id_store,exprvar(pv_temp),pe),readPool(pe+EXPR_OFS_EPOS+0),readPool(pe+EXPR_OFS_EPOS+1))}, [pe_check],exprvar(pv_temp),[pe_init_call])
				return fget_function_return_value(pobjfn,pecall)
		//param checks/sccp
		if n_args<n_funcargs||n_args>n_funcargs&&getCcnv(pobjfn)==g_id_function:
			sfname=getIdString(readPool(pobjfn+FUNCTION_OFS_NAME))
			errorAtExpr(ETYPE_ERROR,pecall,"function '@1' takes @2 arguments, not @3".Replace([
				"@1",sfname,
				"@2",string(n_funcargs),
				"@3",string(n_args)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
		p_param_values=readPool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
		for i=0:n_funcargs-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			t_expected=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+i*2+1),g_vtid_CTVAL)
			if t_expected:
				//t_expected is not a dependency, it must not interrupt the eval
				t=getExprType(pe_argi)
				if t&&!parameterTypeCheck(t_expected,t):
					errorAtExpr(ETYPE_ERROR,pe_argi,"parameter #@3 type mismatch: '@1' expected but '@2' provided".Replace(["@1",dumpType(t_expected),"@2",dumpType(t),"@3",string(i)]))
					continue
				if t&&t!=t_expected:
					//cast
					sccpQueueReach(insertCallAt(pecall,~i,function(){return call(g_id_cast,exprctval(t_expected),pe_argi)}))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
			//sccp
			val_old=readPoolTyped(p_param_values+i*3,TSCCPValue)
			val_new=getExprValue(pe_argi)
			if val_new.tid==g_vtid_CTVAL:
				if readPool(val_new.val)==g_tid_TFunction:
					//Writeln('setFunctionUsed ',dumpObject(val_new.val))
					//pass to param: it's used and its params become vars
					setFunctionUsed(val_new.val)
					setParameterSlotTypes(val_new.val)
				if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
				//it will be passed as a var, so consider it as a var
				val_new.tid=g_vtid_RTVAR
				val_new.val=t
			val_final=mergeValues(pecall,val_old,val_new, pecall,pecall)
			//set param functions as used
			if Platform.BUILD=="debug":
				if !(val_final.tid>=g_vtid_UNINIT&&val_final.tid<=g_vtid_CTVAL):
					Writeln(FormatAsText('bad value at param merge ',pe_argi,' ',dumpExpr(pe_argi,fcolor_abbrv_blocks),' ',getIdString(val_final.tid)))
					assert(0)
			if val_old.tid==val_final.tid&&val_old.val==val_final.val:
				//nothing changed
			else
				//param value changed, queue the ldparam
				writePoolTyped(p_param_values+i*3,val_final)
				pe_ldparam=readPool(p_param_values+i*3+2)
				if pe_ldparam:
					sccpQueueEval(pe_ldparam)
		return fget_function_return_value(pobjfn,pecall)
	}
	ftemplate_instantiation_oneval=function(PExpression pecall,int expr_oplevel){
		pobjfn=getExprFunction(pecall)
		n_args=getFCallNArgs(pecall)
		n_funcargs=getNumberOfArguments(pobjfn)
		if n_args<n_funcargs:
			sfname=getIdString(readPool(pobjfn+FUNCTION_OFS_NAME))
			errorAtExpr(ETYPE_ERROR,pecall,"template function '@1' takes @2 arguments, but only @3 are provided".Replace([
				"@1",sfname,
				"@2",string(n_funcargs),
				"@3",string(n_args)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pedecl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
		//get a desc
		//template_desc=new PCTObject[]
		template_desc=[g_id_function,pobjfn]
		to_lock=new PExpression[]
		arg_mapping=new int[n_funcargs]
		template_desc2=new int[n_funcargs]
		n2=0
		for i=0:n_funcargs-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			peatype=readPool(pedecl+EXPR_OFS_ARGS+1+i*2)
			eflag_sid=readPool(peatype)
			if eflag_sid==EFLAG_STRING+g_id_auto:
				t=getExprType(pe_argi)
				if !t:
					ctval_test=getExprValueAs(pe_argi,g_vtid_CTVAL)
					if ctval_test:
						name='compile-time value'
						if tisbuiltin(ctval_test):
							name='built-in type'
						else if tisclass(ctval_test):
							name='class'
						else if readPool(ctval_test)==g_tid_TFunction&&getCcnv(ctval_test)!=g_id_function:
							name='@1 function'.Replace("@1",getIdString(getCcnv(ctval_test)))
						errorAtExpr(ETYPE_ERROR,pe_argi,"@3 '@1' cannot be passed to auto-typed template parameter '@2', try to use a 'const' template parameter instead".Replace([
							"@1",citeexpr(pe_argi),
							"@2",citeexpr(readPool(pedecl+EXPR_OFS_ARGS+2+i*2)),
							"@3",name]))
					if DEBUG_EVAL_LOG:
						Writeln('  bad arg type at ',i)
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				template_desc.push(t)
				template_desc2[i]=t
				arg_mapping[i]=n2++
			else if eflag_sid==EFLAG_STRING+g_id_const:
				val=getExprValue(pe_argi)
				if val.tid==g_vtid_CNS||val.tid==g_vtid_STR||val.tid==g_vtid_CTVAL:
					if val.tid==g_vtid_CNS:
						eflag_val=EFLAG_CONST
					else if val.tid==g_vtid_STR:
						eflag_val=EFLAG_STRING
					else if val.tid==g_vtid_CTVAL:
						eflag_val=EFLAG_CTVAL
					template_desc.push(eflag_val+val.val)
					template_desc2[i]=eflag_val+val.val
					to_lock.push(pe_argi)
				else
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				arg_mapping[i]=-1
			else
				arg_mapping[i]=n2++
				template_desc2[i]=-1
		arg_mapping_delta_extras=n_funcargs-n2
		//lock the now unchangable variables
		as_checks=new PExpression[]
		foreach pei in to_lock
			as_checks.push(lockValueCheck(pei,g_id_error_const_cannot_change))
		//check existing instantiations
		pobjfn_insted=ctUnique(template_desc)
		if !pobjfn_insted:
			//clone, hack out ldparam
			pobjfn_insted=cloneFunction(pobjfn)
			ctUnique(template_desc)=pobjfn_insted
			if g_readable_c_code:
				sname=new(getIdString(readPool(pobjfn+FUNCTION_OFS_NAME)))
				sname.push('<')
			else
				writePool(pobjfn_insted+FUNCTION_OFS_NAME,readPool(pobjfn+FUNCTION_OFS_NAME))
			writePool(pobjfn_insted+FUNCTION_OFS_ONEVAL,g_cbobj_function_used_oneval)
			writePool(pobjfn_insted+FUNCTION_OFS_ONCGEN,g_cbobj_generated_function_oncgen)
			pedecl_insted=readPool(pobjfn_insted+FUNCTION_OFS_PEDECL)
			//Writeln('>>>>>>>>>>>>>> ',dumpFunction(pobjfn_insted))
			//Writeln(dumpExpr(readPool(pobjfn_insted+FUNCTION_OFS_PEDECL),fcolor_abbrv_blocks))
			n2=0
			for i=0:n_funcargs-1
				peatype=readPool(pedecl_insted+EXPR_OFS_ARGS+1+i*2)
				eflag_sid=readPool(peatype)
				if eflag_sid==EFLAG_STRING+g_id_auto:
					//resolve the type
					assert(arg_mapping[i]==n2)
					//sccpQueueReach(insertCallAt(pedecl_insted,~(1+n2*2),function(){return exprctval(template_desc2[i])}))
					pe_atype_new=exprctval(template_desc2[i])
					writePool(pedecl_insted+EXPR_OFS_ARGS+1+n2*2,pe_atype_new);writePool(pe_atype_new+EXPR_OFS_CALLER,pedecl_insted)
					writePool(pedecl_insted+EXPR_OFS_ARGS+2+n2*2,readPool(pedecl_insted+EXPR_OFS_ARGS+2+i*2))
					n2++
					if g_readable_c_code:
						if sname.back()!='<':
							sname.push(',')
						sname.push(dumpType(template_desc2[i]))
				else if eflag_sid==EFLAG_STRING+g_id_const:
					//nothing
					if g_readable_c_code:
						if sname.back()!='<':
							sname.push(',')
						if (template_desc2[i]&EFLAG_MASK)==EFLAG_CTVAL&&objistype(template_desc2[i]&~EFLAG_MASK):
							sname.push(dumpType(template_desc2[i]&~EFLAG_MASK))
						else
							sname.push(dumpExpr(poolCode(TCnsExpression(){'flags_cid':template_desc2[i]}),NULL))
				else
					//don't touch the arg
					assert(arg_mapping[i]==n2)
					writePool(pedecl_insted+EXPR_OFS_ARGS+1+n2*2,peatype)
					writePool(pedecl_insted+EXPR_OFS_ARGS+2+n2*2,readPool(pedecl_insted+EXPR_OFS_ARGS+2+i*2))
					n2++
				//Writeln(i,' ',dumpExpr(readPool(pobjfn_insted+FUNCTION_OFS_PEDECL),fcolor_abbrv_blocks))
			//Writeln(dumpExpr(readPool(pobjfn_insted+FUNCTION_OFS_PEDECL),fcolor_abbrv_blocks))
			if g_readable_c_code:
				sname.push('>')
				writePool(pobjfn_insted+FUNCTION_OFS_NAME,getid(sname))
			//copy the code and reset # args
			writePool(pedecl_insted+EXPR_OFS_ARGS+1+n2*2,readPool(pedecl_insted+EXPR_OFS_ARGS+1+n_funcargs*2))
			writePool(pedecl_insted,EFLAG_FCALL+n2*2+2)
			//Writeln(dumpExpr(readPool(pobjfn_insted+FUNCTION_OFS_PEDECL),fcolor_abbrv_blocks))
			p_param_values=readPool(pobjfn_insted+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
			freplace_ldparam=function(PExpression pe){
				if isBuiltin(pe,g_id_ldparam):
					pe_paramid=readPool(pe+EXPR_OFS_ARGS+0)
					pe_atype=readPool(pe+EXPR_OFS_ARGS+1)
					paramid=getExprValueAs(pe_paramid,g_vtid_CNS)
					map_to=arg_mapping[paramid]
					if map_to>=0:
						//just change the param id
						writePool(pe_paramid,EFLAG_CONST+getid_const(const_type(CTYPE_INT,Util.bitSize()),i64(map_to)))
						if readPool(pe_atype)==EFLAG_STRING+g_id_auto:
							sccpQueueReach(insertCallAt(pe,~1,function(){return exprctval(template_desc2[paramid])}))
						//update the ldparam pointers
						writePool(p_param_values+map_to*3+2,pe)
					else
						eflag_val_valid=template_desc2[paramid]
						auto pecaller=readPool(pe+EXPR_OFS_CALLER)
						fmake_const_template_arg=function(){
							return poolCode(TCnsExpression(){'flags_cid':eflag_val_valid})
						}
						sccpQueueReach(insertCallAt(pecaller,pe,fmake_const_template_arg))
				if isBuiltin(pe,g_id_function):
					return 0
				return 1
			}
			dfsExpr(readPool(pobjfn_insted+FUNCTION_OFS_CODE),freplace_ldparam)
			writePool(pobjfn_insted+FUNCTION_OFS_TEMPLATE,pobjfn)
			writePool(pobjfn_insted+FUNCTION_OFS_TEMPLATE_EPOS0,readPool(pecall+1))
			writePool(pobjfn_insted+FUNCTION_OFS_TEMPLATE_EPOS1,readPool(pecall+2))
		//hack the call - arg_mapping
		//arg_mapping_delta_extras
		as_new=new PExpression[n_args-arg_mapping_delta_extras+1]
		for i=0:n_args-1
			if i<arg_mapping.n:
				map_to=arg_mapping[i]
				if map_to<0:continue
			else
				map_to=i-arg_mapping_delta_extras
			//writePool(pecall+EXPR_OFS_ARGS+arg_base+map_to,readPool(pecall+EXPR_OFS_ARGS+arg_base+i))
			as_new[1+map_to]=readPool(pecall+EXPR_OFS_ARGS+i)
		foreach pe_argi in as_new
			writePool(pe_argi+EXPR_OFS_CALLER,0)
		//we must relink the user queue to the insted function, so we need to create a new call
		writePool(pecall,EFLAG_FCALL)
		as_new[0]=exprctval(pobjfn_insted)
		pecallee=readPool(pecall+EXPR_OFS_FUNCTION)
		writePool(pecallee+EXPR_OFS_CALLER,0)
		if isBuiltin(pecallee,g_id_dot):
			//call dot case - keep this
			pecallee_clone=cloneExpr(pecallee)
			sccpQueueReach(insertCallAt(pecallee_clone,~1,function(){return as_new[0]}))
			as_new[0]=pecallee_clone
		as_checks.push(lockValueCheck(pecallee,g_id_error_template_cannot_change));
		//Write('>>> ',isBuiltin(pecallee,g_id_dot),' ');Writeln(dumpExpr(pecallee,fcolor_abbrv_blocks))
		if tisclass(pobjfn_insted):
			//classes return a type
			pecall_new=as_new[0]
		else
			pecall_new=indcall(as_new)
		//Write('>>> ');Writeln(dumpExpr(pecall_new,fcolor_abbrv_blocks))
		//as_checks.push(pecall_new)
		addFunctionUser(pobjfn_insted,as_new[0])
		//Writeln('>>> before template transformCode');
		//sccpQueueReach(pecall_new)
		pecaller=readPool(pecall+EXPR_OFS_CALLER)
		if pecaller:
			//we may reach here with pecaller=0 for function types
			sccpQueueEval(pecaller)
			transformCode(pecall,ftransformer_callback.NULL, as_checks,pecall_new,PExpression[].NULL)
		else
			return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobjfn_insted}
		//Writeln('>>> after template transformCode');
		//Writeln('>>>>>>>>>>>>>> ',dumpFunction(pobjfn_insted))
		//Writeln(dumpExpr(readPool(pobjfn_insted+FUNCTION_OFS_PEDECL),NULL))
		//Writeln('==============')
		//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
		//Writeln('<<<<<<<<<<<<<<')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fgenerate_C_fcall=function(PExpression pecall,PCTObject pobjfn,PExpression pe_lambdactx,int is_dtor){
		//error check -- # parameters and their types
		//pobjfn=getExprFunction(pecall)
		n_args=getFCallNArgs(pecall)
		assert(readPool(pobjfn)==g_tid_TFunction)
		queueCodeGen(pobjfn)
		fn=readPoolTyped(pobjfn,TFunction)
		if g_enable_debug_instrumentation&&!is_dtor:
			g_code_buffer.push('(')
			genLineInfoExpr(pecall)
			g_code_buffer.push(',')
		genFunctionName(pobjfn)
		g_code_buffer.push('(')
		if fn.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
			if pe_lambdactx:
				genCode(pe_lambdactx,0)
				g_code_buffer.push(',')
			else
				pf_owner=getOwningFunction(pecall)
				assert(!!pf_owner)
				dlevel=readPool(pf_owner+FUNCTION_OFS_NEST_DEPTH)-fn.nest_depth+1
				if Platform.BUILD=="debug":
					if !(dlevel>=0):
						Writeln(string(dlevel)+" "+dumpExpr(pecall,fcolor_abbrv_blocks))
				assert(dlevel>=0)
				if dlevel==0:
					g_code_buffer.push('s7_BL,')
				else
					g_code_buffer.push('s7_BP')
					for i=0:dlevel-2
						g_code_buffer.push('->p')
					g_code_buffer.push(',')
		else if fn.flags&FFLAG_HAS_FPTR_TAKEN:
			//NULL for the dummy param
			g_code_buffer.push('NULL,')
		if !is_dtor:
			for i=0:n_args-1
				if i:g_code_buffer.push(',')
				genCode(readPool(pecall+EXPR_OFS_ARGS+i),LEVEL_ASSIGNMENT)
		if g_code_buffer.back()==',':
			g_code_buffer.pop()
		g_code_buffer.push(')')
		if g_enable_debug_instrumentation&&!is_dtor:
			g_code_buffer.push(')')
	}
	fgenerated_function_oncgen=function(PExpression pecall,int expr_oplevel){
		//it should have been tested
		pecallee=readPool(pecall+EXPR_OFS_FUNCTION)
		pe_lambdactx=PExpression(0)
		if isBuiltin(pecallee,g_id_ldlambda)||isBuiltin(pecallee,g_id_dot):
			//method call case, need to bind a lambda context
			//in that case, however, the function itself is not generated, so we can use the expr directly
			pe_lambdactx=readPool(pecallee+EXPR_OFS_ARGS+0)
		fgenerate_C_fcall(pecall,getExprFunction(pecall),pe_lambdactx,0)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	g_cbobj_reach_fn_only=registerCompilerCallback(freach_fn_only)
	g_cbobj_expand_inline_oneval=registerCompilerCallback(fexpand_inline_oneval)
	g_cbobj_function_used_oneval=registerCompilerCallback(fnormal_function_oneval)
	g_cbobj_template_instantiation_oneval=registerCompilerCallback(ftemplate_instantiation_oneval)
	g_cbobj_generated_function_oncgen=registerCompilerCallback(fgenerated_function_oncgen)
	ffunction_onreach=function(PExpression pecall,int expr_oplevel){
		//we reach all the types automatically, but nothing else
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		for i=1:2:n_args-3
			petype=readPool(pecall+(EXPR_OFS_ARGS)+i)
			sccpQueueReach(petype)
		auto pecode=readPool(pecall+(EXPR_OFS_ARGS))
		sccpQueueReach(pecode)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	ffunction_oneval=function(PExpression pecall,int expr_oplevel){
		//we do not wait for the types, but we do wait for the ccnv
		val_existing=getExprValue(pecall)
		//duplicate evaluation not prevented... but we do need the eval
		//if !(val_existing.tid==g_vtid_CTVAL):
		//	Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
		//	Writeln(dumpCode(pecall,fcolor_reach_eval))
		assert(val_existing.tid==g_vtid_CTVAL)
		pf=val_existing.val
		fn=readPoolTyped(pf,TFunction)
		if !fn.obj_oneval:
			ccnv=getCcnv(pf)
			//if ccnv==CCNV_META:
			//	//a must-evaluate function
			//	assert(0)
			if ccnv==g_id_inline||ccnv==g_id_inline_loopbody:
				fn.obj_onreach=g_cbobj_reach_fn_only
				fn.obj_oneval=g_cbobj_expand_inline_oneval
				fn.obj_oncgen=0
			else
				//test for template: auto/const represented as strings
				n_args=getFCallNArgs(pecall)
				is_template=0
				for i=1:2:n_args-3
					peatype=readPool(pecall+EXPR_OFS_ARGS+i)
					//t_argi=getExprValueAs(peatype,g_vtid_CTVAL)
					//if t_argi==CTYPE_AUTO
					if isExpr(peatype,EFLAG_STRING):
						//template indeed
						id_t_argi=readPool(peatype)&~EFLAG_MASK
						if id_t_argi==g_id_auto||id_t_argi==g_id_const:
							is_template=1
							break
				if is_template:
					//template function
					fn.obj_oneval=g_cbobj_template_instantiation_oneval
				else
					//normal function
					fn.obj_oneval=g_cbobj_function_used_oneval
					fn.obj_oncgen=g_cbobj_generated_function_oncgen
			writePoolTyped(pf,fn)
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			//if pecall==readPool(pecaller+EXPR_OFS_FUNCTION):
			sccpQueueEval(pecaller)
		if getFFlag(pf)&FFLAG_IS_PARALLEL:
			setParameterSlotTypes(pf)
		return val_existing
	}
	ffunction_oncgen=function(PExpression pecall,int expr_oplevel){
		//avoid generating in-line function expressions
		if expr_oplevel!=LEVEL_FUNCTION_HACK:
			//coulddo: immediate-call case
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//function decl, inner code
		nargs=readPool(pecall)&~EFLAG_MASK
		val_existing=getExprValue(pecall)
		if val_existing.tid!=g_vtid_CTVAL:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=val_existing.val
		fn=readPoolTyped(pobjfn,TFunction)
		//scan function for the necessary information
		treturn=getReturnType(pobjfn)
		pecode=readPool(fn.pe_decl+(EXPR_OFS_ARGS)+nargs-1)
		is_type_only=isExpr(pecode,EFLAG_STRING)
		assert(is_type_only||isBuiltin(pecode,g_id_block))
		is_type_only|=(pobjfn==getStdObject(0,STDTYPE_VARIANT))
		//Writeln(pobjfn,' ',getStdObject(0,STDTYPE_VARIANT))
		//could use a dfs
		n_funcargs=(nargs-2)>>1
		var_argnames=new int[n_funcargs]
		ffind_argnames=function(PExpression pe){
			if isBuiltin(pe,g_id_function):return 0
			if isBuiltin(pe,g_id_ldparam):
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				arg_id=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_CNS)
				if isBuiltin(pecaller,g_id_store):
					pe_var_i=readPool(pecaller+EXPR_OFS_ARGS+0)
					var_argnames[arg_id]=getVariable(pe_var_i)
					assert(!!var_argnames[arg_id])
				else
					val0=getExprValue(pe)
					pobj_var=makevar(pobjfn)
					var_argnames[arg_id]=pobj_var
					writePool(pobj_var+0,val0.tid)
					writePool(pobj_var+1,val0.val)
					replaceExpr(pe,exprvar(pobj_var))
			return 1
		}
		dfsExpr(pecode,ffind_argnames)
		//declaration
		if !is_type_only:
			auto sbk=g_code_buffer
			g_code_buffer=g_forward_buffer
			if !(fn.flags&FFLAG_EXPORTED):
				g_code_buffer.push('static ')
			if !treturn||tisstruct(treturn):
				g_code_buffer.push(FormatAsText("void"))
			else
				genType(treturn)
			g_code_buffer.push(' ')
			genFunctionName(pobjfn)
			g_code_buffer.push('(')
			pf_parent=0
			if fn.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
				pf_parent=getOwningFunction(readPool(fn.pe_decl+EXPR_OFS_CALLER))
				genClassName(pf_parent)
				g_code_buffer.push("*,")
			else if fn.flags&FFLAG_HAS_FPTR_TAKEN:
				g_code_buffer.push('void*,')
			for i=1:2:nargs-3
				if i>1:
					g_code_buffer.push(',')
				petype=readPool(fn.pe_decl+(EXPR_OFS_ARGS)+i)
				targi=getExprValueAs(petype,g_vtid_CTVAL)
				if !targi:
					errorAtExpr(ETYPE_ERROR,petype,"invalid argument type '"+citeexpr(petype)+"'")
					g_code_buffer.push('err!')
				else
					genType(targi)
			if g_code_buffer.back()==',':
				g_code_buffer.pop()
			g_code_buffer.push(');')
			g_code_buffer=sbk
		//definition
		if !is_type_only:
			if !treturn||tisstruct(treturn):
				g_code_buffer.push(FormatAsText("void"))
			else
				genType(treturn)
			g_code_buffer.push(' ')
			genFunctionName(pobjfn)
			g_code_buffer.push('(')
			if fn.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
				genClassName(pf_parent)
				g_code_buffer.push("* s7_BP,")
			else if fn.flags&FFLAG_HAS_FPTR_TAKEN:
				g_code_buffer.push('void* s7_unused,')
			//Writeln(dumpCode(pecall,fcolor_reach_eval))
			for i=1:2:nargs-3
				if i>1:
					g_code_buffer.push(',')
				petype=readPool(fn.pe_decl+(EXPR_OFS_ARGS)+i)
				targi=getExprValueAs(petype,g_vtid_CTVAL)
				if !targi:
					errorAtExpr(ETYPE_ERROR,petype,"invalid argument type '"+citeexpr(petype)+"'")
					g_code_buffer.push('err!')
				else
					genType(targi)
				if !var_argnames[i>>1]
					//this is valid - it may have gotten const-folded
					//if Platform.BUILD=="debug":
					//	Writeln(dumpObject(pobjfn),", failed to find parameter #",i>>1,', fn.pe_decl=',fn.pe_decl)
					//	dumpExpr(fn.pe_decl,fcolor_reach_eval)
					g_code_buffer.push(' s7_d')
					g_code_buffer.push(string(i>>1))
				else
					assert(!!var_argnames[i>>1])
					g_code_buffer.push(' ')
					genVar(var_argnames[i>>1])
					//g_code_buffer.push(toBase32(var_argnames[i>>1]))
			if g_code_buffer.back()==',':
				g_code_buffer.pop()
			g_code_buffer.push('){')
		//for is_type_only, the context is never actually used, but we need to generate the type anyway
		if is_type_only||(fn.flags&FFLAG_LAMBDA_NEEDS_CONTEXT):
			//generate the lambda struct decl, and new it
			sbk=g_code_buffer
			g_code_buffer=new string
			genClassName(pobjfn)
			g_code_buffer.push('{')
			got_anything=0
			if !tisstruct(pobjfn):
				got_anything=1
				if Util.bitSize()>32:
					g_code_buffer.push('long long ')
				else
					g_code_buffer.push('int ')
				g_code_buffer.push('s7rc;')
			if fn.flags&FFLAG_LAMBDA_NEEDS_RTTI:
				got_anything=1
				g_code_buffer.push('void* s7rtti;')
			if fn.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER:
				got_anything=1
				//parent pointer
				genClassName(pf_parent)
				g_code_buffer.push("* p;")
			for i=0:fn.nlambda_vars-1
				got_anything=1
				pobj_var=readPool(fn.plambda_vars+i)
				t=getValueType(readPoolTyped(pobj_var,TSCCPValue))
				if !t:
					//Writeln(dumpExpr(pecall,fcolor_epos),' ',pobj_var,' ',getIdString(dump_getObjectName(pobj_var)),' ',dumpExpr(exprvar(pobj_var),NULL))
					errorAtExpr(ETYPE_LOW_LEVEL_ERROR,pecall,"uninitialized variable '@1' cannot be accessed in other functions".Replace(["@1",getIdString(dump_getObjectName(pobj_var))]))
					continue
				//Writeln(dumpType(t),' ',dumpObject(pobj_var))
				genType(t)
				if tisstruct(t):g_code_buffer.pop()
				g_code_buffer.push(' m_')
				g_code_buffer.push(toBase32(pobj_var))
				g_code_buffer.push(';')
			if !got_anything:
				g_code_buffer.push('char dummy;')
			g_code_buffer.push('};')
			//need a dep sort later
			g_struct_code_per_type[pobjfn]=g_code_buffer
			g_all_struct_types.push(pobjfn)
			g_code_buffer=sbk
			if !is_type_only&&!tisstruct(pobjfn):
				genClassName(pobjfn)
				g_code_buffer.push('* s7_BL=(')
				genClassName(pobjfn)
				g_code_buffer.push('*)memset(malloc(sizeof(')
				genClassName(pobjfn)
				g_code_buffer.push(')),0,sizeof(')
				genClassName(pobjfn)
				g_code_buffer.push('));')
		if is_type_only:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		sbak=g_code_buffer
		g_code_buffer=new string
		cgPushScope()
		if g_enable_debug_instrumentation&&(fn.flags&FFLAG_EXPORTED):
			g_code_buffer.push('spapDebugV2Start();')
		if (fn.flags&FFLAG_LAMBDA_NEEDS_CONTEXT)&&(fn.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER):
			//lambda arg -> lambda parent pointer
			g_code_buffer.push('s7_BL->p=s7_BP;')
		if (fn.flags&FFLAG_LAMBDA_NEEDS_RTTI)&&(fn.flags&FFLAG_LAMBDA_NEEDS_CONTEXT):
			//for function-pointers that use NULL as a context substitute, we don't have to set the RTTI
			g_code_buffer.push('s7_BL->s7rtti=(void*)')
			pobjfn_dtor=readPool(pobjfn+FUNCTION_OFS_FINALIZER)
			genFunctionName(pobjfn_dtor)
			queueCodeGen(pobjfn_dtor)
			g_code_buffer.push(';')
		if pobjfn==g_t_root_namespace&&(fn.flags&FFLAG_LAMBDA_NEEDS_CONTEXT):
			sbk=g_code_buffer
			g_code_buffer=g_forward_buffer
			genClassName(pobjfn)
			g_code_buffer.push('* s7_BR=NULL;')
			g_code_buffer=sbk
			g_code_buffer.push('s7_BR=s7_BL;')
		id_return_label=getReturnLabel(pobjfn)
		bk_label=g_current_labels[id_return_label]
		g_current_labels[id_return_label]=pecall
		sbk_return=g_local_return_buffer
		g_local_return_buffer=new string
		genCode(pecode,0)
		g_code_buffer.push(g_local_return_buffer)
		g_local_return_buffer=sbk_return
		g_current_labels[id_return_label]=bk_label
		cgPopScope()
		sbak.push(g_code_buffer)
		g_code_buffer=sbak
		g_code_buffer.push('}')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_function,ffunction_onreach,ffunction_oneval,ffunction_oncgen,FFLAG_STATEMENT_HOST|FFLAG_SPECIAL)
	fc_return_oncgen=function(PExpression pecall,int expr_oplevel){
		id_return_label=getReturnLabel(getOwningFunction(pecall))
		my_label=g_current_labels[id_return_label]
		if my_label&0x80000000:
			//generate the return label
			g_code_buffer.push('s7_lb')
			g_code_buffer.push(toBase32(my_label&0x7fffffff))
			g_code_buffer.push(':')
		if g_enable_debug_instrumentation:
			g_code_buffer.push("spapPopCallStack()")
		if readPool(pecall)==EFLAG_FCALL+0:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
		val=getExprValue(pe_opr)
		if val.tid==g_vtid_UNINIT:
			//it didn't return anything
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		t=getValueTypeEx(pecall,val)
		if tisstruct(t):
			//should have been hacked
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		g_local_return_buffer.push('return ')
		sbk=g_code_buffer
		g_code_buffer=g_local_return_buffer
		genCode(pe_opr,0)
		g_local_return_buffer.push(';')
		g_code_buffer=sbk
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	//returning counts as side effect
	registerPrimitive(g_id_C_return,fcompiler_callback.NULL,fdummy_callback,fc_return_oncgen,FFLAG_SPECIAL|FFLAG_RC_HAS_SIDE_EFFECT|FFLAG_IS_PRELIVE)
	ffunction_type_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		pe_rettype=readPool(pecall+EXPR_OFS_ARGS+n_args-1)
		val=getExprValue(pe_rettype)
		if val.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		t_return=getExprValueAs(pe_rettype,g_vtid_CTVAL)
		//t_return==0 is valid
		t_function=makeFunctionTypeRaw(pecall,pecall,t_return,0)
		if !t_function:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_CTVAL,'val':t_function}
	}
	registerPrimitive(g_id_function_type,fcompiler_callback.NULL,ffunction_type_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	////////////
	fexport_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==2)
		id_export_name=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_STR)
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if pobjfn:
			setFunctionUsed(pobjfn)
		if !id_export_name||!pobjfn:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		fn=readPoolTyped(pobjfn,TFunction)
		if !(fn.flags&FFLAG_EXPORTED):
			if !(fn.flags&FFLAG_CGEN_QUEUED):
				fn.flags|=FFLAG_CGEN_QUEUED
				g_gencode_queue.push(fn.pe_decl)
			fn.flags|=FFLAG_EXPORTED
			fn.id_name=id_export_name
			writePoolTyped(pobjfn,fn)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fexport_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==2)
		id_export_name=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_STR)
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if !id_export_name||!pobjfn:
			errorAtExpr(ETYPE_ERROR,pecall,"in __export(name,function), both parameters have to be constants")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//fn=readPoolTyped(pobjfn,TFunction)
		//if !(fn.flags&FFLAG_EXPORTED):
		//	if !(fn.flags&FFLAG_CGEN_QUEUED):
		//		fn.flags|=FFLAG_CGEN_QUEUED
		//		g_gencode_queue.push(fn.pe_decl)
		//	fn.flags|=FFLAG_EXPORTED
		//	fn'id_name':id_export_name
		//	writePoolTyped(pobjfn,fn)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	//g_id_export
	registerPrimitive(g_id_export,fcompiler_callback.NULL,fexport_oneval,fexport_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	////////////
	fcimport_eval=function(PExpression pecall,int expr_oplevel){
		pobjfn=getExprFunction(pecall)
		if !pobjfn:
			assert(0)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		fn=readPoolTyped(pobjfn,TFunction)
		pe_decl=fn.pe_decl
		assert((readPool(pe_decl)&~EFLAG_MASK)>=3)
		petype=readPool(pe_decl+(EXPR_OFS_ARGS+0))
		t=evaluateAsType(petype)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//Writeln('^_^')
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	cbobj_cimport_eval=registerCompilerCallback(fcimport_eval)
	fcimport_cgen=function(PExpression pecall,int expr_oplevel){
		pobjfn=getExprFunction(pecall)
		if !pobjfn:
			assert(0)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		fn=readPoolTyped(pobjfn,TFunction)
		pe_decl=fn.pe_decl
		n_args_decl=getFCallNArgs(pe_decl)
		assert(n_args_decl>=3)
		pe_fname=readPool(pe_decl+EXPR_OFS_ARGS+1)
		id_func=getExprValueAs(pe_fname,g_vtid_STR)
		id_header=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+2),g_vtid_STR)
		if !id_func:
			errorAtExpr(ETYPE_ERROR,pe_fname,"C function name has to be a constant, not '@1'".Replace(["@1",citeexpr(pe_fname)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if n_args_decl>3:
			for i=3:2:n_args_decl-2
				pe_c_name=readPool(pe_decl+EXPR_OFS_ARGS+i);id_c_name=getExprValueAs(pe_c_name,g_vtid_STR)
				pe_c_file=readPool(pe_decl+EXPR_OFS_ARGS+i+1);id_c_file=getExprValueAs(pe_c_file,g_vtid_STR)
				if !id_c_name:
					errorAtExpr(ETYPE_ERROR,pe_c_name,"JSON key name has to be a constant, not '@1'".Replace(["@1",citeexpr(pe_c_name)]))
				if !id_c_file:
					errorAtExpr(ETYPE_ERROR,pe_c_file,"JSON file name has to be a constant, not '@1'".Replace(["@1",citeexpr(pe_c_file)]))
				if id_c_name&&id_c_file:
					arr=g_json_pool[id_c_name]
					if !arr:
						arr=new int[]
						g_json_pool[id_c_name]=arr
					arr.push(id_c_file)
		if id_header&&!(fn.flags&FFLAG_C_HEADER_INCLUDED):
			setFFlag(pobjfn,FFLAG_C_HEADER_INCLUDED)
			g_c_headers.push(id_header)
		if g_enable_debug_instrumentation:
			g_code_buffer.push('(')
			genLineInfoExpr(pecall)
			g_code_buffer.push(',')
		g_code_buffer.push(getIdString(id_func))
		g_code_buffer.push('(')
		n_args=getFCallNArgs(pecall)
		for i=0:n_args-1
			if i:g_code_buffer.push(',')
			genCode(readPool(pecall+EXPR_OFS_ARGS+i),LEVEL_ASSIGNMENT)
		g_code_buffer.push(')')
		if g_enable_debug_instrumentation:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	g_cbobj_cimport_cgen=registerCompilerCallback(fcimport_cgen)
	fcimport_oneval=function(PExpression pecall,int expr_oplevel){
		val_existing=getExprValue(pecall)
		if val_existing.tid==g_vtid_CTVAL||val_existing.tid==g_vtid_RTVAR:
			//prevent duplicate evaluation
			return val_existing
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args<3:
			errorAtExpr(ETYPE_ERROR,pecall,"__c_function(type,'function','header.h' [,'json-key','json-file', ...]) has to take at least 3 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_CTVAL,'val':poolObject(TFunction(){
				'flags':FFLAG_IMPORTED,
				'pe_decl':pecall,
				'obj_oneval':cbobj_cimport_eval,
				'obj_oncgen':g_cbobj_cimport_cgen
			})}
	}
	registerPrimitive(g_id_c_function,fcompiler_callback.NULL,fcimport_oneval,fdummy_callback,FFLAG_SPECIAL)
	////////////
	fstore_onreach=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args!=2&&n_args!=3:
			errorAtExpr(ETYPE_ERROR,pecall,"__store(variable,expr) can only take 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pevarname=readPool(pecall+(EXPR_OFS_ARGS))
		if !isExpr(pevarname,EFLAG_VARIABLE):
			errorAtExpr(ETYPE_ERROR,pecall,"the variable in __store(variable,expr) has to be a variable")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_var=getVariable(pevarname)
		if isVariable(pobj_var):
			//insert the expression into a store chain
			//Writeln('chain ',pobj_var,' ',pecall)
			assert(readPool(pobj_var+VAR_OFS_STORE_QUEUE)!=pecall)
			writePool(pecall+EXPR_OFS_NEXT_V_USER,readPool(pobj_var+VAR_OFS_STORE_QUEUE))
			writePool(pobj_var+VAR_OFS_STORE_QUEUE,pecall)
		sccpQueueReach(readPool(pecall+((EXPR_OFS_ARGS)+1)))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fstore_oneval=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		assert(n_args==2||n_args==3)
		pevarname=readPool(pecall+(EXPR_OFS_ARGS))
		if (readPool(pevarname)&EFLAG_MASK)!=EFLAG_VARIABLE:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_var=getVariable(pevarname)
		pe_value=readPool(pecall+((EXPR_OFS_ARGS)+1))
		return fstore_eval_core(pecall,pobj_var,pe_value,1)
	}
	fstore_oncgen=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		assert(n_args==2||n_args==3)
		pe_var=readPool(pecall+EXPR_OFS_ARGS+0)
		peexpr=readPool(pecall+EXPR_OFS_ARGS+1)
		if isBuiltin(peexpr,g_id_ldparam):
			//do not generate ldparam
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//somehow, this is still needed
		val=getExprValue(pe_var)
		if val.tid==g_vtid_CNS||val.tid==g_vtid_CTVAL||val.tid==g_vtid_STR:
			//const-folded
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//can't really update a parameter
		pobj_var=getVariable(pe_var)
		if pobj_var&&testUserFlag(pobj_var,VAR_FLAG_PARAM):
			errorAtExpr(ETYPE_ERROR,pecall,"parameter '@1' can't be modified".Replace(["@1",citeexpr(pe_var)]))
			//Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
			//Writeln(">>> "+dumpCode(pecall,fcolor_reach_eval))
			//assert(0)
		genCode(pe_var,LEVEL_STORE_HACK)
		g_code_buffer.push('=')
		genCode(peexpr,LEVEL_ASSIGNMENT)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_store,fstore_onreach,fstore_oneval,fstore_oncgen,FFLAG_SPECIAL)
	////////////
	fcast_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=readPool(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"__cast has to take 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		petype=readPool(pecall+EXPR_OFS_ARGS+0)
		pesrc=readPool(pecall+EXPR_OFS_ARGS+1)
		t_result=getExprValueAs(petype,g_vtid_CTVAL)
		if !t_result:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		val_src=getExprValue(pesrc)
		if val_src.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val_src.tid==g_vtid_CNS:
			if tisbuiltin(t_result):
				ca=Util.ctNumber(val_src.val)
				//if !(u32(readPool(t_result+1))<u32(CTYPE_COUNT)):
				//	Writeln(dumpExpr(pecall,NULL))
				//	Writeln(dumpType(t_result))
				//	assert(0)
				//if dumpType(t_result)=="f64":
				//	Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
				//Writeln(dumpExpr(pecall,NULL)+" "+dumpType(t_result))
				ca=castConst(ca,t_result)
				if ca.type==CTYPE_INVALID:
					errorAtExpr(ETYPE_ERROR,pecall,"invalid cast '@1'".Replace(["@1",citeexpr(pecall)]))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ca.type,ca.val_bin)}
			if tisclass(t_result)&&val_src.val==g_cid_null:
				//typed NULL
				ca=Util.ctNumber(val_src.val)
				ca=castConst(ca,t_result)
				assert(ca.type!=CTYPE_INVALID)
				return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ca.type,ca.val_bin)}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t_result}
	}
	fcast_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=readPool(pecall)
		if n_args!=2:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		petype=readPool(pecall+EXPR_OFS_ARGS+0)
		pesrc=readPool(pecall+EXPR_OFS_ARGS+1)
		t_result=getExprValueAs(petype,g_vtid_CTVAL)
		if !t_result:
			errorAtExpr(ETYPE_ERROR,pecall,"invalid target type for __cast")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//__cast is just for forced object casts, C-like basic type casts, and stuff
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('(')
		genType(t_result)
		g_code_buffer.push(')')
		genCode(pesrc,LEVEL_PREFIX)
		if need_bracket:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_cast,fcompiler_callback.NULL,fcast_oneval,fcast_oncgen,FFLAG_SPECIAL)
	////////////
	fblock_oneval=function(PExpression pecall,int expr_oplevel){
		//er=readPoolTyped(pecall,TExpression)
		//n_args=(er.flags_n_args&~EFLAG_MASK)
		//if n_args<1:return TSCCPValue(){'tid':g_vtid_UNINIT}
		//return getExprValue(readPool(pecall+EXPR_OFS_ARGS+n_args-1))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fblock_oncgen=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if expr_oplevel>0:
			assert(0)
		else
			for i=0:n_args-1
				genCode(readPool(pecall+EXPR_OFS_ARGS+i),0)
				if g_code_buffer.n&&g_code_buffer.back()!=';':
					g_code_buffer.push(';')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_block,fcompiler_callback.NULL,fblock_oneval,fblock_oncgen,FFLAG_SPECIAL)
	////////////
	fblockex_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args>0)
		p_args=0
		id_word=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+p_args),g_vtid_STR)
		is_loop=0
		if id_word==g_id_for:
			is_loop=1
			g_code_buffer.push('for(;;){')
			p_args++
			id_word=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+p_args),g_vtid_STR)
		if id_word==g_id_blockex:
			//it's a host
			p_args++
			id_word=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+p_args),g_vtid_STR)
			bk_label=g_current_labels[id_word]
			my_label=(is_loop&&(id_word==g_id_break||id_word==g_id_continue)?-1:pecall)
			g_current_labels[id_word]=my_label
			p_args++
			bk_label2=0;has_word2=0;id_word2=0
			if p_args<n_args-1:
				//we're hosting another type, break+continue
				has_word2=1
				id_word2=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+p_args),g_vtid_STR)
				bk_label2=g_current_labels[id_word2]
				my_label2=(is_loop&&(id_word2==g_id_break||id_word2==g_id_continue)?-1:pecall)
				g_current_labels[id_word2]=my_label2
				p_args++
			genCode(readPool(pecall+EXPR_OFS_ARGS+p_args),0)
			if has_word2:
				my_label=g_current_labels[id_word2]
				if my_label!=-1&&(my_label&0x80000000):
					g_code_buffer.push('s7_lb')
					g_code_buffer.push(toBase32(my_label&0x7fffffff))
					g_code_buffer.push(':;')
				g_current_labels[id_word2]=bk_label2
			my_label=g_current_labels[id_word]
			if my_label!=-1&&(my_label&0x80000000):
				g_code_buffer.push('s7_lb')
				g_code_buffer.push(toBase32(my_label&0x7fffffff))
				g_code_buffer.push(':;')
			g_current_labels[id_word]=bk_label
		else
			my_label=g_current_labels[id_word]
			if my_label==-1:
				g_code_buffer.push(getIdString(id_word))
				g_code_buffer.push(';')
			else
				if !my_label:
					errorAtExpr(ETYPE_ERROR,pecall,"can't find a corresponding scope for this '@1'".Replace(["@1",getIdString(id_word)]))
				g_code_buffer.push('goto s7_lb')
				g_code_buffer.push(toBase32(my_label&0x7fffffff))
				g_code_buffer.push(';')
				if !(my_label&0x80000000):
					g_current_labels[id_word]=(my_label|0x80000000)
		if is_loop:
			g_code_buffer.push('}')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	//coulddo: separate break/continue/loop: break/continue has side effect, loop doesn't... but it's a bad idea to defer anything beyond a loop, even if it's pure
	registerPrimitive(g_id_blockex,fcompiler_callback.NULL,fdummy_callback,fblockex_oncgen,FFLAG_SPECIAL|FFLAG_STATEMENT_HOST|FFLAG_RC_HAS_SIDE_EFFECT|FFLAG_IS_PRELIVE)
	////////////
	fif_onreach=function(PExpression pecall,int expr_oplevel){
		//reach the cond and the clause values, nothing else
		n_args=getFCallNArgs(pecall)
		for i=0:2:n_args-2
			sccpQueueReach(readPool(pecall+EXPR_OFS_ARGS+i))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fif_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		pe_cond=readPool(pecall+EXPR_OFS_ARGS+0)
		val_cond=getExprValue(pe_cond)
		if val_cond.tid==g_vtid_UNINIT:
			//if is invalid before the condition can be evaluated
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val_cond.tid==g_vtid_CNS||val_cond.tid==g_vtid_STR:
			//compare with the clause values and pick one
			cns_branch=computeConstIfBranch(pecall,val_cond)
			sccpQueueReach(readPool(pecall+EXPR_OFS_ARGS+cns_branch))
		else
			//reach all clauses
			for i=1:2:n_args-1
				sccpQueueReach(readPool(pecall+EXPR_OFS_ARGS+i))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fif_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(!expr_oplevel)
		n_args=getFCallNArgs(pecall)
		if n_args==4:
			pe_case_value=readPool(pecall+EXPR_OFS_ARGS+2)
			val_case_value=getExprValue(pe_case_value)
			if isValueZero(val_case_value):
				//it's a normal if
				g_code_buffer.push('if(')
				genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_ASSIGNMENT)
				g_code_buffer.push('){')
				genCode(readPool(pecall+EXPR_OFS_ARGS+1),0)
				g_code_buffer.push('}')
				pe_else=readPool(pecall+EXPR_OFS_ARGS+3)
				if (readPool(pe_else)&EFLAG_MASK)==EFLAG_CONST:
					//no else
				else
					g_code_buffer.push('else{')
					genCode(pe_else,0)
					g_code_buffer.push('}')
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		errored=0
		for i=2:2:n_args-2
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			val_i=getExprValue(pe_argi)
			if val_i.tid!=g_vtid_CNS:
				errorAtExpr(ETYPE_ERROR,pe_argi,"case label must be an integer but '@1' isn't one".Replace("@1",citeexpr(pe_argi)))
				errored=1
		if !errored:
			//todo: duplicate labels, etc
			g_code_buffer.push('switch(')
			genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_ASSIGNMENT)
			g_code_buffer.push('){')
			for i=2:2:n_args-2
				pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
				val_i=getExprValue(pe_argi)
				assert(val_i.tid==g_vtid_CNS)
				g_code_buffer.push('case ')
				genConst(val_i.val)
				g_code_buffer.push(':')
				///////////////
				pe_body=readPool(pecall+EXPR_OFS_ARGS+i+1)
				if readPool(pe_body)==EFLAG_STRING+g_id_case:
					//fall through
					g_code_buffer.push(';')
				else
					genCode(pe_body,0)
					g_code_buffer.push('break;')
			g_code_buffer.push('default:')
			genCode(readPool(pecall+EXPR_OFS_ARGS+1),0)
			g_code_buffer.push(';}')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_if,fif_onreach,fif_oneval,fif_oncgen,FFLAG_SPECIAL|FFLAG_STATEMENT_HOST)
	////////////
	fassert_ctval_oneval=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args<2:return TSCCPValue(){'tid':g_vtid_UNINIT}
		pearg0=readPool(pecall+EXPR_OFS_ARGS+0)
		id_error=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_STR)
		val=getExprValue(pearg0)
		if val.tid==g_vtid_RTVAR:
			errorAtExpr(ETYPE_ERROR,pearg0,new(getIdString(id_error)).Replace("@1",citeexpr(pearg0)))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_assert_ctval,fcompiler_callback.NULL,fassert_ctval_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	////////////
	fldparam_oneval=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		assert(n_args==3)
		//serial id, type, name
		pobjfn=getOwningFunction(pecall)
		p_param_values=readPool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
		param_id=getExprValueAs(readPool(pecall+(EXPR_OFS_ARGS+0)),g_vtid_CNS)
		return readPoolTyped(p_param_values+param_id*3,TSCCPValue)
		//petype=readPool(pecall+(EXPR_OFS_ARGS+1))
		//t=evaluateAsType(petype)
		//if !t:
		//	//errorAtExpr(ETYPE_ERROR,petype,FormatAsText("invalid type '",citeexpr(petype),"'"))
		//	return TSCCPValue(){'tid':g_vtid_UNINIT}
		//return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	registerPrimitive(g_id_ldparam,fcompiler_callback.NULL,fldparam_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	////////////
	faliased_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		auto t=getValueType(getExprValue(readPool(pecall+EXPR_OFS_ARGS+0)))
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		else
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	registerPrimitive(g_id_aliased,fcompiler_callback.NULL,faliased_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL|FFLAG_RC_HAS_SIDE_EFFECT)
	registerPrimitive(g_id_nop,fcompiler_callback.NULL,fcompiler_callback.NULL,fcompiler_callback.NULL,FFLAG_BUILTIN_HACK)
	registerPrimitive(g_id_dummy_use,fcompiler_callback.NULL,fcompiler_callback.NULL,fcompiler_callback.NULL,FFLAG_BUILTIN_HACK)
	//////////////////////////////////////
	//dotting
	fldlambda_oneval=function(PExpression pecall,int expr_oplevel){
		pobj_var=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if !pobj_var:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return readPoolTyped(pobj_var,TSCCPValue)
	}
	fldlambda_oncgen=function(PExpression pecall,int expr_oplevel){
		//if expr_oplevel&&expr_oplevel<LEVEL_POSTFIX:
		//	got_bracket=1
		//	g_code_buffer.push('(')
		debug_instrumented=0
		if g_enable_debug_instrumentation:
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			if !isBuiltin(pecaller,g_id_operator_and)||readPool(pecaller)!=EFLAG_FCALL+1:
				//avoid instrumenting when we're the operand of an unary &
				debug_instrumented=1
				g_code_buffer.push('(')
				genLineInfoExpr(pecall)
				g_code_buffer.push(',')
		pobj_var=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if readPool(pobj_var)==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if Platform.BUILD=="debug":
			if readPool(pobj_var)!=g_vtid_RTVAR:
				Writeln(dumpExpr(pecall,fcolor_abbrv_blocks))
		assert(readPool(pobj_var)==g_vtid_RTVAR)
		t_member=readPool(pobj_var+1)
		need_bracket=0
		if tisstruct(t_member):
			//ldlambda cgen for struct
			if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
				need_bracket=1
				g_code_buffer.push('(')
			g_code_buffer.push('&')
		genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_POSTFIX)
		g_code_buffer.push('->m_')
		g_code_buffer.push(toBase32(pobj_var))
		if need_bracket:
			g_code_buffer.push(')')
		if debug_instrumented:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_ldlambda,fcompiler_callback.NULL,fldlambda_oneval,fldlambda_oncgen,FFLAG_SPECIAL)
	fstlambda_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(!expr_oplevel)
		if g_enable_debug_instrumentation:
			genLineInfoExpr(pecall)
			g_code_buffer.push(';')
		genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_POSTFIX)
		g_code_buffer.push('->m_')
		pobj_var=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		g_code_buffer.push(toBase32(pobj_var))
		g_code_buffer.push('=')
		genCode(readPool(pecall+EXPR_OFS_ARGS+2),LEVEL_ASSIGNMENT)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_stlambda,fcompiler_callback.NULL,fcompiler_callback.NULL,fstlambda_oncgen,FFLAG_SPECIAL)
	fgetparentctx_oneval=function(PExpression pecall,int expr_oplevel){
		pe_levels=readPool(pecall+EXPR_OFS_ARGS+0)
		val=getExprValue(pe_levels)
		if val.tid==g_vtid_CTVAL:
			//the smart version, translate later
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':val.val}
		n_levels=getExprValueAs(pe_levels,g_vtid_CNS)
		//assert(!n_levels)
		if n_levels:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		t=getOwningFunction(pecall)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		else
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fgetparentctx_oncgen=function(PExpression pecall,int expr_oplevel){
		n_levels=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CNS)
		if n_levels==0x80000000:
			//root
			g_code_buffer.push('s7_BR')
		else
			assert(n_levels>=0)
			if !n_levels:
				pf_owner=getOwningFunction(pecall)
				if !(getFFlag(pf_owner)&FFLAG_LAMBDA_NEEDS_CONTEXT):
					//unnecessary context, use NULL
					g_code_buffer.push('NULL')
				else
					g_code_buffer.push('s7_BL')
			else
				g_code_buffer.push('s7_BP')
			for j=1:n_levels-1
				g_code_buffer.push('->p')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_get_lambda_context,fcompiler_callback.NULL,fgetparentctx_oneval,fgetparentctx_oncgen,FFLAG_SPECIAL)
	//return __get_lambda_context(0)
	fdot_oneval=function(PExpression pecall,int expr_oplevel){
		//__dot(obj,"member")
		//hack for template
		pe_id_name=readPool(pecall+EXPR_OFS_ARGS+1)
		if isExpr(pe_id_name,EFLAG_CTVAL):
			val=getExprValueAs(pe_id_name,g_vtid_CTVAL)
			if !isVariable(val):
				return TSCCPValue(){'tid':g_vtid_CTVAL,'val':val}
		//hack for special members: array new, tuple[], function.call
		id_member=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_STR)
		if id_member==g_id_operator_bracket||id_member==g_id_set_operator_bracket:
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			if readPool(pecaller+EXPR_OFS_FUNCTION)==pecall:
				assert(readPool(pecaller)==EFLAG_FCALL+1+(id_member==g_id_set_operator_bracket))
				peobj=readPool(pecall+EXPR_OFS_ARGS+0)
				pe_subscript=readPool(pecaller+EXPR_OFS_ARGS+0)
				//type[n] or type[type]
				t_element=getExprValueAs(peobj,g_vtid_CTVAL)
				if id_member==g_id_operator_bracket&&t_element&&(tisbuiltin(t_element)||tisclass(t_element)):
					pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
					sccpQueueReach(insertCallAt(pecaller_caller,pecaller,function(){return call(g_id_array_or_map,peobj,pe_subscript)}))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				//tuple[CNS], this is writable
				t_object=getExprType(peobj)
				if t_object&&tistuple(t_object):
					//g_id_tuple_bracket
					if id_member==g_id_operator_bracket:	
						pe_tuple_bracket=call(g_id_tuple_bracket,peobj,pe_subscript)
					else
						pe_tuple_bracket=call(g_id_tuple_bracket,peobj,pe_subscript,readPool(pecaller+EXPR_OFS_ARGS+1))
					replaceExpr(pecaller,pe_tuple_bracket)
					return TSCCPValue(){'tid':g_vtid_UNINIT}
		if id_member==g_id_call:
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			if readPool(pecaller+EXPR_OFS_FUNCTION)==pecall:
				peobj=readPool(pecall+EXPR_OFS_ARGS+0)
				pobjfn_called=getExprValueAs(peobj,g_vtid_CTVAL)
				//function.call
				if pobjfn_called&&readPool(pobjfn_called)==g_tid_TFunction||tisfunction(getExprType(peobj)):
					if readPool(pecaller)!=EFLAG_FCALL+1:
						errorAtExpr(ETYPE_ERROR,pecaller,"indirect call '@1' can only take one tuple as argument".Replace("@1",citeexpr(pecaller)))
						return TSCCPValue(){'tid':g_vtid_UNINIT}
					pe_arg=readPool(pecaller+EXPR_OFS_ARGS+0)
					replaceExpr(pecaller,call(g_id_tuple_call,peobj,pe_arg))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
		//actual member handling
		pe_member_name=readPool(pecall+EXPR_OFS_ARGS+1)
		if getExprValue(pe_member_name).tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_member=getDotMember(pecall,1)
		if !pobj_member:
			if DEBUG_EVAL_LOG:
				Writeln('  no such member')
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//queue as a user
		if !testUserFlag(pecall,QUEUE_FLAG_USERS):
			setUserFlag(pecall,QUEUE_FLAG_USERS)
			writePool(pecall+EXPR_OFS_NEXT_V_USER,readPool(pobj_member+VAR_OFS_USER_QUEUE))
			writePool(pobj_member+VAR_OFS_USER_QUEUE,pecall)
		return readPoolTyped(pobj_member,TSCCPValue)
	}
	registerPrimitive(g_id_dot,fcompiler_callback.NULL,fdot_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fstdot_oneval=function(PExpression pecall,int expr_oplevel){
		//__stdot(obj,"member",value)
		pe_member_name=readPool(pecall+EXPR_OFS_ARGS+1)
		if getExprValue(pe_member_name).tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_member=getDotMember(pecall,1)
		if !pobj_member:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !testUserFlag(pecall,QUEUE_FLAG_DOT):
			//we only reach here once
			assert(readPool(pobj_member+VAR_OFS_STORE_QUEUE)!=pecall)
			writePool(pecall+EXPR_OFS_NEXT_V_USER,readPool(pobj_member+VAR_OFS_STORE_QUEUE))
			writePool(pobj_member+VAR_OFS_STORE_QUEUE,pecall)
			setUserFlag(pecall,QUEUE_FLAG_DOT)
		pe_value=readPool(pecall+EXPR_OFS_ARGS+2)
		return fstore_eval_core(pecall,pobj_member,pe_value,0)
	}
	registerPrimitive(g_id_stdot,fcompiler_callback.NULL,fstdot_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fdeclare_struct_slots_cgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		id_mode=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS),g_vtid_STR)
		if id_mode==g_id_struct:
			pf_owner=getOwningFunction(pecall)
			sbak=g_code_buffer
			g_code_buffer=g_structs_slots_buffer
			g_code_buffer.push('struct s7_TS')
			g_code_buffer.push(toBase32(pf_owner))
			g_code_buffer.push('{')
			for i=1:n_args-1
				genCode(readPool(pecall+EXPR_OFS_ARGS+i),0)
				g_code_buffer.push('m_')
				g_code_buffer.push(string(i-1))
				g_code_buffer.push(';')
			g_code_buffer.push('};')
			g_code_buffer=sbak
			//the function-level declaration buffer
			g_local_decl_buffer.push('struct s7_TS')
			g_local_decl_buffer.push(toBase32(pf_owner))
			g_local_decl_buffer.push(' s7_Bs;')
		else
			g_code_buffer.push('union{')
			for i=1:n_args-1
				t=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+i),g_vtid_CTVAL)
				genType(t)
				assert(g_code_buffer.back()=='*')
				g_code_buffer.pop()
				g_code_buffer.push(' m_')
				g_code_buffer.push(toBase32(t))
				g_code_buffer.push(';')
			g_code_buffer.push('}')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_C_declare_struct_slots,fcompiler_callback.NULL,fcompiler_callback.NULL,fdeclare_struct_slots_cgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fget_struct_slot_cgen=function(PExpression pecall,int expr_oplevel){
		str_slotid=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CNS)
		t=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('(')
		genType(t)
		g_code_buffer.push(')memset(')
		g_code_buffer.push('&s7_Bs.m_')
		g_code_buffer.push(string(str_slotid))
		g_code_buffer.push('.m_')
		g_code_buffer.push(toBase32(t))
		g_code_buffer.push(',0,sizeof(')
		genType(t)
		g_code_buffer.pop()
		g_code_buffer.push('))')
		if need_bracket:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_C_get_struct_slot,fcompiler_callback.NULL,fcompiler_callback.NULL,fget_struct_slot_cgen,FFLAG_SPECIAL)
	//create a tuple type and new it
	registerPrimitive(g_id_uninit,fcompiler_callback.NULL,fdummy_callback,fcompiler_callback.NULL,FFLAG_SPECIAL)
	ftuple_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args==1&&getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CNS):
			//numbered tuple
			n_elements=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CNS)
			ids=new int[n_elements]
			for i=0:n_elements-1
				ids[i]=getTupleId(i)
			n_args=n_elements
		else
			ids=new int[n_args]
			for i=0:n_args-1
				id_argi=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+i),g_vtid_STR)
				if !id_argi:
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				ids[i]=id_argi
		is_numeric_tuple=1
		for i=0:n_args-1
			if ids[i]!=getTupleId(i):
				is_numeric_tuple=0
				break
		//create the struct ctor and construct it
		g_names_resolved=0
		as=new PExpression[n_args+is_numeric_tuple+2]
		as[0]=call(g_id_store,exprvar(g_id_this),call(g_id_get_lambda_context,expriptr(0)),expriptr(0))
		for i=0:n_args-1
			//forgo the check, __tuple is always parser-generated
			as[i+1]=call(g_id_store,exprvar(ids[i]),call(g_id_uninit))
		if is_numeric_tuple:
			as[n_args+1]=call(g_id_store,exprvar(g_id_length),expriptr(n_args))
		as[n_args+is_numeric_tuple+1]=call(g_id_store,exprvar(g_id_return),exprvar(g_id_this))
		pe_tuple_maker=indcall([call(g_id_function,exprstr(g_id_struct),vcall(g_id_block,as))])
		resolveNames(pe_tuple_maker,0)
		g_names_resolved=1
		pobjfn_tuple=getExprValueAs(readPool(pe_tuple_maker+EXPR_OFS_FUNCTION),g_vtid_CTVAL)
		assert(!!pobjfn_tuple&&readPool(pobjfn_tuple)==g_tid_TFunction)
		if is_numeric_tuple:
			setFFlag(pobjfn_tuple,FFLAG_IS_TUPLE)
			if g_readable_c_code:
				id_typename=getid("tuple<")
				if is_numeric_tuple:
					id_typename=catid(id_typename,getid(string(n_args)))
				else
					for i=0:n_args-1
						if i:id_typename=catid(id_typename,getid(","))
						id_typename=catid(id_typename,ids[i])
				id_typename=catid(id_typename,getid(">"))
				writePool(pobjfn_tuple+FUNCTION_OFS_NAME,id_typename)
		replaceExpr(pecall,pe_tuple_maker)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_tuple,fcompiler_callback.NULL,ftuple_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	//////////////////////////////////////
	//rc
	auto genRefcntCCode(PExpression pecall,int expr_oplevel,int check_finalize)
		delta=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CNS)
		pe_var=readPool(pecall+EXPR_OFS_ARGS+0)
		if isExpr(pe_var,EFLAG_CONST):
			pobj_var=0
			t=getOwningFunction(pecall)
		else
			//if !isExpr(readPool(pecall+EXPR_OFS_ARGS+0),EFLAG_VARIABLE):
			//	Writeln(dumpExpr(pecall,fcolor_abbrv_blocks))
			assert(isExpr(readPool(pecall+EXPR_OFS_ARGS+0),EFLAG_VARIABLE))
			pobj_var=getVariable(pe_var)
			t=getVariableType(pobj_var)
		auto genObject()
			if !pobj_var:
				g_code_buffer.push('s7_BL')
			else if tisclass(t):
				//if t==g_variant_type:
				//	//variant case - make use of RTTI
				//	assert(0)
				genVar(pobj_var)
			else
				g_code_buffer.push('err!')
		if delta==0x3fffffff&&!check_finalize:
			//pre-destruction setref
			genVar(pobj_var)
			if Util.bitSize()==64:
				g_code_buffer.push('->s7rc=0x3fffffffffffffffLL')
			else
				g_code_buffer.push('->s7rc=0x3fffffff')
			return
		//need_bracket=0
		//if expr_oplevel&&expr_oplevel<=70:
		//	need_bracket=1
		//	g_code_buffer.push('(')
		assert(!expr_oplevel)
		g_code_buffer.push('if(')
		genObject()
		g_code_buffer.push(')')
		if check_finalize:
			g_code_buffer.push('if((')
		genObject()
		g_code_buffer.push('->s7rc')
		if delta:
			g_code_buffer.push(FormatAsText('+=',delta))//*2
		if check_finalize:
			g_code_buffer.push(')<=0)')
			pf_dtor=readPool(t+FUNCTION_OFS_FINALIZER)
			if g_enable_debug_instrumentation:
				g_code_buffer.push('(')
				genLineInfoExpr(pecall)
				g_code_buffer.push(',')
			if pf_dtor:
				fgenerate_C_fcall(pecall,pf_dtor,0, 1)
				g_code_buffer.pop()//')'
			else
				g_code_buffer.push('free(')
			genObject()
			g_code_buffer.push(')')
			if g_enable_debug_instrumentation:
				g_code_buffer.push(')')
			//genObject()
			//g_code_buffer.push('=NULL')
	faddref_oncgen=function(PExpression pecall,int expr_oplevel){
		genRefcntCCode(pecall,expr_oplevel,0)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_addref,fcompiler_callback.NULL,fcompiler_callback.NULL,faddref_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	frelease_oncgen=function(PExpression pecall,int expr_oplevel){
		genRefcntCCode(pecall,expr_oplevel,1)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_release,fcompiler_callback.NULL,fcompiler_callback.NULL,frelease_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	//registerPrimitive(g_id_rc_local_holder,fcompiler_callback.NULL,fdummy_callback,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fexplicitrc_oneval=function(PExpression pecall,int expr_oplevel){
		peobj=readPool(pecall+EXPR_OFS_ARGS+0)
		val_obj=getExprValue(peobj)
		if val_obj.tid==g_vtid_STR:
			//constant string dotted, force into rtvar
			pobj_str_var=PCTObject(0)
			if isExpr(peobj,EFLAG_VARIABLE):
				pobj_str_var=getVariable(peobj)
			else if isExpr(peobj,EFLAG_FCALL):
				pobjfn=getExprFunction(peobj)
				if pobjfn:
					pobj_str_var=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
			if pobj_str_var:
				//dotted const strings become vars
				fstore_eval_core_ex(pecall,pobj_str_var,TSCCPValue(){'tid':g_vtid_RTVAR,'val':getStdObject(pecall,STDTYPE_STRING)},1)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_explicit_rc,fcompiler_callback.NULL,fexplicitrc_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fcfree_oncgen=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)==2+EFLAG_FCALL:
			//variant free - rtti call
			g_s7_TF_rtti_dtor_used=1
			g_code_buffer.push('((s7_TF_rtti_dtor)')
			genCode(readPool(pecall+EXPR_OFS_ARGS),LEVEL_POSTFIX)
			g_code_buffer.push('->s7rtti)((void*)')
			genCode(readPool(pecall+EXPR_OFS_ARGS),LEVEL_PREFIX)
			g_code_buffer.push(')')
		else
			assert(readPool(pecall+0)==1+EFLAG_FCALL)
			g_code_buffer.push('free(')
			genCode(readPool(pecall+EXPR_OFS_ARGS),LEVEL_ASSIGNMENT)
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_C_free,fcompiler_callback.NULL,fcompiler_callback.NULL,fcfree_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	//////////////////////////////////////
	//exposed raw functionality
	fcsizeof_oneval=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)!=1+EFLAG_FCALL:
			errorAtExpr(ETYPE_ERROR,pecall,"sizeof(expression) takes exactly 1 parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_opr=readPool(pecall+EXPR_OFS_ARGS)
		t=getExprValueAs(pe_opr,g_vtid_CTVAL)
		if !t||!tisclass(t)&&!tisbuiltin(t):
			t=getExprType(pe_opr)
			if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
		if tisbuiltin(t):
			ct=readPool(t+1)
			if ct==CTYPE_TYPED_NULL||ct==CTYPE_POINTER:
				n_bytes=(Util.bitSize()>>3)
			else
				n_bytes=((ct&~CTYPE_MASK)+1)
			assert(const_type(CTYPE_INT,Util.bitSize())<CTYPE_COUNT)
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,Util.bitSize()),i64(n_bytes))}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':getBuiltinType(const_type(CTYPE_INT,Util.bitSize()))}
	}
	fcsizeof_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall+0)==1+EFLAG_FCALL)
		g_code_buffer.push('sizeof(')
		pe_opr=readPool(pecall+EXPR_OFS_ARGS)
		t=getExprValueAs(pe_opr,g_vtid_CTVAL)
		if t:
			genType(t)
			if tisstruct(t):
				assert(g_code_buffer.back()=='*')
				g_code_buffer.pop()
		else
			genCode(pe_opr,LEVEL_ASSIGNMENT)
		g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_sizeof,fcompiler_callback.NULL,fcsizeof_oneval,fcsizeof_oncgen,FFLAG_SPECIAL)
	fmemory_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall+0)==2+EFLAG_FCALL)
		t=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fmemory_oncgen=function(PExpression pecall,int expr_oplevel){
		if g_enable_debug_instrumentation:
			g_code_buffer.push('(')
			genLineInfoExpr(pecall)
			g_code_buffer.push(',')
		assert(readPool(pecall+0)==2+EFLAG_FCALL)
		pe_type=readPool(pecall+EXPR_OFS_ARGS)
		t=getExprValueAs(pe_type,g_vtid_CTVAL)
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('*(')
		genType(t)
		g_code_buffer.push('*)')
		genCode(readPool(pecall+EXPR_OFS_ARGS+1),LEVEL_PREFIX)
		if need_bracket:
			g_code_buffer.push(')')
		if g_enable_debug_instrumentation:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_memory,fcompiler_callback.NULL,fmemory_oneval,fmemory_oncgen,FFLAG_SPECIAL)
	fset_memory_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall+0)==3+EFLAG_FCALL)
		assert(expr_oplevel==0)
		if g_enable_debug_instrumentation:
			genLineInfoExpr(pecall)
			g_code_buffer.push(';')
		pe_type=readPool(pecall+EXPR_OFS_ARGS)
		t=getExprValueAs(pe_type,g_vtid_CTVAL)
		g_code_buffer.push('*(')
		genType(t)
		g_code_buffer.push('*)')
		genCode(readPool(pecall+EXPR_OFS_ARGS+1),LEVEL_PREFIX)
		g_code_buffer.push('=')
		genCode(readPool(pecall+EXPR_OFS_ARGS+2),LEVEL_SELECT)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_set_memory,fcompiler_callback.NULL,fdummy_callback,fset_memory_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	//////////////////////////////////////
	//template utility
	fis_type_oneval=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)!=2+EFLAG_FCALL:
			errorAtExpr(ETYPE_ERROR,pecall,"__is_type('meta-type',expression) takes exactly 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		id_meta_type=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS),g_vtid_STR)
		if !id_meta_type:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		t=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if id_meta_type==g_id_function:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(tisfunction(t)))}
		if id_meta_type==g_id_struct:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(tisstruct(t)))}
		if id_meta_type==g_id_class:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(tisrealclass(t)))}
		if id_meta_type==g_id_builtin:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(tisbuiltin(t)))}
		if id_meta_type==g_id_int:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64((tisctype(t,CTYPE_INT)||tisctype(t,CTYPE_UINT))))}
		if id_meta_type==g_id_float:return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(tisctype(t,CTYPE_FLOAT)))}
		errorAtExpr(ETYPE_ERROR,readPool(pecall+EXPR_OFS_ARGS),"invalid meta-type category '@1' for __is_type".Replace(["@1",getIdString(id_meta_type)]))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_is_type,fcompiler_callback.NULL,fis_type_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	//todo: an entire parameter type list?
	fparameter_count_oneval=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)!=1+EFLAG_FCALL:
			errorAtExpr(ETYPE_ERROR,pecall,"__parameter_count(function) takes exactly 1 parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		if !pobjfn||readPool(pobjfn)!=g_tid_TFunction:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
		return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(((readPool(pe_decl)&~EFLAG_MASK)-2)>>1))}
	}
	registerPrimitive(g_id_parameter_count,fcompiler_callback.NULL,fparameter_count_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	finline_clone_oneval=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)!=1+EFLAG_FCALL:
			errorAtExpr(ETYPE_ERROR,pecall,"__inline_clone(function) takes exactly 1 parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		if !pobjfn||readPool(pobjfn)!=g_tid_TFunction:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		assert(getCcnv(pobjfn)!=g_id_inline_loopbody)
		if getCcnv(pobjfn)==g_id_inline:
			//if it's already inline, don't clone
			return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobjfn}
		if getFFlag(pobjfn)&FFLAG_IS_SYMDERIV:
			//wait for _deriv translation
			t_symderiv_return=getReturnType(pobjfn)
			if !t_symderiv_return:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			if tisstruct(t_symderiv_return):
				enableNameLookup(t_symderiv_return)
				p_members=readPool(t_symderiv_return+FUNCTION_OFS_PMEMBER_LIST)
				n_members=readPool(t_symderiv_return+FUNCTION_OFS_NMEMBER_LIST)
				for i=0:n_members-1
					id_member=readPool(p_members+i)
					if id_member==g_id_this||id_member==g_id_return:continue
					pobj_member=lookupFunctionVariable(t_symderiv_return,id_member)
					t_member=getVariableType(pobj_member)
					if !t_member:
						//depend on the member
						pe_dep_dummy=exprvar(pobj_member)
						writePool(pe_dep_dummy+EXPR_OFS_CALLER,pecall)
						sccpQueueReach(pe_dep_dummy)
						return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn_cloned=readCtUniqueInEvalFlow(0,[g_id_inline_clone,pobjfn])
		if !pobjfn_cloned:
			pobjfn_cloned=cloneFunction(pobjfn)
			writeCtUniqueInEvalFlow([g_id_inline_clone,pobjfn],pobjfn_cloned)
			pe_decl=readPool(pobjfn_cloned+FUNCTION_OFS_PEDECL)
			pe_ccnv=readPool(pe_decl+EXPR_OFS_ARGS+0)
			writePool(pe_ccnv,g_id_inline+EFLAG_STRING)
			writePool(pobjfn_cloned+FUNCTION_OFS_ONEVAL,g_cbobj_expand_inline_oneval)
			writePool(pobjfn_cloned+FUNCTION_OFS_ONCGEN,0)
		return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobjfn_cloned}
	}
	registerPrimitive(g_id_inline_clone,fcompiler_callback.NULL,finline_clone_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	ftypeof_oneval=function(PExpression pecall,int expr_oplevel){
		if readPool(pecall+0)!=1+EFLAG_FCALL:
			errorAtExpr(ETYPE_ERROR,pecall,"typeof(expression) takes exactly 1 parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
		val=getExprValue(pe_opr)
		if val.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val.tid==g_vtid_CTVAL:
			//Writeln(getIdString(readPool(val.val)))
			if readPool(val.val)==g_tid_TFunction&&getCcnv(val.val)!=g_id_function||readPool(val.val)==g_tid_TBuiltinType:
				//typeless thingy, return zero
				return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(0))}
		t=getValueTypeEx(pe_opr,val)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		else
			return TSCCPValue(){'tid':g_vtid_CTVAL,'val':t}
	}
	registerPrimitive(g_id_typeof,fcompiler_callback.NULL,ftypeof_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	farraytype_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall+0)==1+EFLAG_FCALL)
		pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
		t_array=getStdObject(pecall,STDTYPE_ARRAY)
		if !t_array:return TSCCPValue(){'tid':g_vtid_UNINIT}
		replaceExpr(pecall,indcall([exprctval(t_array),pe_opr]))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_array_type,fcompiler_callback.NULL,farraytype_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	ftuple_call_oneval=function(PExpression pecall,int expr_oplevel){
		peobj=readPool(pecall+EXPR_OFS_ARGS+0)
		pe_arg=readPool(pecall+EXPR_OFS_ARGS+1)
		//translate it to a better form
		t_tuple=getExprType(pe_arg)
		if !t_tuple:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !tistuple(t_tuple)
			errorAtExpr(ETYPE_ERROR,peobj,"the indirect call argument '@1' must be a tuple, not @2".Replace(["@1",citeexpr(pe_arg),"@2",dumpType(t_tuple)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//generate the indirect call
		pv_this=rcGetVariableIfExprIsOne(pe_arg)
		as=PExpression[].NULL
		if !pv_this:
			pf_owner=getOwningFunction(pecall)
			pv_this=makevar(pf_owner)
			as=new PExpression[1]
			as.push(call(g_id_store,exprvar(pv_this),pe_arg))
		enableNameLookup(t_tuple)
		p_members=readPool(t_tuple+FUNCTION_OFS_PMEMBER_LIST)
		n_members=readPool(t_tuple+FUNCTION_OFS_NMEMBER_LIST)
		as_indcall=new PExpression[]
		as_indcall.push(peobj)
		for i=0:n_members-1
			id_member=readPool(p_members+i)
			if id_member==g_id_length||id_member==g_id_this||id_member==g_id_return:continue
			as_indcall.push(call(g_id_dot,exprvar(pv_this),exprstr(id_member)))
		transformCode(pecall,ftransformer_callback.NULL,as,indcall(as_indcall),PExpression[].NULL)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_tuple_call,fcompiler_callback.NULL,ftuple_call_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	ftuple_bracket_oneval=function(PExpression pecall,int expr_oplevel){
		peobj=readPool(pecall+EXPR_OFS_ARGS+0)
		pe_subscript=readPool(pecall+EXPR_OFS_ARGS+1)
		val_subscript=getExprValue(pe_subscript)
		if val_subscript.tid==g_vtid_CNS:
			cns_subscript=getExprValueAs(pe_subscript,g_vtid_CNS)
			if u32(cns_subscript)<u32(int(g_tuple_ids.n)):
				if readPool(pecall)==EFLAG_FCALL+2:
					//replace with a tuple dot and remove the call
					//writePool(readPool(pecall+EXPR_OFS_ARGS+1),EFLAG_STRING+getTupleId(cns_subscript))
					//pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
					transformCode(pecall,ftransformer_callback.NULL,[lockValueCheck(pe_subscript,g_id_error_int_cannot_change)],call(g_id_dot,peobj,exprstr(getTupleId(cns_subscript))),PExpression[].NULL)
				else
					//replace with a stdot call and add an object slot
					pe_stdot_value=readPool(pecall+EXPR_OFS_ARGS+2)
					transformCode(pecall,ftransformer_callback.NULL,[lockValueCheck(pe_subscript,g_id_error_int_cannot_change)],call(g_id_stdot,peobj,exprstr(getTupleId(cns_subscript)),pe_stdot_value),PExpression[].NULL)
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			else
				errorAtExpr(ETYPE_ERROR,pe_subscript,"invalid tuple subscript '@1'".Replace(["@1",citeexpr(pe_subscript)]))
		else if val_subscript.tid==g_vtid_UNINIT:
			//Writeln(string(pe_subscript)+" damn "+dumpExpr(pe_subscript,fcolor_reach_eval))
			//System.IO.stdin.ReadLine()
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		errorAtExpr(ETYPE_ERROR,pe_subscript,"tuple subscript '@1' in '@2' must be a constant".Replace(["@1",citeexpr(pe_subscript),"@2",citeexpr(pecall)]))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_tuple_bracket,fcompiler_callback.NULL,ftuple_bracket_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	flist_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		t_all=PCTObject(0)
		pe_argi_previous=PExpression(0)
		for i=0:n_args-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			t=getExprType(pe_argi)
			if !t:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			if i:
				t_merged=typeMerge(pecall,t_all,t, pe_argi_previous,pe_argi,0)
				if !t_merged:
					errorAtExpr(ETYPE_ERROR,pe_argi,"type '@1' expression '@2' is incompatible with previous list element types '@3'".Replace([
						"@1",dumpType(t),
						"@2",citeexpr(pe_argi),
						"@3",dumpType(t_all)]))
					setnop(pecall)
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				t_all=t_merged
			else
				t_all=t
			pe_argi_previous=pe_argi
		//todo: all-const case
		assert(!!t_all)
		pf_owner=getOwningFunction(pecall)
		pobj_var=makevar(pf_owner)
		as=new PExpression[1+n_args]
		as[0]=call(g_id_store,exprvar(pobj_var),indcall([call(g_id_array_type,exprctval(t_all)),expriptr(n_args),exprcns(getid_const(const_type(CTYPE_INT,16),0LL))]))
		for i=0:n_args-1
			as[i+1]=indcall([call(g_id_dot,exprvar(pobj_var),exprstr(g_id_set_operator_bracket)),expriptr(i),readPool(pecall+EXPR_OFS_ARGS+i)])
		transformCode(pecall,ftransformer_callback.NULL, as,exprvar(pobj_var),PExpression[].NULL)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_list,fcompiler_callback.NULL,flist_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fhas_member_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"__has_member(object,'name') takes exactly 2 arguments")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_name=readPool(pecall+EXPR_OFS_ARGS+1)
		if getExprValue(pe_name).tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		id_name=getExprValueAs(pe_name,g_vtid_STR)
		if !id_name:
			errorAtExpr(ETYPE_ERROR,pe_name,"__has_member(object,'name') can only take a string as the member name")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		peobj=readPool(pecall+EXPR_OFS_ARGS+0)
		t_object=getExprType(peobj)
		if !t_object:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !tisclass(t_object):
			//not class, no member
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),0LL)}
		//Writeln('>>> ',lookupFunctionVariable(t_object,id_name),' ',getIdString(id_name))
		return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),i64(lookupFunctionVariable(t_object,id_name)))}
	}
	registerPrimitive(g_id_has_member,fcompiler_callback.NULL,fhas_member_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fmember_list_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=1:
			errorAtExpr(ETYPE_ERROR,pecall,"__member_list(object) takes exactly 1 object/type argument")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_arg=readPool(pecall+EXPR_OFS_ARGS+0)
		t_class=getExprValueAs(pe_arg,g_vtid_CTVAL)
		if !t_class:
			t_class=getExprType(pe_arg)
			if !t_class:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		id_all_members=new int[]
		if tisclass(t_class):
			enableNameLookup(t_class)
			p_members=readPool(t_class+FUNCTION_OFS_PMEMBER_LIST)
			n_members=readPool(t_class+FUNCTION_OFS_NMEMBER_LIST)
			for i=0:n_members-1
				id_member=readPool(p_members+i)
				if id_member==g_id_this||id_member==g_id_return||!id_member:continue
				id_all_members.push(id_member)
		else
			//or namespaces
			errorAtExpr(ETYPE_ERROR,pecall,"__member_list(object) only works on class/struct types, not '@1'".Replace(["@1",dumpType(t_class)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		////
		pf_owner=getOwningFunction(pecall)
		pe_tuple=makeTuple(int(id_all_members.n))
		pv_return_new=makevar(pf_owner)
		as=new PExpression[]
		as.push(call(g_id_store,exprvar(pv_return_new),pe_tuple))
		foreach id,I in id_all_members
			as.push(call(g_id_stdot,exprvar(pv_return_new),exprstr(getTupleId(int(I))),exprstr(id)))
		transformCode(pecall,ftransformer_callback.NULL, as,exprvar(pv_return_new),PExpression[].NULL)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_member_list,fcompiler_callback.NULL,fmember_list_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fis_variable_onreach=function(PExpression pecall,int expr_oplevel){
		sccpQueueReach(readPool(pecall+EXPR_OFS_ARGS+0))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fis_variable_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"__is_variable(variable,{}) takes exactly 2 arguments")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		val=getExprValue(readPool(pecall+EXPR_OFS_ARGS+0))
		if val.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val.tid==g_vtid_RTVAR:
			pecaller=readPool(pecall+EXPR_OFS_CALLER)
			sccpQueueReach(insertCallAt(pecaller,pecall,function(){return readPool(pecall+EXPR_OFS_ARGS+1)}))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_is_variable,fis_variable_onreach,fis_variable_oneval,fdummy_callback,FFLAG_SPECIAL|FFLAG_STATEMENT_HOST)
	fget_rtti_oneval=function(PExpression pecall,int expr_oplevel){
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':getBuiltinType(const_type(CTYPE_INT,Util.bitSize()))}
	}
	fget_rtti_oncgen=function(PExpression pecall,int expr_oplevel){
		pe_object=readPool(pecall+EXPR_OFS_ARGS+0)
		t_object=getExprValueAs(pe_object,g_vtid_CTVAL)
		if t_object:
			//type RTTI - dtor name, fill during lambda tran
			pf_dtor=readPool(t_object+FUNCTION_OFS_FINALIZER)
			assert(!!pf_dtor)
			g_code_buffer.push('((void*)')
			genFunctionName(pf_dtor)
			g_code_buffer.push(')')
		else
			//object RTTI, take the member
			genCode(pe_object,LEVEL_POSTFIX)
			g_code_buffer.push('->s7rtti')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_get_rtti,fcompiler_callback.NULL,fget_rtti_oneval,fget_rtti_oncgen,FFLAG_SPECIAL)
	fforce_reach_oneval=function(PExpression pecall,int expr_oplevel){
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		if pobjfn:setFunctionUsed(pobjfn)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_reach,fcompiler_callback.NULL,fforce_reach_oneval,fdummy_callback,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fforce_alive_oneval=function(PExpression pecall,int expr_oplevel){
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_force_alive,fcompiler_callback.NULL,fforce_alive_oneval,fdummy_callback,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fforce_var_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall)==EFLAG_FCALL+1)
		pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
		t=getExprType(pe_opr)
		if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fforce_var_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall)==EFLAG_FCALL+1)
		pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
		genCode(pe_opr,expr_oplevel)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_force_var,fcompiler_callback.NULL,fforce_var_oneval,fforce_var_oncgen,FFLAG_SPECIAL)
	freport_error=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args<1:
			errorAtExpr(ETYPE_ERROR,pecall,"__error('format',...) has to take at least one parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_format=readPool(pecall+EXPR_OFS_ARGS+0)
		id_serror=getExprValueAs(pe_format,g_vtid_STR)
		if !id_serror&&getExprValue(pe_format).tid!=g_vtid_UNINIT:
			errorAtExpr(ETYPE_ERROR,pecall,"__error('format',...) has to take a format string as the first parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		serror=new(getIdString(id_serror))
		s_to_replace=new string[]
		for i=1:n_args-1
			s_to_replace.push("@"+string(i))
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			val=getExprValue(pe_argi)
			if val.tid==g_vtid_UNINIT:return TSCCPValue(){'tid':g_vtid_UNINIT}
			//todo: inline param case
			if val.tid==g_vtid_CNS:
				sret=dumpConst(Util.g_const_values[val.val])
			else if val.tid==g_vtid_STR:
				sret=new(getIdString(val.val))
			else if val.tid==g_vtid_CTVAL:
				sret=dumpObject(val.val)
			else
				sret=citeexpr(pe_argi)
			s_to_replace.push(sret)
		serror=s_to_replace.n?serror.Replace(s_to_replace):serror
		errorAtExpr(ETYPE_ERROR,pecall,serror)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_report_error,fcompiler_callback.NULL,freport_error,fdummy_callback,FFLAG_SPECIAL)
	farray_or_map_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall)==EFLAG_FCALL+2)
		peobj=readPool(pecall+EXPR_OFS_ARGS+0)
		pe_subscript=readPool(pecall+EXPR_OFS_ARGS+1)
		val_subscript=getExprValue(pe_subscript)
		if val_subscript.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val_subscript.tid==g_vtid_CTVAL:
			//it's a map
			t_map=getStdObject(pecall,STDTYPE_MAP)
			if !t_map:return TSCCPValue(){'tid':g_vtid_UNINIT}
			transformCode(pecall,NULL, NULL,indcall([exprctval(t_map),pe_subscript,peobj]),NULL)
		else
			//translate T.[] into Array(T), this is read-only
			t_array=getStdObject(pecall,STDTYPE_ARRAY)
			if !t_array:return TSCCPValue(){'tid':g_vtid_UNINIT}
			transformCode(pecall,NULL, NULL,indcall([indcall([exprctval(t_array),peobj]),pe_subscript,exprcns(getid_const(const_type(CTYPE_INT,16),0LL))]),NULL)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_array_or_map,fcompiler_callback.NULL,farray_or_map_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fnew_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall)==EFLAG_FCALL+1)
		pe_type=readPool(pecall+EXPR_OFS_ARGS+0)
		val=getExprValue(pe_type)
		if val.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val.tid==g_vtid_CTVAL&&tisclass(val.val):
			//transform to a call
			transformCode(pecall,NULL, NULL,indcall([pe_type]),NULL)
		else
			//transform into "clone"
			pobjfn_clone=getStdObject(pecall,STDFN_CLONE)
			if !pobjfn_clone:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			insertCallAt(pecall,0,function(){return exprctval(pobjfn_clone)})
			sccpQueueEval(pecall)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_new,fcompiler_callback.NULL,fnew_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fset_fflag=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"set___fflag(function,value) has to take exactly two parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_func=readPool(pecall+EXPR_OFS_ARGS+0)
		pe_flags=readPool(pecall+EXPR_OFS_ARGS+1)
		if getExprValue(pe_func).tid==g_vtid_UNINIT||getExprValue(pe_flags).tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=getExprValueAs(pe_func,g_vtid_CTVAL)
		if !pobjfn:
			errorAtExpr(ETYPE_ERROR,pe_func,"set___fflag(function,value) has to take a function for 'name'")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		flag_val=getExprValueAs(pe_flags,g_vtid_CNS)
		setFFlag(pobjfn,flag_val)
		if flag_val&FFLAG_IS_PARALLEL:
			setFunctionUsed(pobjfn)
			setParameterSlotTypes(pobjfn)
		setnop(pecall)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_set_fflag,fcompiler_callback.NULL,fset_fflag,fcompiler_callback.NULL,FFLAG_SPECIAL)
	//////////////////////////////////////
	//meta state
	fmeta_state_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=1:
			errorAtExpr(ETYPE_ERROR,pecall,"__meta_state('name') has to take exactly one string parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_name=readPool(pecall+EXPR_OFS_ARGS+0)
		id_name=getExprValueAs(pe_name,g_vtid_STR)
		if !id_name:
			errorAtExpr(ETYPE_ERROR,pe_name,"__meta_state('name') has to take exactly one string parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_ret=readCtUniqueInEvalFlow(pecall,[g_id_meta_state,id_name])
		if pobj_ret:
			return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobj_ret}
		else
			return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_meta_state,fcompiler_callback.NULL,fmeta_state_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	fset_meta_state_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"set___meta_state('name',value) has to take exactly two parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_name=readPool(pecall+EXPR_OFS_ARGS+0)
		id_name=getExprValueAs(pe_name,g_vtid_STR)
		if !id_name:
			errorAtExpr(ETYPE_ERROR,pe_name,"set___meta_state('name',value) has to take a string for 'name'")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		val_existing=getExprValue(pecall)
		pobj_ret=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if val_existing.tid==g_vtid_UNINIT&&pobj_ret:
			writeCtUniqueInEvalFlow([g_id_meta_state,id_name],pobj_ret)
			return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobj_ret}
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_set_meta_state,fcompiler_callback.NULL,fset_meta_state_oneval,fdummy_callback,FFLAG_SPECIAL)
	fgenerate_json_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"__generate_json('category','file') has to take exactly two parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_name=readPool(pecall+EXPR_OFS_ARGS+0)
		id_name=getExprValueAs(pe_name,g_vtid_STR)
		if !id_name:
			errorAtExpr(ETYPE_ERROR,pe_name,"__generate_json('category','file') has to take a string for 'category'")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_value=readPool(pecall+EXPR_OFS_ARGS+1)
		id_value=getExprValueAs(pe_value,g_vtid_STR)
		if !id_value:
			errorAtExpr(ETYPE_ERROR,pe_value,"__generate_json('category','file') has to take a string for 'file'")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		arr=g_json_pool[id_name]
		if !arr:
			arr=new int[]
			g_json_pool[id_name]=arr
		arr.push(id_value)
		setnop(pecall)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_generate_json,fcompiler_callback.NULL,fgenerate_json_oneval,fdummy_callback,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fprototype_matches_oneval=function(PExpression pecall,int expr_oplevel){
		assert(readPool(pecall)==EFLAG_FCALL+3)
		pe_arg_tuple=readPool(pecall+EXPR_OFS_ARGS+0)
		pobjfn_proto=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		pe_deps=readPool(pecall+EXPR_OFS_ARGS+2)
		if isExpr(pe_deps,EFLAG_VARIABLE):
			//smash the dependency every time
			writePool(pe_deps,EFLAG_STRING+g_empty_id)
		if !pobjfn_proto:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		t_tuple=getExprType(pe_arg_tuple)
		if !t_tuple||!tistuple(t_tuple)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		enableNameLookup(t_tuple)
		p_members=readPool(t_tuple+FUNCTION_OFS_PMEMBER_LIST)
		n_members=readPool(t_tuple+FUNCTION_OFS_NMEMBER_LIST)
		n_args_call=0
		for i=0:n_members-1
			id_member=readPool(p_members+i)
			if id_member==g_id_length||id_member==g_id_this||id_member==g_id_return:continue
			n_args_call++
		n_args_proto=getNumberOfArguments(pobjfn_proto)
		if n_args_call!=n_args_proto:
			transformCode(pecall,NULL, NULL,expriptr(0),NULL)
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),0LL)}
		pedecl_proto=readPool(pobjfn_proto+FUNCTION_OFS_PEDECL)
		p_args=0
		for i=0:n_members-1
			id_member=readPool(p_members+i)
			if id_member==g_id_length||id_member==g_id_this||id_member==g_id_return:continue
			pobj_member=lookupFunctionVariable(t_tuple,id_member)
			pe_proto_i=readPool(pedecl_proto+EXPR_OFS_ARGS+1+p_args*2)
			if isExpr(pe_proto_i,EFLAG_STRING):
				//template param, always matches that
			else
				t_call_i=getVariableType(pobj_member)
				if !t_call_i:
					//we need to know all the arg types - dependency
					sccpQueueReach(insertCallAt(pecall,~2,function(){return exprvar(pobj_member)}))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				t_proto_i=getExprValueAs(pe_proto_i,g_vtid_CTVAL)
				//Writeln('=? ',dumpType(t_proto_i),' ',dumpType(t_call_i))
				if t_proto_i&&t_proto_i!=t_call_i:
					//a type mismatch
					//Writeln('mismatch')
					transformCode(pecall,NULL, NULL,expriptr(0),NULL)
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),0LL)}
			p_args++
		//Writeln('match')
		replaceExpr(pecall,expriptr(1))
		return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),1LL)}
	}
	registerPrimitive(g_id_prototype_matches,fcompiler_callback.NULL,fprototype_matches_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	if ENABLE_FEM_DSL:{
	//////////////////////////////////////
	//symbolic derivatives
	fderiv_onreach=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args<2:
			errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) needs at least 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pefunc=readPool(pecall+EXPR_OFS_ARGS)
		sccpQueueReach(pefunc)
		//val=getExprValue(pefunc)
		//if val.tid==g_vtid_UNINIT||val.tid==g_vtid_UNREACHED:
		//	return TSCCPValue(){'tid':g_vtid_UNINIT}
		//if val.tid!=g_vtid_CTVAL:
		//	errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) requires a function as its first parameter")
		//	return TSCCPValue(){'tid':g_vtid_UNINIT}
		//pobjfn=getAsFunction(val.val)
		//if !pobjfn:
		//	errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) requires a function as its first parameter")
		//	return TSCCPValue(){'tid':g_vtid_UNINIT}
		//pobjfn_dup=ctUnique([g_id_symderiv,pobjfn])
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	derivAddVarDerivs=function(PCTObject pobj_var,PCTObject pobjfn_dup,PCTObject pobj_vderiv){
		vdata=readPoolTyped(pobj_var,TVariable)
		for(pestore=vdata.first_v_store;pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
			//if !testUserFlag(pestore,USER_FLAG_ACTIVATED):continue
			if !isBuiltin(pestore,g_id_store):continue
			//apply _deriv to the result, then rely on _deriv to transform stuff
			//don't apply to store itself, but do apply to other stuff
			//id_original_varname=readPool(readPool(pestore+(EXPR_OFS_ARGS+0))+(EXPR_OFS_NAME+1))
			//compute them and then 
			pe_var=readPool(pestore+(EXPR_OFS_ARGS+0))
			assert(isExpr(pe_var,EFLAG_VARIABLE))
			pobj_original_var=getVariable(pe_var)
			id_original_var__=g_id__
			if g_readable_c_code:
				if pobj_original_var:
					id_original_var__=catid(readPool(pobj_original_var+VAR_OFS_ID),g_id__)
			pe_original_expr=readPool(pestore+(EXPR_OFS_ARGS+1))
			pobjfn_toplevel=(isExpr(pe_original_expr,EFLAG_FCALL)?getExprFunction(pe_original_expr):0)
			if pobjfn_toplevel:
				pobjfn_compute_reusable_components=ctUnique([g_id_deriv_reusable_components,pobjfn_toplevel])
				if pobjfn_compute_reusable_components:
					pv_reused_tuple=ctUnique([g_id_deriv_reusable_components,pestore])
					if !pv_reused_tuple:
						//we have reusable components - compute them and add the arg to the clones
						as=new PExpression[]
						as.push(exprctval(pobjfn_compute_reusable_components))
						n_args_original_expr=getFCallNArgs(pe_original_expr)
						for i=0:n_args_original_expr-1
							as.push(cloneExpr(readPool(pe_original_expr+EXPR_OFS_ARGS+i)))
						as.push(expriptr(0))
						as.push(exprstr(g_empty_id))
						pv_reused_tuple=makevar(pobjfn_dup)
						transformCode(pestore,NULL, [call(g_id_store,exprvar(pv_reused_tuple),indcall(as))],0,NULL)
						ctUnique([g_id_deriv_reusable_components,pestore])=pv_reused_tuple
						if DEBUG_DUMP_DERIV:
							Writeln("precomputing for pobjfn_compute_reusable_components: "+dumpExpr(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),NULL))
					//add the resulting tuple to pe_original_expr
					as=new PExpression[]
					n_args_original_expr=getFCallNArgs(pe_original_expr)
					for i=-1:n_args_original_expr-1
						as.push(cloneExpr(readPool(pe_original_expr+EXPR_OFS_ARGS+i)))
					as.push(exprvar(pv_reused_tuple))
					pe_original_expr=indcall(as)
					if DEBUG_DUMP_DERIV:
						Writeln("triggered pobjfn_compute_reusable_components: "+dumpExpr(pe_original_expr,NULL))
			pe_store_caller=readPool(pestore+EXPR_OFS_CALLER)
			//Writeln(dumpExpr(pestore,NULL),' ',pe_store_caller
			fadd_more_stores=function(PExpression pe){
				auto as=new int[]
				as.push(pe)
				pe_deriv_i=cloneExpr(pe_original_expr)
				//sccpQueueReach(pe_deriv_i)
				pe_deriv_i=call(g_id_deriv,pe_deriv_i,expriptr(pobjfn_dup),exprctval(pobj_vderiv))
				pvar_deriv_i=ctUnique([g_id_deriv,pobjfn_dup,pobj_var,pobj_vderiv])
				if !pvar_deriv_i:
					pvar_deriv_i=makevar(pobjfn_dup)
					if g_readable_c_code:
						vid=readPool(pobj_vderiv+VAR_OFS_ID)
						writePool(pvar_deriv_i+VAR_OFS_ID,gettempid(vid?catid(id_original_var__,vid):0))
					ctUnique([g_id_deriv,pobjfn_dup,pobj_var,pobj_vderiv])=pvar_deriv_i
				pe_store_deriv=call(g_id_store,exprvar(pvar_deriv_i),pe_deriv_i)
				as.push(pe_store_deriv)
				if DEBUG_DUMP_DERIV:
					Writeln('  ',dumpExpr(pe_store_deriv,NULL))
				return vcall(g_id_block,as)
			}
			sccpQueueReach(insertCallAt(pe_store_caller,pestore,fadd_more_stores))
	}
	FLAG_RELATED=1
	FLAG_REQUIRED=2
	auto memberCnsToRtvar(PExpression pecall,PCTObject t)
		p_members=readPool(t+FUNCTION_OFS_PMEMBER_LIST)
		n_members=readPool(t+FUNCTION_OFS_NMEMBER_LIST)
		for i=0:n_members-1
			id_member=readPool(p_members+i)
			if id_member==g_id_this||id_member==g_id_return:continue
			pobj_member=lookupFunctionVariable(t,id_member)
			if readPool(pobj_member)==g_vtid_CNS:
				t_member=getVariableType(pobj_member)
				assert(!!t_member)
				fstore_eval_core_ex(pecall,pobj_member,TSCCPValue(){'tid':g_vtid_RTVAR,'val':t_member},0)
	auto cdfOptimize(PCTObject pobjfn_dup,PCTObject[] var_list_ret)
		//protect var_list_ret - don't setnop when "renaming" the returners
		tmp_ids=new int[var_list_ret.n]
		for i=0:var_list_ret.n-1
			tmp_ids[i]=readPool(var_list_ret[i]+VAR_OFS_ID)
			writePool(var_list_ret[i]+VAR_OFS_ID,g_id_return)
		partialSSAGVN(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),1,0)
		sccp(0)
		pedecl_new=dfsFlattenBlocks(NULL,readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),0,1)
		writePool(pobjfn_dup+FUNCTION_OFS_PEDECL,pedecl_new)
		sccp(0)
		for i=0:var_list_ret.n-1
			writePool(var_list_ret[i]+VAR_OFS_ID,tmp_ids[i])
	fsymderiv_oneval=function(PExpression pecall,int is_cdf_pass){
		//per-var scan: we can precisely find out reusable / irrelevant expr components for each var
		//then we leaf them and copy to temp
		n_args=getFCallNArgs(pecall)
		if n_args<2:
			errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) needs at least 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pefunc=readPool(pecall+EXPR_OFS_ARGS)
		//Writeln('^_^ ',__LINE__)
		val=getExprValue(pefunc)
		if val.tid==g_vtid_UNINIT://||val.tid==g_vtid_UNREACHED:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//Writeln('^_^ ',__LINE__,' ',getIdString(val.tid))
		if val.tid!=g_vtid_CTVAL:
			errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) requires a function as its first parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=getAsFunction(val.val)
		if !pobjfn:
			errorAtExpr(ETYPE_ERROR,pecall,"symbolicDerivative(function,'var',...) requires a function as its first parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !is_cdf_pass:
			//varify arg/ret elements, if any is available
			//we have to do it before the first strflatten
			//problem: tuple length
			//pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
			//n_args_decl=getFCallNArgs(pe_decl)
			//for i=1:2:n_args_decl-2
			//	petype=readPool(pe_decl+EXPR_OFS_ARGS+i)
			//	t=getExprValueAs(petype,g_vtid_CTVAL)
			//	if t&&tisclass(t):
			//		memberCnsToRtvar(pecall,t)
			//t=getReturnType(pobjfn)
			//if t&&tisclass(t):
			//	memberCnsToRtvar(pecall,t)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn_dup=ctUnique([g_id_symderiv,pobjfn])
		if !pobjfn_dup:
			pobjfn_dup=cloneFunction(pobjfn)
			setFFlag(pobjfn_dup,FFLAG_IS_SYMDERIV_TEMP)
			ctUnique([g_id_symderiv,pobjfn])=pobjfn_dup
			sccpQueueReach(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL))
			//sccpQueueReach(fn.code)
			//Writeln(parser.Canonical.dumpExpr(fn.code,fcolor_reach_eval))
			setFunctionUsed(pobjfn_dup)
			//initialize parameter types
			setParameterSlotTypes(pobjfn_dup)
			//sccpQueueEval(pecall)
			//return TSCCPValue(){'tid':g_vtid_UNINIT}
			if DEBUG_DUMP_DERIV:
				Writeln('sccpProcessReaches()')
			sccpProcessReaches()
			if DEBUG_DUMP_DERIV:
				Writeln('>>> after dup')
				Writeln(FormatAsText(dumpExpr(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),fcolor_reach_eval)))
			if g_readable_c_code:
				id_name0=readPool(pobjfn+FUNCTION_OFS_NAME)
				if id_name0:
					id_name_deriv=catid(getid("deriv_"),id_name0)
				else
					id_name_deriv=getid("deriv_by_")
					for i=1:n_args-1
						peargname=readPool(pecall+EXPR_OFS_ARGS+i)
						flags=readPool(peargname)
						if (flags&EFLAG_MASK)!=EFLAG_STRING:
							continue
						vid=(flags&~EFLAG_MASK)
						id_name_deriv=catid(catid(id_name_deriv,vid),getid("_"))
				writePool(pobjfn_dup+FUNCTION_OFS_NAME,id_name_deriv)
			////we need another iteration to make sure the innards gets evaled
			//return TSCCPValue(){'tid':g_vtid_UNINIT}
			//gotta eval the dupped body before flattening
			sccp(0)
			did_div2rcp=0
			fdiv2rcp=function(PExpression pe){
				if isBuiltin(pe,g_id_operator_div):
					auto pe_arg0=readPool(pe+EXPR_OFS_ARGS+0)
					auto pe_arg1=readPool(pe+EXPR_OFS_ARGS+1)
					auto t=getExprType(pe_arg1)
					assert(tisbuiltin(t))
					if tisbuiltin(t):
						val0=getExprValue(pe_arg0)
						if !isValueOne(val0):
							did_div2rcp=1
							auto pecaller=readPool(pe+EXPR_OFS_CALLER)
							ca=castConst(TConstValue(){'type':const_type(CTYPE_INT,64),'val_bin':1LL},t)
							auto pe_one=exprcns(getid_const(ca.type,ca.val_bin))
							sccpQueueReach(insertCallAt(pecaller,pe,function(){return call(g_id_operator_mul,pe_arg0,call(g_id_operator_div,pe_one,pe_arg1))}))
							return 1
				return 1
			}
			dfsExpr(readPool(pobjfn_dup+FUNCTION_OFS_CODE),fdiv2rcp)
			if did_div2rcp:sccp(0)
		//we should eventually reach here again...
		//if !pobjfn_dup:
		//	assert(0)
		//	return TSCCPValue(){'tid':g_vtid_UNINIT}
		//check the variable names
		var_list_ret=g_strflatten_monitored_variables[pecall+0]
		var_list_params=g_strflatten_monitored_variables[pecall+1]
		is_exclusive=ctUnique([g_id_option_exclusive,pobjfn_dup])
		if !var_list_ret:{
			//set up the variable lists
			var_list_params=new PCTObject[]
			for i=1:n_args-1
				peargname=readPool(pecall+EXPR_OFS_ARGS+i)
				vid=getExprValueAs(peargname,g_vtid_STR)
				if vid==g_id_option_exclusive:
					is_exclusive=1
					ctUnique([g_id_option_exclusive,pobjfn_dup])=is_exclusive
					continue
				if !vid:
					errorAtExpr(ETYPE_ERROR,peargname,"symbolicDerivative(function,'var',...) requires all variable names to be strings, but '@1' isn't one".Replace(["@1",citeexpr(peargname)]))
					continue
				pobj_vderiv=lookupFunctionVariable(pobjfn_dup,vid)
				if !pobj_vderiv:
					errorAtExpr(ETYPE_WARNING,peargname,"'@1' did not appear in function '@2' at all, the corresponding partial derivative is always zero and would be dropped".Replace(["@1",getIdString(vid),"@2",citeexpr(peargname)]))
					continue
				var_list_params.push(pobj_vderiv)
			pobj_var_return=getReturnVariable(pobjfn_dup)
			if !pobj_var_return:
				errorAtExpr(ETYPE_ERROR,readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),"to compute derivatives, the original function must return something")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			var_list_ret=[pobj_var_return]
			addFunctionUser(pobjfn_dup,pecall)
			g_strflatten_monitored_variables[pecall+0]=var_list_ret
			g_strflatten_monitored_variables[pecall+1]=var_list_params
		}
		//ensure we evaluate it inside-out
		waiting_on_inner_symderiv=0
		ftest_inner_symderiv=function(PExpression pe){
			if isBuiltin(pe,g_id_assert_ctval)||isBuiltin(pe,g_id_function):return 0
			if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return 0
			if isBuiltin(pe,g_id_symderiv)||isBuiltin(pe,g_id_inline_clone):
				if DEBUG_DUMP_DERIV:
					Writeln('symderiv / inline clone - ',dumpExpr(pe,NULL))
				waiting_on_inner_symderiv=1
			val=getExprValue(pe)
			if val.tid==g_vtid_UNINIT&&pe==readPool(readPool(pe+EXPR_OFS_CALLER)+EXPR_OFS_FUNCTION):
				//uninited function, could be symderiv
				if DEBUG_DUMP_DERIV:
					Writeln('uninited function - ',dumpExpr(pe,NULL))
				waiting_on_inner_symderiv=1
			return !waiting_on_inner_symderiv
		}
		dfsExpr(readPool(pobjfn_dup+FUNCTION_OFS_CODE),ftest_inner_symderiv)
		if waiting_on_inner_symderiv:
			if DEBUG_DUMP_DERIV:
				Writeln('waiting_on_inner_symderiv')
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		//wait for flattening and queue on the waiting variable - create a child
		if localflatten(pecall,pobjfn_dup):
			var_list_ret=g_strflatten_monitored_variables[pecall+0]
			var_list_params=g_strflatten_monitored_variables[pecall+1]
			//we have to re-optimize after every flattening pass!
			cdfOptimize(pobjfn_dup,var_list_ret)
		//but we can't queue on structs / classes
		//the strings are no longer useful, smash them
		//Writeln('wait for flattening >>>')
		foreach pobj_var in var_list_ret
			t=getVariableType(pobj_var)
			//Writeln(dumpType(t),' ',dumpObject(pobj_var))
			if !t||tisclass(t):
				//g_strflatten_eval_queue.push(pecall)
				sccpQueueReach(insertCallAt(pecall,~1,function(){return !t?exprvar(pobj_var):expriptr(0)}))
				if DEBUG_DUMP_DERIV:
					Writeln('waiting on ret variable ',dumpObject(pobj_var),' ',t?dumpType(t):"typeless")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		foreach pobj_var in var_list_params
			t=getVariableType(pobj_var)
			//Writeln(dumpType(t),' ',dumpObject(pobj_var))
			if !t||tisclass(t):
				//g_strflatten_eval_queue.push(pecall)
				sccpQueueReach(insertCallAt(pecall,~1,function(){return !t?exprvar(pobj_var):expriptr(0)}))
				if DEBUG_DUMP_DERIV:
					Writeln('waiting on param variable ',dumpObject(pobj_var),' ',t?dumpType(t):"typeless")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		//Writeln(parser.Canonical.dumpExpr(fn.pe_decl,fcolor_reach_eval))
		all_final_vars=new PCTObject[][]
		for passi=0:1
			foreach pobj_vderiv,J in var_list_params
				auto code=readPool(pobjfn_dup+FUNCTION_OFS_CODE)
				clearUserFlags(code,USER_FLAG_ACTIVATED)
				//mark the variable-related ops
				setUserFlag(pobj_vderiv,FLAG_RELATED)
				Q=[pobj_vderiv|0x80000000]
				for(I=0;I<Q.n;I++)
					if Q[I]&0x80000000:
						pobj_var=Q[I]&~0x80000000
						if !pobj_var||!isVariable(pobj_var):continue
						if DEBUG_DUMP_DERIV:
							Writeln('related: ',dumpObject(pobj_var))
						vdata=readPoolTyped(pobj_var,TVariable)
						//Writeln(string.ToHex(fn.scope))
						for(peuser=vdata.first_v_user;peuser;peuser=readPool(peuser+EXPR_OFS_NEXT_V_USER))
							//if DEBUG_DUMP_DERIV:
							//	Writeln('  deriv-user: ',dumpExpr(peuser,NULL))
							if !testUserFlag(peuser,USER_FLAG_ACTIVATED):continue
							if testUserFlag(peuser,FLAG_RELATED):continue
							//Writeln('^_^')
							setUserFlag(peuser,FLAG_RELATED)
							Q.push(peuser)
					else
						pe=Q[I]
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						if DEBUG_DUMP_DERIV:
							Writeln(FormatAsText('related: ',dumpExpr(pe,fcolor_reach_eval),' ',isSpecial(pecaller)?"special":""))
						if isSpecial(pecaller):
							//Writeln('special ',pecaller)
							if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+1)==pe:
								pobj_var=getStoreTarget(pecaller)
								//Writeln(pobj_var)
								if pobj_var&&testUserFlag(pobj_var,USER_FLAG_ACTIVATED)&&!testUserFlag(pobj_var,FLAG_RELATED):
									//double-queueing is fine
									//Writeln('queue ',pobj_var,' ',readPoolTyped(pobj_var,TVariable).first_v_user)
									setUserFlag(pobj_var,FLAG_RELATED)
									Q.push(pobj_var|0x80000000)
							if passi==0:
								if isBuiltin(pecaller,g_id_stdot)&&readPool(pecaller+EXPR_OFS_ARGS+2)==pe:
									//all related variables have to be flattened before we can do this
									clearUserFlags(code,0)
									if DEBUG_DUMP_DERIV:
										Writeln('waiting on ',dumpExpr(pecaller,NULL))
									return TSCCPValue(){'tid':g_vtid_UNINIT}
							//flow control and stuff are ignored
							continue
						if !testUserFlag(pecaller,USER_FLAG_ACTIVATED):continue
						if testUserFlag(pecaller,FLAG_RELATED):continue
						if DEBUG_DUMP_DERIV:
							Writeln('queue caller: ',dumpExpr(pecaller,NULL))
						setUserFlag(pecaller,FLAG_RELATED)
						Q.push(pecaller)
				if DEBUG_DUMP_USER_FLAGS:
					Writeln('final-relevant: ',Q)
				//mark the result-affecting ops - store chain
				final_vars=new PCTObject[]
				Q=new PCTObject[]
				foreach pobj_var in var_list_ret
					Q.push(pobj_var|0x80000000)
				for(I=0;I<Q.n;I++)
					if Q[I]&0x80000000:
						pobj_var=Q[I]&~0x80000000
						if !pobj_var||!isVariable(pobj_var):continue
						if testUserFlag(pobj_var,USER_FLAG_ACTIVATED|FLAG_RELATED|FLAG_REQUIRED)==(USER_FLAG_ACTIVATED|FLAG_RELATED|FLAG_REQUIRED):
							//we need to deriv this var
							if pobj_var!=pobj_vderiv:
								final_vars.push(pobj_var)
						vdata=readPoolTyped(pobj_var,TVariable)
						for(pestore=vdata.first_v_store;pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
							if !testUserFlag(pestore,USER_FLAG_ACTIVATED):continue
							if testUserFlag(pestore,FLAG_REQUIRED):continue
							setUserFlag(pestore,FLAG_REQUIRED)
							Q.push(pestore)
							//Write(pobj_var,' ',pestore,' ');Writeln(parser.Canonical.dumpCode(pestore,fcolor_user_flags))
					else
						pe=Q[I]
						if !testUserFlag(pe,USER_FLAG_ACTIVATED):continue
						//if isSpecial(pe)&&!isStore(pecaller):
						//	continue
						flags=readPool(pe)
						if (flags&EFLAG_MASK)==EFLAG_FCALL:
							n_args_pe=flags&~EFLAG_MASK
							//Writeln(parser.Canonical.dumpCode(pe,fcolor_user_flags))
							//Writeln(n_args_pe)
							for i=0:n_args_pe-1
								pearg=readPool(pe+EXPR_OFS_ARGS+i)
								if testUserFlag(pearg,FLAG_REQUIRED):continue
								setUserFlag(pearg,FLAG_REQUIRED)
								Q.push(pearg)
								//Writeln(parser.Canonical.dumpCode(pearg,fcolor_user_flags))
						else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
							pobj_var=getVariable(pe)
							if pobj_var&&testUserFlag(pobj_var,USER_FLAG_ACTIVATED)&&!testUserFlag(pobj_var,FLAG_REQUIRED):
								setUserFlag(pobj_var,FLAG_REQUIRED)
								Q.push(pobj_var|0x80000000)
				if DEBUG_DUMP_DERIV:
					//if passi==1:
					//Writeln(dumpCode(code,fcolor_reach_eval))
					//System.IO.stdin.ReadLine()
					Writeln("user flags-"+dumpCode(code,fcolor_user_flags))
					//Writeln(final_vars,' ',pobj_var_return,' ',lookupFunctionVariable(pobjfn_dup,getid("return")))
					//System.IO.stdin.ReadLine()
				final_vars.Sort()
				final_vars.Unique()
				if passi==0:
					//relevance could be wrong here
					//foreach pobj_var in final_vars
					//	if readPool(pobj_var)==g_vtid_UNINIT:
					//		//all relevant variables have to become at least initialized before we can do the derivs
					//		clearUserFlags(code,0)
					//		return TSCCPValue(){'tid':g_vtid_UNINIT}
					//pull out the reusable expressions
					pulled_exprs=new PExpression[]
					auto pullReusable(PExpression pe)
						if isExpr(pe,EFLAG_FCALL):
							auto nargs=readPool(pe)&~EFLAG_MASK
							auto pobj_f=getAsFunction(getExprValueAs(readPool(pe+EXPR_OFS_FUNCTION+0),g_vtid_CTVAL))
							//it's OK for pobj_f to be NULL
							auto pulling_mask=ctUnique([g_id_deriv_pulling_masks,pobj_f])
							//Writeln('pulling_mask=',pulling_mask,' ',dumpObject(pobj_f))
							for i=0:nargs-1
								pearg=readPool(pe+EXPR_OFS_ARGS+i)
								need_recurse=(testUserFlag(pearg,FLAG_REQUIRED)&&testUserFlag(pearg,FLAG_RELATED))
								pulling_mask_arg=0
								if need_recurse:
									//we need to recurse in * / pow pulling
									//and we need to do it first to avoid sccrewing up ordering
									pulling_mask_arg=pullReusable(pearg)
								//else
								//	Writeln('no more recursion into ',dumpExpr(pearg,NULL),' ',testUserFlag(pearg,FLAG_REQUIRED),' ',testUserFlag(pearg,FLAG_RELATED))
								if !testUserFlag(pearg,FLAG_REQUIRED)||!testUserFlag(pearg,FLAG_RELATED)||((pulling_mask>>i)&1)||(pulling_mask_arg&DERIV_HAS_REUSABLE_COMPONENTS):
									if isExpr(pearg,EFLAG_FCALL):
										//pull out
										fpullout=function(PExpression pe){
											auto vtemp=makevar(pobjfn_dup)
											if need_recurse:
												setUserFlag(vtemp,FLAG_RELATED)
												setUserFlag(vtemp,FLAG_REQUIRED)
											pulled_exprs.push(call(g_id_store,exprvar(vtemp),pearg))
											return exprvar(vtemp)
										}
										sccpQueueReach(insertCallAt(pe,~i,fpullout))
							return pulling_mask
						return 0
					foreach pobj_var in final_vars
						vdata=readPoolTyped(pobj_var,TVariable)
						for(pestore=vdata.first_v_store;pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
							//if !testUserFlag(pestore,FLAG_REQUIRED):continue
							//if !testUserFlag(pestore,FLAG_RELATED):continue
							pulled_exprs.clear()
							pullReusable(readPool(pestore+EXPR_OFS_ARGS+1))
							if pulled_exprs.n:
								faddpulled=function(PExpression pestore0){
									pulled_exprs.push(pestore0)
									auto ret=vcall(g_id_block,pulled_exprs)
									pulled_exprs.clear()
									return ret
								}
								sccpQueueReach(insertCallAt(readPool(pestore+EXPR_OFS_CALLER),pestore,faddpulled))
						sccpProcessReaches()
				else
					//we still need a persistent flag to detect inline params - the map
					all_final_vars.push(final_vars)
					//Writeln(final_vars)
					//System.IO.stdin.ReadLine()
				clearUserFlags(code,0)
			if passi==0:
				//Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
				//pre-label all variables as -1
				flabelvar=function(PExpression pe){
					if isExpr(pe,EFLAG_VARIABLE):
						auto pobj_var=getVariable(pe)
						ctUnique([g_id_deriv,pobjfn_dup,pobj_var])=-1
					//else if isBuiltin(pe,g_id_extra_return):
					//	errorAtExpr(ETYPE_ERROR,pe,"to compute derivatives, the function can only return one value")
					return 1
				}
				dfsExpr(readPool(pobjfn_dup+FUNCTION_OFS_CODE),flabelvar)
		if DEBUG_DUMP_DERIV:
			Writeln("before add-deriv: "+dumpExpr(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),NULL))
		foreach final_vars,I in all_final_vars.ReverseOrder()
			foreach pobj_var in final_vars.ReverseOrder()
				if DEBUG_DUMP_DERIV:
					Writeln('add-deriv ',dumpObject(pobj_var),' ',I)
				derivAddVarDerivs(pobj_var,pobjfn_dup,var_list_params[I])
		////////
		//do the extra returns
		pe_tuple=makeTuple(int(var_list_ret.n*(!is_exclusive+var_list_params.n)))
		pv_return_new=makevar(pobjfn_dup)
		writePool(pv_return_new+VAR_OFS_ID,g_id_return)
		as=new PExpression[]
		as.push(call(g_id_store,exprvar(pv_return_new),pe_tuple))
		tuple_slot_id=0
		if !is_exclusive:
			foreach pobj_var_return in var_list_ret
				as.push(call(g_id_stdot,exprvar(pv_return_new),exprstr(getTupleId(tuple_slot_id)),exprvar(pobj_var_return)))
				tuple_slot_id++
		foreach pobj_vderiv,J in var_list_params
			foreach pobj_var_return in var_list_ret
				//Writeln(dumpObject(pobj_vderiv),' ',dumpObject(pobj_var_return))
				pvar_deriv=ctUnique([g_id_deriv,pobjfn_dup,pobj_var_return,pobj_vderiv])
				//assert(!!pvar_deriv)
				//as.push(exprvar(pvar_deriv))
				as.push(call(g_id_stdot,
					exprvar(pv_return_new),
					exprstr(getTupleId(tuple_slot_id)),
					pvar_deriv?exprvar(pvar_deriv):call(
						g_id_cast,
						exprctval(getVariableType(pobj_var_return)),
						expriptr(0))))
				tuple_slot_id++
		appendCode(pobjfn_dup,as)
		writePool(pobjfn_dup+FUNCTION_OFS_PVAR_RETURN,pv_return_new)
		///////////////
		pecaller=readPool(pecall+EXPR_OFS_CALLER)
		if pecaller:
			//insertCallAt(pecaller,pecall,function(PExpression pe0){writePool(pe0+EXPR_OFS_CALLER,0);return fn.pe_decl})
			pe_ret=exprctval(pobjfn_dup)
			sccpQueueReach(insertCallAt(pecaller,pecall,function(PExpression pe0){return pe_ret}))
			addFunctionUser(pobjfn_dup,pe_ret)
			//avoid duplicated eval
			insertCallAt(pecall,0,function(){return exprvar(g_symbols[g_id_nop].user_slot)})
		writePool(pobjfn_dup+FUNCTION_OFS_FLAGS,(readPool(pobjfn_dup+FUNCTION_OFS_FLAGS)&~FFLAG_IS_SYMDERIV_TEMP)|FFLAG_IS_SYMDERIV)
		if DEBUG_DUMP_DERIV:
			sccpProcessReaches()//warning: this may break/fix something!
			Writeln("after symderiv transformation: "+dumpExpr(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),fcolor_just_reach))
		return TSCCPValue(){'tid':g_vtid_CTVAL,'val':pobjfn_dup}
	}
	registerPrimitive(g_id_symderiv,fderiv_onreach,fsymderiv_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL|FFLAG_DEPENDS_ON_OTHER_CODE)
	finline_deriv_oneval=function(PExpression pecall,int expr_oplevel){
		//directly expand the thing
		//Writeln(parser.Canonical.dumpExpr(pecall,function(){return -1}))
		peexpr=readPool(pecall+(EXPR_OFS_ARGS+0))
		pobjfn=getExprValueAs(readPool(pecall+(EXPR_OFS_ARGS+1)),g_vtid_CNS)
		if !pobjfn:return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_vderiv=getExprValueAs(readPool(pecall+(EXPR_OFS_ARGS+2)),g_vtid_CTVAL)
		if !pobj_vderiv:return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_replace=0
		flags=readPool(peexpr)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//function deriv, add the prefix
			pobjfn_param=getAsFunction(getExprValueAs(readPool(peexpr+EXPR_OFS_FUNCTION+0),g_vtid_CTVAL))
			if pobjfn_param:
				pobjfn_deriv=readCtUniqueInEvalFlow(pecall,[g_id_deriv_callback,pobjfn_param])
				if !pobjfn_deriv:return TSCCPValue(){'tid':g_vtid_UNINIT}
				pobjfn_deriv=getAsFunction(pobjfn_deriv)
				if !pobjfn_deriv:return TSCCPValue(){'tid':g_vtid_UNINIT}
				n_args=(flags&~EFLAG_MASK)
				as=new int[]
				as.push(exprctval(pobjfn_deriv))
				as.push(g_ctobject_pool[peexpr+EXPR_OFS_ARGS:peexpr+EXPR_OFS_ARGS+n_args-1])
				as.push(expriptr(pobjfn))
				as.push(exprctval(pobj_vderiv))
				pe_replace=indcall(as)
			else
				//not a function, uninit
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			//look it up
			pobj_var=getVariable(peexpr)
			pvar_deriv=ctUnique([g_id_deriv,pobjfn,pobj_var,pobj_vderiv])
			if !pvar_deriv&&!ctUnique([g_id_deriv,pobjfn,pobj_var]):
				//newly created variables (possibly through inline, deriv it)
				ctUnique([g_id_deriv,pobjfn,pobj_var])=1
				derivAddVarDerivs(pobj_var,pobjfn,pobj_vderiv)
				pvar_deriv=ctUnique([g_id_deriv,pobjfn,pobj_var,pobj_vderiv])
			if pobj_var==pobj_vderiv:
				//typed one
				t=getVariableType(pobj_var)
				if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
				if tisbuiltin(t):
					ca=castConst(Util.ctNumber(getid_const(const_type(CTYPE_INT,32),1LL)),t)
					pe_replace=exprcns(getid_const(ca.type,ca.val_bin))
				else
					pe_replace=call(g_id_cast,exprctval(t),expriptr(1))
			else if pvar_deriv:
				pe_replace=exprvar(pvar_deriv)
			else
				//go for the generic zero
				pe_replace=0
		if !pe_replace:
			//typed zero
			t=getExprType(peexpr)
			if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
			if tisbuiltin(t):
				ca=castConst(Util.ctNumber(getid_const(const_type(CTYPE_INT,32),0LL)),t)
				pe_replace=exprcns(getid_const(ca.type,ca.val_bin))
			else
				pe_replace=call(g_id_cast,exprctval(t),expriptr(0))
		pecaller=readPool(pecall+EXPR_OFS_CALLER)
		fsubstitute=function(PExpression pe_unused){
			//setnop(pe_unused)
			return pe_replace
		}
		pe_replace=sccpQueueReach(insertCallAt(pecaller,pecall,fsubstitute))
		sccpQueueEval(pecaller)
		setnop(pecall)
		if isExpr(peexpr,EFLAG_FCALL):setnop(peexpr)//avoid eval on bad callers
		//return getExprValue(pe_replace)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(getid("_deriv"),fcompiler_callback.NULL,finline_deriv_oneval,fcompiler_callback.NULL,FFLAG_BUILTIN_HACK)
	fdeclare_deriv_oneval=function(PExpression pecall,int expr_oplevel){
		USER_FLAG_DERIVCB_RELEVANT=1
		//////////////
		n_args=getFCallNArgs(pecall)
		if n_args!=2:
			errorAtExpr(ETYPE_ERROR,pecall,"set__deriv(f,f') must take exactly 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobj_f=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		pobj_f_deriv=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
		if !pobj_f||!pobj_f_deriv||!readPool(pobj_f_deriv+FUNCTION_OFS_ONEVAL):
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if getCcnv(pobj_f_deriv)!=g_id_inline:
			errorAtExpr(ETYPE_ERROR,readPool(pecall+EXPR_OFS_ARGS+1),"derivative implementations must be inline")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		/////////////////////////
		//analyze pobj_f_deriv's code
		pe_code=readPool(pobj_f_deriv+FUNCTION_OFS_CODE)
		pvar_return=readPool(pobj_f_deriv+FUNCTION_OFS_PVAR_RETURN)
		clearUserFlags(pe_code,USER_FLAG_ACTIVATED)
		//only allow one-line expressions - pulling becomes a hassle otherwise
		occurances=new int[PCTObject]
		pv_params=new PCTObject[]
		auto analyzeDerivImpl(PExpression pe){
			auto ret=0
			if isExpr(pe,EFLAG_VARIABLE):
				occurances[getVariable(pe)]++
			else if isExpr(pe,EFLAG_FCALL):
				if isBuiltin(pe,g_id_function):return 0
				if isBuiltin(pe,g_id_store):
					pe_var=readPool(pe+EXPR_OFS_ARGS+0)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					assert(isExpr(pe_var,EFLAG_VARIABLE))
					if isBuiltin(pe_value,g_id_ldparam):
						paramid=getExprValueAs(readPool(pe_value+EXPR_OFS_ARGS+0),g_vtid_CNS)
						if pv_params.n<=paramid:
							pv_params.resize(paramid+1)
						pv_params[paramid]=getVariable(pe_var)
					else
						if readPool(pe_var)!=EFLAG_VARIABLE+pvar_return:
							//the function is unreached, we can't handle intermediate variables
							errorAtExpr(ETYPE_ERROR,pe,"derivative implementation cannot have intermediate variables like @1".Replace(["@1",citeexpr(pe_var)]))
							return 0
				else if isBuiltin(pe,g_id_deriv):
					//it is relevant
					ret=1
				n_args=getFCallNArgs(pe)
				for i=-1:n_args-1
					pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
					ret|=analyzeDerivImpl(pe_argi)
				if ret:
					setUserFlag(pe,USER_FLAG_DERIVCB_RELEVANT)
			return ret
		}
		analyzeDerivImpl(pe_code)
		//count # occurances of all params except the last two
		pull_param_mask=0
		for i=0:pv_params.n-3
			if occurances[pv_params[i]]>2:
				//more than 2 uses (and 1 ldparam ass), pull it
				pull_param_mask|=(1<<i)
		//factorize non-_deriv subexpressions, split into two parts, use a tuple to pass the stuff
		//DERIV_HAS_REUSABLE_COMPONENTS... pull_param_mask=-1 - need pull all args
		pv_to_pull=new PCTObject[]
		auto checkReusableComponents(PExpression pe)
			if isExpr(pe,EFLAG_FCALL):
				ignore_reuse_pulling=(isBuiltin(pe,g_id_block)||isBuiltin(pe,g_id_store))
				n_args=getFCallNArgs(pe)
				for i=-1:n_args-1
					pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
					if !ignore_reuse_pulling&&!testUserFlag(pe_argi,USER_FLAG_DERIVCB_RELEVANT)&&i>=0:
						if isExpr(pe_argi,EFLAG_FCALL)
							//pull it
							pull_param_mask=-1
							pv_temp=makevar(pobj_f_deriv)
							pv_to_pull.push(pv_temp)
							if DEBUG_DUMP_DERIV:
								Writeln("mark as reusable: "+dumpExpr(pe_argi,NULL))
							//tempify
							transformCodeEx(pe_argi,function(PExpression pe_argi){return call(g_id_store,exprvar(pv_temp),pe_argi)}, NULL,exprvar(pv_temp),NULL,0)
					else
						checkReusableComponents(pe_argi)
		checkReusableComponents(pe_code)
		if pull_param_mask&DERIV_HAS_REUSABLE_COMPONENTS:
			//just clone and ldparam the stores / setnop everything else
			var_map=new PCTObject[PCTObject]
			pobjfn_compute_reusable_components=cloneFunctionEx(pobj_f_deriv,var_map,CLONE_WIPE_TO_UNREACHED|CLONE_VARS|CLONE_KEEP_VAR_IDS)
			pv_to_pull_cloned=new PCTObject[pv_to_pull.n]
			is_var_reused=new int[PCTObject]
			is_var_valid=new int[PCTObject]
			foreach pobj_var,I in pv_to_pull
				pv_cloned=var_map[pobj_var]
				is_var_reused[pobj_var]=int(I+1)
				is_var_valid[pv_cloned]=int(I+1)
				pv_to_pull_cloned[I]=pv_cloned
			//setnop pobjfn_compute_reusable_components
			pe_code_compute_reusable=readPool(pobjfn_compute_reusable_components+FUNCTION_OFS_CODE)
			fsetnop_deriv_part=function(PExpression pe){
				if isBuiltin(pe,g_id_store):
					pe_var=readPool(pe+EXPR_OFS_ARGS+0)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					assert(isExpr(pe_var,EFLAG_VARIABLE))
					pobj_var=getVariable(pe_var)
					if !is_var_valid[pobj_var]&&!isBuiltin(pe_value,g_id_ldparam):
						setnop(pe)
						return 0
				return 1
			}
			dfsExpr(pe_code_compute_reusable,fsetnop_deriv_part)
			//build tuple and return it
			//there are two unused args, leave them there
			assert(isBuiltin(pe_code_compute_reusable,g_id_block))
			pvar_return_cloned=var_map[pvar_return]
			as_tuple_ret=new PExpression[]
			n_args_block=getFCallNArgs(pe_code_compute_reusable)
			for i=0:n_args_block-1
				as_tuple_ret.push(readPool(pe_code_compute_reusable+EXPR_OFS_ARGS+i))
			as_tuple_ret.push(call(g_id_store,exprvar(pvar_return_cloned),makeTuple(int(pv_to_pull_cloned.n))))
			foreach pobj_var,I in pv_to_pull_cloned
				as_tuple_ret.push(call(g_id_stdot,exprvar(pvar_return_cloned),exprstr(getTupleId(int(I))),exprvar(pobj_var)))
			pe_code_compute_reusable=replaceBlockArgs(pe_code_compute_reusable,as_tuple_ret,1)
			writePool(pobjfn_compute_reusable_components+FUNCTION_OFS_CODE,pe_code_compute_reusable)
			//add the arg to pobj_f_deriv
			pe_decl_f_deriv=readPool(pobj_f_deriv+FUNCTION_OFS_PEDECL)
			as_new_decl_args=new PExpression[]
			n_args_block=getFCallNArgs(pe_decl_f_deriv)
			argid_reusable=-1
			for i=-1:n_args_block-1
				if i==n_args_block-5:
					//insert the arg before the deriv args
					as_new_decl_args.push(exprstr(g_id_auto))
					as_new_decl_args.push(exprstr(g_id_deriv_reusable_components))
					argid_reusable=((i-1)>>1)
				as_new_decl_args.push(readPool(pe_decl_f_deriv+EXPR_OFS_ARGS+i))
			pe_decl_f_arg_added=indcall(as_new_decl_args)
			writePool(pe_decl_f_arg_added+EXPR_OFS_VALUE,readPool(pe_decl_f_deriv+EXPR_OFS_VALUE))
			writePool(pe_decl_f_arg_added+EXPR_OFS_VALUE+1,readPool(pe_decl_f_deriv+EXPR_OFS_VALUE+1))
			writePool(pobj_f_deriv+FUNCTION_OFS_PEDECL,pe_decl_f_arg_added)
			//it's inline, it doesn't need param value slots
			writePool(pobj_f_deriv+FUNCTION_OFS_PPARAM_VALUE_SLOTS,0)
			//add ldparam and dot-ify the pulled variables
			pv_tuple_param=PCTObject(0)
			fdottify_pulled=function(PExpression pe){
				if isBuiltin(pe,g_id_store):
					pe_var=readPool(pe+EXPR_OFS_ARGS+0)
					//pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					assert(isExpr(pe_var,EFLAG_VARIABLE))
					pobj_var=getVariable(pe_var)
					tuple_slot_id=is_var_reused[pobj_var]-1
					if tuple_slot_id>=0:
						if !pv_tuple_param:
							pv_tuple_param=makevar(pobj_f_deriv)
							pe_store_tuple=call(g_id_store,exprvar(pv_tuple_param),call(g_id_ldparam,expriptr(argid_reusable),expriptr(0),exprstr(g_id_deriv_reusable_components)))
							transformCodeEx(pe,NULL, [pe_store_tuple],0,NULL,0)
						pe_replacement=call(g_id_dot,exprvar(pv_tuple_param),exprstr(getTupleId(tuple_slot_id)))
						insertCallAt(pe,~1,function(){return pe_replacement})
				else if isBuiltin(pe,g_id_ldparam):
					paramid=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_CNS)
					if paramid>=argid_reusable:
						insertCallAt(pe,~0,function(){return expriptr(paramid+1)})
				return 1
			}
			dfsExpr(pe_code,fdottify_pulled)
			if DEBUG_DUMP_DERIV:
				Writeln("compute_reusable: "+dumpExpr(pe_code_compute_reusable,NULL))
				Writeln("original: "+dumpExpr(pe_code,NULL))
			ctUnique([g_id_deriv_reusable_components,pobj_f])=pobjfn_compute_reusable_components
		/////
		clearUserFlags(pe_code,0)
		if pull_param_mask:
			//first deriv translation happens in the code-dependent pass, by when the sets are long evaluated
			ctUnique([g_id_deriv_pulling_masks,pobj_f])=pull_param_mask
		//Writeln(dumpObject(pobj_f),' ',dumpObject(pobj_f_deriv))
		writeCtUniqueInEvalFlow([g_id_deriv_callback,pobj_f],pobj_f_deriv)
		setnop(pecall)
		return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),1LL)}
	}
	registerPrimitive(getid("set__deriv"),fcompiler_callback.NULL,fdeclare_deriv_oneval,fdummy_callback,FFLAG_BUILTIN_HACK)
	//////////////////////////////////////
	//quadratic decomposition
	fANMdecompose_onreach=function(PExpression pecall,int expr_oplevel){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args<2:
			errorAtExpr(ETYPE_ERROR,pecall,"__ANM_decompose(function,'var',...) needs at least 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pefunc=readPool(pecall+EXPR_OFS_ARGS)
		sccpQueueReach(pefunc)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	fANMdecompose_oneval=function(PExpression pecall,int is_cdf_pass){
		er=readPoolTyped(pecall,TExpression)
		n_args=(er.flags_n_args&~EFLAG_MASK)
		if n_args<2:
			errorAtExpr(ETYPE_ERROR,pecall,"__ANM_decompose(function,'var',...) needs at least 2 parameters")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pefunc=readPool(pecall+EXPR_OFS_ARGS)
		val=getExprValue(pefunc)
		if val.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if val.tid!=g_vtid_CTVAL:
			errorAtExpr(ETYPE_ERROR,pecall,"__ANM_decompose(function,'var',...) requires a function as its first parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn=getAsFunction(val.val)
		if !pobjfn:
			errorAtExpr(ETYPE_ERROR,pecall,"__ANM_decompose(function,'var',...) requires a function as its first parameter")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !is_cdf_pass:
			//varify arg/ret elements, if any is available
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pobjfn_dup=ctUnique([g_id_ANM_decompose,pobjfn])
		if !pobjfn_dup:
			pobjfn_dup=cloneFunction(pobjfn)
			setFFlag(pobjfn_dup,FFLAG_IS_SYMDERIV_TEMP)
			ctUnique([g_id_ANM_decompose,pobjfn])=pobjfn_dup
			setFunctionUsed(pobjfn_dup)
			setParameterSlotTypes(pobjfn_dup)
			sccpProcessReaches()
			sccp(0)
		//check the variable names
		var_list_ret=g_strflatten_monitored_variables[pecall+0]
		var_list_params=g_strflatten_monitored_variables[pecall+1]
		if !var_list_ret:{
			//set up the variable lists
			var_list_params=new PCTObject[]
			for i=1:n_args-1
				peargname=readPool(pecall+EXPR_OFS_ARGS+i)
				vid=getExprValueAs(peargname,g_vtid_STR)
				if !vid:
					errorAtExpr(ETYPE_ERROR,peargname,"__ANM_decompose(function,'var',...) requires all variable names to be strings, but '@1' isn't one".Replace(["@1",citeexpr(peargname)]))
					continue
				pobj_vderiv=lookupFunctionVariable(pobjfn_dup,vid)
				if !pobj_vderiv:
					errorAtExpr(ETYPE_ERROR,peargname,"'@1' did not appear in function '@2' at all, ANM decomposition cannot proceed".Replace(["@1",getIdString(vid),"@2",citeexpr(peargname)]))
					continue
				var_list_params.push(pobj_vderiv)
			pobj_var_return=getReturnVariable(pobjfn_dup)
			if !pobj_var_return:
				errorAtExpr(ETYPE_ERROR,readPool(pobjfn_dup+FUNCTION_OFS_PEDECL),"the original function must return something for the original equations")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			var_list_ret=[pobj_var_return]
			addFunctionUser(pobjfn_dup,pecall)
			g_strflatten_monitored_variables[pecall+0]=var_list_ret
			g_strflatten_monitored_variables[pecall+1]=var_list_params
		}
		//ensure we evaluate it inside-out
		waiting_on_inner_symderiv=0
		ftest_inner_symderiv=function(PExpression pe){
			if isBuiltin(pe,g_id_assert_ctval)||isBuiltin(pe,g_id_function):return 0
			if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return 0
			//__ANM_decompose cannot nest
			if isBuiltin(pe,g_id_symderiv)||isBuiltin(pe,g_id_inline_clone)||isBuiltin(pe,g_id_deriv):
				if DEBUG_DUMP_DERIV:
					Writeln('symderiv / inline clone - ',dumpExpr(pe,NULL))
				waiting_on_inner_symderiv=1
			val=getExprValue(pe)
			if val.tid==g_vtid_UNINIT&&pe==readPool(readPool(pe+EXPR_OFS_CALLER)+EXPR_OFS_FUNCTION):
				//uninited function, could be symderiv
				if DEBUG_DUMP_DERIV:
					Writeln('uninited function - ',dumpExpr(pe,NULL))
				waiting_on_inner_symderiv=1
			return !waiting_on_inner_symderiv
		}
		dfsExpr(readPool(pobjfn_dup+FUNCTION_OFS_CODE),ftest_inner_symderiv)
		if waiting_on_inner_symderiv:
			if DEBUG_DUMP_DERIV:
				Writeln('waiting_on_inner_symderiv')
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if localflatten(pecall,pobjfn_dup):
			var_list_ret=g_strflatten_monitored_variables[pecall+0]
			var_list_params=g_strflatten_monitored_variables[pecall+1]
			//we have to re-optimize after every flattening pass!
			cdfOptimize(pobjfn_dup,var_list_ret)
		//Writeln('var_list_ret>>> ',pecall+0,' ',var_list_ret)
		//Writeln('var_list_params>>> ',pecall+1,' ',var_list_params)
		//wait for flattening and queue on the waiting variable - create a child
		//but we can't queue on structs / classes
		//the strings are no longer useful, smash them
		//Writeln('wait for flattening >>>')
		foreach pobj_var in var_list_ret
			t=getVariableType(pobj_var)
			//Writeln(dumpType(t),' ',dumpObject(pobj_var))
			if !t||tisclass(t):
				//varifyDblMembers(pecall,t)
				//g_strflatten_eval_queue.push(pecall)
				sccpQueueReach(insertCallAt(pecall,~1,function(){return !t?exprvar(pobj_var):expriptr(0)}))
				if DEBUG_DUMP_DERIV:
					Writeln('waiting on ret variable ',dumpObject(pobj_var),' ',t?dumpType(t):"typeless")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		foreach pobj_var in var_list_params
			t=getVariableType(pobj_var)
			//Writeln(dumpType(t),' ',dumpObject(pobj_var))
			if !t||tisclass(t):
				//varifyDblMembers(pecall,t)
				//g_strflatten_eval_queue.push(pecall)
				sccpQueueReach(insertCallAt(pecall,~1,function(){return !t?exprvar(pobj_var):expriptr(0)}))
				if DEBUG_DUMP_DERIV:
					Writeln('waiting on param variable ',dumpObject(pobj_var),' ',t?dumpType(t):"typeless")
				return TSCCPValue(){'tid':g_vtid_UNINIT}
		auto code=readPool(pobjfn_dup+FUNCTION_OFS_CODE)
		pe_decl=readPool(pobjfn_dup+FUNCTION_OFS_PEDECL)
		n_args_decl=getFCallNArgs(pe_decl)
		assert(readPool(pe_decl+EXPR_OFS_ARGS+n_args_decl-1)==code)
		clearUserFlags(code,USER_FLAG_ACTIVATED)
		//Writeln('code-shit:')
		//Writeln(dumpExpr(code,NULL))
		//mark the variable-related ops
		Q=new PCTObject[]
		foreach pobj_vderiv,J in var_list_params
			setUserFlag(pobj_vderiv,FLAG_RELATED)
			Q.push(pobj_vderiv|0x80000000)
		for(I=0;I<Q.n;I++)
			if Q[I]&0x80000000:
				pobj_var=Q[I]&~0x80000000
				if !pobj_var||!isVariable(pobj_var):continue
				if DEBUG_DUMP_DERIV:
					Writeln('related: ',dumpObject(pobj_var))
				vdata=readPoolTyped(pobj_var,TVariable)
				//Writeln(string.ToHex(fn.scope))
				for(peuser=vdata.first_v_user;peuser;peuser=readPool(peuser+EXPR_OFS_NEXT_V_USER))
					//if DEBUG_DUMP_DERIV:
					//	Writeln('  user: ',dumpExpr(peuser,NULL),' ',testUserFlag(peuser,USER_FLAG_ACTIVATED),' ',testUserFlag(peuser,FLAG_RELATED))
					if !testUserFlag(peuser,USER_FLAG_ACTIVATED):continue
					if testUserFlag(peuser,FLAG_RELATED):continue
					//Writeln('^_^')
					setUserFlag(peuser,FLAG_RELATED)
					Q.push(peuser)
			else
				pe=Q[I]
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if DEBUG_DUMP_DERIV:
					Writeln(FormatAsText('related: ',dumpExpr(pe,fcolor_reach_eval),' ',isSpecial(pecaller)?"special":""))
				if isSpecial(pecaller):
					//Writeln('special ',pecaller)
					if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+1)==pe:
						pobj_var=getStoreTarget(pecaller)
						//Writeln(pobj_var)
						if pobj_var&&testUserFlag(pobj_var,USER_FLAG_ACTIVATED)&&!testUserFlag(pobj_var,FLAG_RELATED):
							//double-queueing is fine
							//Writeln('queue ',pobj_var,' ',readPoolTyped(pobj_var,TVariable).first_v_user)
							setUserFlag(pobj_var,FLAG_RELATED)
							Q.push(pobj_var|0x80000000)
					if isBuiltin(pecaller,g_id_stdot)&&readPool(pecaller+EXPR_OFS_ARGS+2)==pe:
						//all related variables have to be flattened before we can do this
						clearUserFlags(code,0)
						if DEBUG_DUMP_DERIV:
							Writeln('waiting on ',dumpExpr(pecaller,NULL))
						return TSCCPValue(){'tid':g_vtid_UNINIT}
					//flow control and stuff are ignored
					continue
				if !testUserFlag(pecaller,USER_FLAG_ACTIVATED):continue
				if testUserFlag(pecaller,FLAG_RELATED):continue
				if DEBUG_DUMP_DERIV:
					Writeln('queue caller: ',dumpExpr(pecaller,NULL))
				setUserFlag(pecaller,FLAG_RELATED)
				Q.push(pecaller)
		//final_vars=new PCTObject[]
		Q=new PCTObject[]
		foreach pobj_var in var_list_ret
			Q.push(pobj_var|0x80000000)
		for(I=0;I<Q.n;I++)
			if Q[I]&0x80000000:
				pobj_var=Q[I]&~0x80000000
				if !pobj_var||!isVariable(pobj_var):continue
				//if testUserFlag(pobj_var,USER_FLAG_ACTIVATED|FLAG_RELATED|FLAG_REQUIRED)==(USER_FLAG_ACTIVATED|FLAG_RELATED|FLAG_REQUIRED):
				//	//we need to deriv this var
				//	if pobj_var!=pobj_vderiv:
				//		final_vars.push(pobj_var)
				vdata=readPoolTyped(pobj_var,TVariable)
				for(pestore=vdata.first_v_store;pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
					if !testUserFlag(pestore,USER_FLAG_ACTIVATED):continue
					if testUserFlag(pestore,FLAG_REQUIRED):continue
					setUserFlag(pestore,FLAG_REQUIRED)
					Q.push(pestore)
					//Write(pobj_var,' ',pestore,' ');Writeln(parser.Canonical.dumpCode(pestore,fcolor_user_flags))
			else
				pe=Q[I]
				if !testUserFlag(pe,USER_FLAG_ACTIVATED):continue
				//if isSpecial(pe)&&!isStore(pecaller):
				//	continue
				flags=readPool(pe)
				if (flags&EFLAG_MASK)==EFLAG_FCALL:
					n_args_pe=flags&~EFLAG_MASK
					//Writeln(parser.Canonical.dumpCode(pe,fcolor_user_flags))
					//Writeln(n_args_pe)
					for i=0:n_args_pe-1
						pearg=readPool(pe+EXPR_OFS_ARGS+i)
						if testUserFlag(pearg,FLAG_REQUIRED):continue
						setUserFlag(pearg,FLAG_REQUIRED)
						Q.push(pearg)
						//Writeln(parser.Canonical.dumpCode(pearg,fcolor_user_flags))
				else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
					pobj_var=getVariable(pe)
					if pobj_var&&testUserFlag(pobj_var,USER_FLAG_ACTIVATED)&&!testUserFlag(pobj_var,FLAG_REQUIRED):
						setUserFlag(pobj_var,FLAG_REQUIRED)
						Q.push(pobj_var|0x80000000)
		//if DEBUG_DUMP_DERIV:
		//	Writeln('final-relevant: ',final_vars)
		//generate the new function / constants
		//use interpretation - the function only serves to precompute the unrelated const table - maul the original? pobjfn_dup
		//consts could get involved in various ways...
		//unify consts vs vars?
		//var-const interaction: + - * / pow
		//need a dedicated IR, and sth gvn-like (created intermediates, var to equ row/column)
		struct TQuadTerm
			int var_a,var_b
			int const_id
		class CEquationTerm
			TQuadTerm[] terms
			PExpression pe
		all_equations=new CEquationTerm[]
		////////////////
		auto addEquation(CEquationTerm eq)
			all_equations.push(eq)
		////////////////
		struct TEquConst
			PCTObject pvar
			int is_cns
			int is_rcp
			int is_neg
		pv_const_array=makevar(pobjfn_dup)
		cvid_map=new int[int]
		consts=new TEquConst[]
		cid_dbl0=getid_const(const_type(CTYPE_FLOAT,64),__double_as_longlong(0.0))
		cid_dbl1=getid_const(const_type(CTYPE_FLOAT,64),__double_as_longlong(1.0))
		as_cstores=new PExpression[2]
		//0 and 1 are the const array allocations
		auto cnsVariableId(PCTObject pvar,int is_cns,int is_rcp,int is_neg)
			auto key=(is_cns?0x80000000+pvar:pvar*4+is_rcp*2+is_neg)
			auto ret=cvid_map[key]
			if !ret:
				ret=int(consts.n)
				consts.push(TEquConst(){'pvar':pvar,'is_cns':is_cns,'is_rcp':is_rcp,'is_neg':is_neg})
				peval=is_cns?exprcns(pvar):exprvar(pvar)
				if is_rcp:peval=call(g_id_operator_div,exprcns(cid_dbl1),peval)
				if is_neg:peval=call(g_id_operator_sub,exprcns(cid_dbl0),peval)
				as_cstores.push(indcall([call(g_id_dot,exprvar(pv_const_array),exprstr(g_id_set_operator_bracket)),expriptr(ret),peval]))
				cvid_map[key]=ret
			return ret
		auto cnsNeg(int cvid)
			ec=consts[cvid]
			if ec.is_cns:
				ca=Util.ctNumber(ec.pvar)
				ct_result=ca.type
				if ct_result==const_type(CTYPE_FLOAT,32):
					ca.val_bin^=0x80000000L
				else if ct_result==const_type(CTYPE_FLOAT,64):
					ca.val_bin^=0x8000000000000000LL
				else
					ca.val_bin=-ca.val_bin
				ec.pvar=getid_const(ca.type,ca.val_bin)
			else
				ec.is_neg=!ec.is_neg
			return cnsVariableId(ec.pvar,ec.is_cns,ec.is_rcp,ec.is_neg)
		auto cnsRcp(int cvid)
			ec=consts[cvid]
			if ec.is_cns:
				ca=Util.ctNumber(ec.pvar)
				ca=castConst(ca,const_type(CTYPE_FLOAT,64))
				ca.val_bin=__double_as_longlong(1./__longlong_as_double(ca.val_bin))
				ec.pvar=getid_const(ca.type,ca.val_bin)
			else
				ec.is_rcp=!ec.is_rcp
			return cnsVariableId(ec.pvar,ec.is_cns,ec.is_rcp,ec.is_neg)
		auto cnsMul(int cvid0,int cvid1)
			auto pv_temp=makevar(pobjfn_dup)
			as_cstores.push(call(g_id_store,exprvar(pv_temp),call(g_id_operator_mul,
				indcall([call(g_id_dot,exprvar(pv_const_array),exprstr(g_id_operator_bracket)),expriptr(cvid0)]),
				indcall([call(g_id_dot,exprvar(pv_const_array),exprstr(g_id_operator_bracket)),expriptr(cvid1)]))))
			return cnsVariableId(pv_temp,0,0,0)
		/////////////////////////
		auto dumpEquation(CEquationTerm pequ)
			auto s=new string
			foreach et in pequ.terms
				s.push(FormatAsText('+C',et.const_id,'*'))
				if et.var_a>=0:s.push(FormatAsText('x',et.var_a))
				if et.var_b>=0:s.push(FormatAsText('x',et.var_b))
			return s
		/////////////////////////
		//create 1 and -1
		cnsVariableId(cid_dbl1,1,0,0)
		cnsVariableId(getid_const(const_type(CTYPE_FLOAT,64),__double_as_longlong(-1.0)),1,0,0)
		evid_map=new int[i64]
		evid_realvar=new PCTObject[]
		auto equPowerTo(int evid,int poweri)
			assert(poweri>0)
			if poweri==1:
				pequ=new CEquationTerm
				pequ.terms=[TQuadTerm{'var_a':evid,'var_b':-1,'const_id':0}]
				pequ.pe=exprvar(evid_realvar[evid])
				return pequ
			pequ0=equPowerTo(evid,poweri>>1)
			if pequ0.terms.n!=1||pequ0.terms[0].var_b!=-1:pequ0=equMakeVar(pequ0)
			assert(pequ0.terms.n==1&&pequ0.terms[0].var_b==-1)
			assert(pequ0.terms[0].var_a!=-1)
			pequ0.terms[0].var_b=pequ0.terms[0].var_a
			//it should be cheap to clone
			pequ0.pe=call(g_id_operator_mul,pequ0.pe,cloneExpr(pequ0.pe))
			if poweri&1:
				pequ0=equMakeVar(pequ0)
				pequ0.terms[0].var_b=evid
				pequ0.pe=call(g_id_operator_mul,pequ0.pe,exprvar(evid_realvar[evid]))
			return pequ0
		//do not use original code, regenerate expr for every var
		auto equVariableId(PCTObject pvar,int inv_power)
			auto key=((i64(pvar)<<32)|i64(u32(inv_power)))
			auto ret=evid_map[key]-1
			if ret==-1:
				if inv_power==1:
					ret=int(evid_realvar.n)
					evid_map[key]=ret+1
					evid_realvar.push(pvar)
				else
					evid_original=equVariableId(pvar,1)//should have appeared before, OK to call it here
					ret=int(evid_realvar.n)
					evid_map[key]=ret+1
					pvar_new=makevar(pobjfn_dup)
					evid_realvar.push(pvar_new)
					key2=((i64(pvar_new)<<32)|1LL)
					evid_map[key2]=ret+1
					//for pow, it won't be lower triangular
					p_cstores=as_cstores.n
					as_cstores.push(0)
					pequ0=equPowerTo(ret,System.Math.abs(inv_power))
					if inv_power==-1:
						pe_root=call(g_id_operator_div,exprcns(cid_dbl1),exprvar(evid_realvar[evid_original]))
					else
						pobjfn_powd=readCtUniqueInEvalFlow(pecall,[g_id_meta_state,getid("__ANM_powd")])
						pe_root=indcall([exprctval(pobjfn_powd),exprvar(evid_realvar[evid_original]),exprcns(getid_const(const_type(CTYPE_FLOAT,64),__double_as_longlong(1.0/double(inv_power))))])
					//this must be done *before* the power!
					as_cstores[p_cstores]=call(g_id_store,exprvar(pvar_new),pe_root)
					if inv_power<0:
						//*evid_original-1
						if pequ0.terms.n!=1||pequ0.terms[0].var_b!=-1:pequ0=equMakeVar(pequ0)
						assert(pequ0.terms.n==1&&pequ0.terms[0].var_b==-1)
						pequ0.terms[0].var_b=evid_original
						pequ0.terms.push(TQuadTerm(){'var_a':-1,'var_b':-1,'const_id':1})
						if DEBUG_DUMP_DERIV:
							Writeln('x',ret,' for equation: ',dumpEquation(pequ0),' (rcp(pow(x',evid_original,',1/',System.Math.abs(inv_power),')))')
							Writeln('    level 0: ',dumpExpr(pe_root,NULL))
						addEquation(pequ0)
					else
						//-evid_original
						pequ0.terms.push(TQuadTerm(){'var_a':evid_original,'var_b':-1,'const_id':1})
						if DEBUG_DUMP_DERIV:
							Writeln('x',ret,' for equation: ',dumpEquation(pequ0),' pow(x',evid_original,',1/',System.Math.abs(inv_power),')')
							Writeln('    level 0: ',dumpExpr(pe_root,NULL))
						addEquation(pequ0)
			if DEBUG_DUMP_DERIV:
				Writeln('x',ret,' <- ',dumpObject(pvar),' ',inv_power)
			return ret
		auto equMakeVar(CEquationTerm pequ)
			ret=int(evid_realvar.n)
			pvar_new=makevar(pobjfn_dup)
			evid_realvar.push(pvar_new)
			as_cstores.push(call(g_id_store,exprvar(pvar_new),pequ.pe))
			pequ.terms.push(TQuadTerm(){'var_a':ret,'var_b':-1,'const_id':1})
			if DEBUG_DUMP_DERIV:
				Writeln('x',ret,' for equation: ',dumpEquation(pequ),' makevar')
				Writeln('    level 0: ',dumpExpr(pequ.pe,NULL))
			addEquation(pequ)
			pequ2=new CEquationTerm
			pequ2.terms=[TQuadTerm(){'var_a':ret,'var_b':-1,'const_id':0}]
			pequ2.pe=exprvar(pvar_new)
			auto key=((i64(pvar_new)<<32)|1LL)
			evid_map[key]=ret+1
			return pequ2
		errored=0
		auto generateEquations(PExpression pe)
			if isExpr(pe,EFLAG_FCALL):
				val=getExprValue(pe)
				if val.tid==g_vtid_CNS:
					pequ=new CEquationTerm
					pequ.terms=[TQuadTerm(){'var_a':-1,'var_b':-1,'const_id':cnsVariableId(val.val,1,0,0)}]
					pequ.pe=exprcns(val.val)
					return pequ
				if isBuiltin(pe,g_id_block)||isBuiltin(pe,g_id_blockex):
					n_args=getFCallNArgs(pe)
					for i=0:n_args-1
						generateEquations(readPool(pe+EXPR_OFS_ARGS+i))
					return NULL
				else if isBuiltin(pe,g_id_if):
					n_args_if=getFCallNArgs(pe)
					for i=1:2:n_args_if-1
						pe_branch=readPool(pe+EXPR_OFS_ARGS+i)
						if testUserFlag(pe_branch,QUEUE_FLAG_REACH):
							generateEquations(pe_branch)
				else if isBuiltin(pe,g_id_nop)||isBuiltin(pe,g_id_assert_ctval)||isBuiltin(pe,g_id_function):
					return NULL
				else if isBuiltin(pe,g_id_store):
					pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
					assert(!!pobj_var)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					if isExpr(pe_value,EFLAG_CTVAL)||isExpr(pe_value,EFLAG_STRING):
						//ignore _deriv artifacts
						setnop(pe)
						return NULL
					//if readPool(pe)==EFLAG_FCALL+3:
					//	Writeln('shit! ',dumpExpr(pe,NULL),' ',readPool(pe_value))
					//	//assert(0)
					if !testUserFlag(pobj_var,FLAG_RELATED)||!testUserFlag(pobj_var,FLAG_REQUIRED):
						//unrelated store - keep it as is
						as_cstores.push(pe)
						//setnop(pe)
						return NULL
					if isBuiltin(pe_value,g_id_ldparam):
						//we still need them - order 0
						as_cstores.push(pe)
						//setnop(pe)
						return NULL
					//it's an equation
					pequ=generateEquations(pe_value)
					if !pequ:
						//somehow we ignored it, keep around for safety
						as_cstores.push(pe)
						return NULL
					assert(!!pequ)
					//add a -1*term, then apply the equation
					as_cstores.push(call(g_id_store,exprvar(pobj_var),pequ.pe))
					pequ.terms.push(TQuadTerm(){'var_a':equVariableId(pobj_var,1),'var_b':-1,'const_id':1})
					if DEBUG_DUMP_DERIV:
						Writeln('x',equVariableId(pobj_var,1),' for equation: ',dumpEquation(pequ),' ',dumpExpr(pe,NULL))
						Writeln('    level 0: ',dumpExpr(pequ.pe,NULL))
					addEquation(pequ)
					return NULL
				else if !testUserFlag(pe,FLAG_RELATED)||!testUserFlag(pe,FLAG_REQUIRED):
					//var it
					if isBuiltin(pe,g_id_stdot):
						assert(isExpr(readPool(pe+EXPR_OFS_ARGS+0),EFLAG_VARIABLE)&&getVariable(readPool(pe+EXPR_OFS_ARGS+0))==readPool(pobjfn_dup+FUNCTION_OFS_PVAR_RETURN))
						setnop(pe)
						return NULL
					if isBuiltin(pe,g_id_dot):
						peobj=readPool(pe+EXPR_OFS_ARGS+0)
						if isExpr(peobj,EFLAG_VARIABLE):
							//for valid unrelated dots, we won't even reach here
							//if testUserFlag(getVariable(peobj),VAR_FLAG_PARAM):
							//we could have flattened 2nd-order loads
							//param member load - ignore it since the value won't be used at all
							//it would be used in order 0
							//setnop(pe)
							return NULL
					if Platform.BUILD=="debug":
						if isSpecial(pe)&&!isArithmetic(pe):
							Writeln('bad-unrelated: ',dumpExpr(pe,NULL))
						if DEBUG_DUMP_DERIV:
							Writeln('unrelated: ',dumpExpr(pe,NULL))
					if isBuiltin(readPool(pe+EXPR_OFS_CALLER),g_id_block):
						//the shit isn't even stored, don't bother
						return NULL
					pequ=new CEquationTerm
					pv_temp=makevar(pobjfn_dup)
					as_cstores.push(call(g_id_store,exprvar(pv_temp),pe))
					pequ.terms=[TQuadTerm(){'var_a':-1,'var_b':-1,'const_id':cnsVariableId(pv_temp,0,0,0)}]
					pequ.pe=exprvar(pv_temp)
					return pequ
				else if isBuiltin(pe,g_id_operator_add)||isBuiltin(pe,g_id_operator_sub):
					assert(readPool(pe)==EFLAG_FCALL+2)
					pequ0=generateEquations(readPool(pe+EXPR_OFS_ARGS+0))
					pequ1=generateEquations(readPool(pe+EXPR_OFS_ARGS+1))
					if isBuiltin(pe,g_id_operator_add):
						pequ0.terms.push(pequ1.terms)
						pequ0.pe=call(g_id_operator_add,pequ0.pe,pequ1.pe)
					else
						foreach et in pequ1.terms
							et2=et
							et2.const_id=cnsNeg(et2.const_id)
							pequ0.terms.push(et2)
						pequ0.pe=call(g_id_operator_sub,pequ0.pe,pequ1.pe)
					return pequ0
				else if isBuiltin(pe,g_id_operator_neg):
					//just negate all the cnses
					pequ0=generateEquations(readPool(pe+EXPR_OFS_ARGS+0))
					foreach et,J in pequ0.terms
						et2=et
						et2.const_id=cnsNeg(et2.const_id)
						pequ0.terms[J]=et2
					pequ0.pe=pe
					return pequ0
				else if isBuiltin(pe,g_id_operator_mul):
					assert(readPool(pe)==EFLAG_FCALL+2)
					pequ0=generateEquations(readPool(pe+EXPR_OFS_ARGS+0))
					pequ1=generateEquations(readPool(pe+EXPR_OFS_ARGS+1))
					if pequ0.terms.n!=1||pequ0.terms[0].var_b!=-1:pequ0=equMakeVar(pequ0)
					if pequ1.terms.n!=1||pequ1.terms[0].var_b!=-1:pequ1=equMakeVar(pequ1)
					assert(pequ0.terms.n==1&&pequ0.terms[0].var_b==-1)
					assert(pequ1.terms.n==1&&pequ1.terms[0].var_b==-1)
					pequ0.terms[0].var_b=pequ1.terms[0].var_a
					if !pequ1.terms[0].const_id:
						//nothing
					else if !pequ0.terms[0].const_id:
						pequ0.terms[0].const_id=pequ1.terms[0].const_id
					else
						pequ0.terms[0].const_id=cnsMul(pequ0.terms[0].const_id,pequ1.terms[0].const_id)
					pequ0.pe=call(g_id_operator_mul,pequ0.pe,pequ1.pe)
					return pequ0
				else if isBuiltin(pe,g_id_operator_div):
					assert(readPool(pe)==EFLAG_FCALL+2)
					pequ0=generateEquations(readPool(pe+EXPR_OFS_ARGS+0))
					pequ1=generateEquations(readPool(pe+EXPR_OFS_ARGS+1))
					if pequ1.terms.n!=1||pequ1.terms[0].var_b!=-1:pequ1=equMakeVar(pequ1)
					assert(pequ1.terms.n==1&&pequ1.terms[0].var_b==-1)
					ec=pequ1.terms[0]
					if ec.var_a!=-1:
						ec.var_a=equVariableId(evid_realvar[ec.var_a],-1)
					if ec.const_id!=0&&ec.const_id!=1:
						ec.const_id=cnsRcp(ec.const_id)
					if pequ0.terms.n!=1||pequ0.terms[0].var_b!=-1:pequ0=equMakeVar(pequ0)
					assert(pequ0.terms.n==1&&pequ0.terms[0].var_b==-1)
					pequ0.terms[0].var_b=ec.var_a
					if !ec.const_id:
						//nothing
					else if !pequ0.terms[0].const_id:
						pequ0.terms[0].const_id=ec.const_id
					else
						pequ0.terms[0].const_id=cnsMul(pequ0.terms[0].const_id,ec.const_id)
					pequ0.pe=call(g_id_operator_div,pequ0.pe,pequ1.pe)
					return pequ0
				else
					pobjfn=getExprFunction(pe)
					id_fname=readPool(pobjfn+FUNCTION_OFS_NAME)
					if id_fname==g_id_powd&&readPool(pe)==EFLAG_FCALL+2:
						//it's pow
						val_power=getExprValue(readPool(pe+EXPR_OFS_ARGS+1))
						if val_power.tid!=g_vtid_CNS:
							errorAtExpr(ETYPE_ERROR,readPool(pe+EXPR_OFS_ARGS+1),"'@1' is not a constant, only rational constant powers are allowed in an ANM-decomposed function".Replace(["@1",citeexpr(readPool(pe+EXPR_OFS_ARGS+1))]))
							errored=1
							return NULL
						dval_power=castConst(Util.ctNumber(val_power.val),getBuiltinType(const_type(CTYPE_FLOAT,64)))
						dpower=__longlong_as_double(dval_power.val_bin)
						if abs(dpower)<1e-7:
							errorAtExpr(ETYPE_ERROR,pe,"panic: we should have optimized out this - 'powd(something,0.0)'")
							errored=1
							return NULL
						A=0
						B=0
						for Bi=1:99
							Ad=dpower*double(Bi)
							Ai=floor(Ad+0.5)
							if abs(Ad-Ai)<1e-7:
								A=int(Ai)
								B=Bi
								break
						if !B:
							errorAtExpr(ETYPE_ERROR,readPool(pe+EXPR_OFS_ARGS+1),"'@1' is not rational (tried a divisor of 1-99), only rational constant powers are allowed in an ANM-decomposed function".Replace(["@1",citeexpr(readPool(pe+EXPR_OFS_ARGS+1))]))
							errored=1
							return NULL
						if A<0:
							A=-A
							B=-B
						///////////////
						pequ0=generateEquations(readPool(pe+EXPR_OFS_ARGS+0))
						if pequ0.terms.n!=1||pequ0.terms[0].var_b!=-1:pequ0=equMakeVar(pequ0)
						assert(pequ0.terms.n==1&&pequ0.terms[0].var_b==-1)
						assert(pequ0.terms[0].var_a!=-1)
						evid_root=equVariableId(evid_realvar[pequ0.terms[0].var_a],B)
						return equPowerTo(evid_root,A)
					errorAtExpr(ETYPE_ERROR,pe,"unsupported operation '@1' in ANM code".Replace(["@1",citeexpr(pe)]))
					if Platform.BUILD=="debug":
						Writeln('bad-related: ',dumpExpr(pe,NULL))
						assert(0)
			else if isExpr(pe,EFLAG_VARIABLE):
				pobj_var=getVariable(pe)
				pequ=new CEquationTerm
				if testUserFlag(pobj_var,FLAG_RELATED)&&testUserFlag(pobj_var,FLAG_REQUIRED):
					pequ.terms=[TQuadTerm(){'var_a':equVariableId(pobj_var,1),'var_b':-1,'const_id':0}]
				else
					if DEBUG_DUMP_DERIV:
						Writeln('var-unrelated: ',dumpExpr(pe,NULL))
					pequ.terms=[TQuadTerm(){'var_a':-1,'var_b':-1,'const_id':cnsVariableId(pobj_var,0,0,0)}]
				pequ.pe=exprvar(pobj_var)
				return pequ
			else if isExpr(pe,EFLAG_CONST):
				if DEBUG_DUMP_DERIV:
					Writeln('const-unrelated: ',dumpExpr(pe,NULL))
				cid=readPool(pe)&~EFLAG_MASK
				pequ=new CEquationTerm
				pequ.terms=[TQuadTerm(){'var_a':-1,'var_b':-1,'const_id':cnsVariableId(cid,1,0,0)}]
				pequ.pe=exprcns(cid)
				return pequ
			else
				//if Platform.BUILD=="debug":
				//	Writeln('unrecognized thingy: ',dumpExpr(pe,NULL))
				return NULL
			return NULL
		evid_params=new int[var_list_params.n]
		foreach pobj_var,J in var_list_params
			evid_params[J]=equVariableId(pobj_var,1)
		if DEBUG_DUMP_DERIV:
			Writeln('before generateEquations:\n=======================\n',dumpExpr(code,NULL))
		generateEquations(code)
		if errored:
			setnop(pecall)
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		evid_ret=new int[var_list_ret.n]
		foreach pobj_var,J in var_list_ret
			evid_ret[J]=equVariableId(pobj_var,1)
		//generate the consts, replace the original code
		//alloc pv_const_array and return it
		//also store order 0 to the same array
		pobjfn_array=getStdObject(pecall,STDTYPE_ARRAY)
		as_cstores[0]=(call(g_id_store,exprvar(pv_const_array),indcall([indcall([exprctval(pobjfn_array),exprctval(getBuiltinType(const_type(CTYPE_FLOAT,64)))])])))
		as_cstores[1]=(indcall([call(g_id_dot,exprvar(pv_const_array),exprstr(g_id_init)),expriptr(consts.n+evid_realvar.n),exprcns(getid_const(const_type(CTYPE_INT,16),0LL))]))
		foreach pobj_var,J in evid_realvar
			as_cstores.push(indcall([call(g_id_dot,exprvar(pv_const_array),exprstr(g_id_set_operator_bracket)),expriptr(consts.n+J),exprvar(pobj_var)]))
		pe_code_new=vcall(g_id_block,as_cstores)
		//clearUserFlags(code,0)
		pe_decl=readPool(pobjfn_dup+FUNCTION_OFS_PEDECL)
		n_args_decl=getFCallNArgs(pe_decl)
		sccpQueueReach(insertCallAt(pe_decl,~(n_args_decl-1),function(PExpression pe){return pe_code_new}))
		writePool(pobjfn_dup+FUNCTION_OFS_CODE,pe_code_new)
		writePool(pobjfn_dup+FUNCTION_OFS_PVAR_RETURN,pv_const_array)
		writePool(pv_const_array+VAR_OFS_ID,g_id_return)
		//Writeln('shit:')
		//Writeln(dumpExpr(g_pe_top,NULL))
		//assert(0)
		//generate equations as a packed int array, and pass to external equation generator / interpreter - could use the "__C(@decl)" approach
		//__C(@decl) generator function
		pe_const_evid=expr_C_const(evid_ret[0:].ConvertToAsBinary(char))
		pe_const_evid_params=expr_C_const(evid_params[0:].ConvertToAsBinary(char))
		buf_terms=new int[]
		buf_pequ=new int[]
		foreach pequ in all_equations
			buf_pequ.push(int(buf_terms.n))
			foreach et in pequ.terms
				buf_terms.push(et.var_a)
				buf_terms.push(et.var_b)
				buf_terms.push(et.const_id)
		buf_pequ.push(int(buf_terms.n))
		pe_const_terms=expr_C_const(buf_terms[0:].ConvertToAsBinary(char))
		pe_const_pequ=expr_C_const(buf_pequ[0:].ConvertToAsBinary(char))
		//translate pecall - make a tuple object
		//the counts...
		pobjfn_ANM_decomposed_result=readCtUniqueInEvalFlow(pecall,[g_id_meta_state,getid("__ANM_decomposed_result")])
		assert(!!pobjfn_ANM_decomposed_result)
		//Writeln(buf_terms)
		//Writeln(buf_pequ)
		//Writeln(evid_ret)
		replaceExpr(pecall,indcall([exprctval(pobjfn_ANM_decomposed_result),
			pe_const_terms,expriptr(buf_terms.n),
			pe_const_pequ,expriptr(buf_pequ.n),
			pe_const_evid,expriptr(evid_ret.n),
			pe_const_evid_params,expriptr(evid_params.n),
			expriptr(consts.n),expriptr(evid_realvar.n),
			exprctval(pobjfn_dup)]))
		writePool(pobjfn_dup+FUNCTION_OFS_FLAGS,(readPool(pobjfn_dup+FUNCTION_OFS_FLAGS)&~FFLAG_IS_SYMDERIV_TEMP)|FFLAG_IS_SYMDERIV)
		if DEBUG_DUMP_DERIV:
			Writeln('=========ANM decomposed')
			Writeln(dumpExpr(pe_code_new,NULL))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_ANM_decompose,fANMdecompose_onreach,fANMdecompose_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL|FFLAG_DEPENDS_ON_OTHER_CODE)
	}
	//////////////////////////////////////
	//operator overloading
	auto enableOverloading(int id_opr)
		fadd_overload_oneval=function(PExpression pecall,int expr_oplevel){
			n_args=getFCallNArgs(pecall)
			pe_fn=readPool(pecall+EXPR_OFS_ARGS+n_args-1)
			pobjfn=getExprValueAs(pe_fn,g_vtid_CTVAL)
			if !pobjfn||!readPool(pobjfn+FUNCTION_OFS_ONEVAL):return TSCCPValue(){'tid':g_vtid_UNINIT}
			ts=new PCTObject[n_args]
			ts[0]=id_opr
			is_valid=0
			for i=0:n_args-2
				pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
				t=getExprValueAs(pe_argi,g_vtid_CTVAL)
				if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
				if tisclass(t)&&!tisfunction(t):is_valid=1
				ts[i+1]=t
			if !is_valid:
				errorAtExpr(ETYPE_ERROR,pecall,"overloaded operator '@1' is invalid - there must be at least one object-typed operand".Replace(["@1",citeexpr(pecall)]))
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			writePool(pobjfn+FUNCTION_OFS_NAME,id_opr)
			writeCtUniqueInEvalFlow(ts,pobjfn)
			replaceExpr(pecall,pe_fn)
			setnop(pecall)
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),1LL)}
		}
		registerPrimitive(catid(g_id_set_,id_opr),fcompiler_callback.NULL,fadd_overload_oneval,fcompiler_callback.NULL,FFLAG_SPECIAL)
	auto checkOverload(int id_opr,PExpression pecall)
		n_args=getFCallNArgs(pecall)
		need_check=0
		all_cns=1
		for i=0:n_args-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			val=getExprValue(pe_argi)
			if val.tid==g_vtid_RTVAR:
				all_cns=0
			//Writeln(i,' ',dumpExpr(pe_argi,NULL))
			t=getExprType(pe_argi)
			if !t:return 0
			if tisclass(t)&&!tisfunction(t):
				need_check=1
		if !need_check||all_cns:return 0
		ts=new PCTObject[n_args+1]
		ts[0]=id_opr
		for i=0:n_args-1
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			t=getExprType(pe_argi)
			ts[i+1]=t
		pobjfn=readCtUniqueInEvalFlow(pecall,ts)
		if pobjfn:
			insertCallAt(pecall,0,function(){return exprctval(pobjfn)})
			sccpQueueEval(pecall)
		return 1
	//////////////////////////////////////
	//the special operators
	//2: undetermined
	auto evaluateAsLogic(TSCCPValue val_a){
		if val_a.tid==g_vtid_CNS:
			return !isValueZero(val_a)
		else if val_a.tid==g_vtid_STR||val_a.tid==g_vtid_CTVAL:
			return 1
		return 2
	}
	flogicnot_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		val_a=getExprValue(readPool(pecall+EXPR_OFS_ARGS+0))
		if val_a.tid==g_vtid_UNINIT:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		logic_val=evaluateAsLogic(val_a)
		if logic_val==2:
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':getBuiltinType(const_type(CTYPE_INT,32))}
		else
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),(i64)!logic_val)}
	}
	flogicnot_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('!')
		genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_PREFIX)
		if need_bracket:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_operator_logic_not,fcompiler_callback.NULL,flogicnot_oneval,flogicnot_oncgen,FFLAG_ARITHMETIC|FFLAG_IS_PURE)
	fbitnot_oneval=function(PExpression pecall,int expr_oplevel){
		if checkOverload(g_id_operator_bit_not,pecall):
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		val_a=getExprValue(readPool(pecall+EXPR_OFS_ARGS+0))
		if val_a.tid==g_vtid_CNS:
			ca=Util.ctNumber(val_a.val)
			ta=getBuiltinType(ca.type)
			if (ca.type&CTYPE_MASK)!=CTYPE_INT:
				errorAtExpr(ETYPE_ERROR,pecall,"invalid operation ~@1 in expression '@2': the operator can only be applied to integers".Replace([
					"@1",dumpType(ta),
					"@2",citeexpr(pecall)]))
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ca.type,~ca.val_bin)}
		t=getValueType(val_a)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		if !tisbuiltin(t)||(readPool(t+1)&CTYPE_MASK)!=CTYPE_INT&&(readPool(t+1)&CTYPE_MASK)!=CTYPE_UINT:
			errorAtExpr(ETYPE_ERROR,pecall,"invalid operation ~@1 in expression '@2': the operator can only be applied to integers".Replace([
				"@1",dumpType(ta),
				"@2",citeexpr(pecall)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fbitnot_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		pe_argi=readPool(pecall+EXPR_OFS_ARGS+0)
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('~')
		genCode(pe_argi,LEVEL_PREFIX)
		if need_bracket:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_operator_bit_not,fcompiler_callback.NULL,fbitnot_oneval,fbitnot_oncgen,FFLAG_ARITHMETIC|FFLAG_IS_PURE)
	enableOverloading(g_id_operator_bit_not)
	fnegation_oneval=function(PExpression pecall,int expr_oplevel){
		if checkOverload(g_id_operator_neg,pecall):
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		val_a=getExprValue(readPool(pecall+EXPR_OFS_ARGS+0))
		if val_a.tid==g_vtid_CNS:
			ca=Util.ctNumber(val_a.val)
			ct_result=ca.type
			if ct_result==const_type(CTYPE_FLOAT,32):
				ca.val_bin^=0x80000000L
			else if ct_result==const_type(CTYPE_FLOAT,64):
				ca.val_bin^=0x8000000000000000LL
			else
				ca.val_bin=-ca.val_bin
			return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ca.type,ca.val_bin)}
		t=getValueType(val_a)
		if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
		if tisbuiltin(t):
			ct=readPool(t+1)
		else
			ct=CTYPE_INVALID
		if !tisbuiltin(t)||(ct&CTYPE_MASK)!=CTYPE_INT&&(ct&CTYPE_MASK)!=CTYPE_UINT&&(ct&CTYPE_MASK)!=CTYPE_FLOAT:
			errorAtExpr(ETYPE_ERROR,pecall,"invalid operation -@1 in expression '@2': only numbers can be negated".Replace([
				"@1",dumpType(t),
				"@2",citeexpr(pecall)]))
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fnegation_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		assert(n_args==1)
		pe_argi=readPool(pecall+EXPR_OFS_ARGS+0)
		need_bracket=0
		if expr_oplevel&&expr_oplevel<LEVEL_PREFIX:
			need_bracket=1
			g_code_buffer.push('(')
		g_code_buffer.push('-')
		genCode(pe_argi,LEVEL_PREFIX)
		if need_bracket:
			g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_operator_neg,fcompiler_callback.NULL,fnegation_oneval,fnegation_oncgen,FFLAG_ARITHMETIC|FFLAG_IS_PURE)
	enableOverloading(g_id_operator_neg)
	//////
	fadd_gen_int_oneval=function(PExpression pecall,int expr_oplevel){
		if checkOverload(g_id_operator_add_generic_int,pecall):
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		n_args=getFCallNArgs(pecall)
		assert(n_args==2)
		pe_opr0=readPool(pecall+EXPR_OFS_ARGS+0)
		pe_opr1=readPool(pecall+EXPR_OFS_ARGS+1)
		assert(isExpr(pe_opr1,EFLAG_CONST))
		t=getExprType(pe_opr0)
		if t:
			//cast and switch to operator+ once we get the type
			sccpQueueReach(insertCallAt(pecall,~1,function(){return call(g_id_cast,exprctval(t),pe_opr1)}))
			sccpQueueReach(insertCallAt(pecall,0,function(){return exprctval(getBuiltin(g_id_operator_add))}))
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_operator_add_generic_int,fcompiler_callback.NULL,fadd_gen_int_oneval,fcompiler_callback.NULL,FFLAG_ARITHMETIC|FFLAG_IS_PURE)
	enableOverloading(g_id_operator_add_generic_int)
	//////////////////////////////////////
	//raw C
	fcwrap_oneval=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args<2:
			errorAtExpr(ETYPE_ERROR,pecall,"__C(type,'code',...) takes at least 2 arguments")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_type=readPool(pecall+EXPR_OFS_ARGS+0)
		t=getExprValueAs(pe_type,g_vtid_CTVAL)
		if !t:
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		else
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t}
	}
	fcwrap_oncgen=function(PExpression pecall,int expr_oplevel){
		n_args=getFCallNArgs(pecall)
		if n_args<2:return TSCCPValue(){'tid':g_vtid_UNINIT}
		pe_stemplate=readPool(pecall+EXPR_OFS_ARGS+1)
		id_stemplate=getExprValueAs(pe_stemplate,g_vtid_STR)
		if !id_stemplate:
			errorAtExpr(ETYPE_ERROR,pe_stemplate,"__C(type,'code',...) must have a string for code")
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		stemplate=new(getIdString(id_stemplate))
		replace_args=new string[]
		sbk=g_code_buffer
		for i=2:n_args-1
			g_code_buffer=new string
			pe_argi=readPool(pecall+EXPR_OFS_ARGS+i)
			val=getExprValue(pe_argi)
			if val.tid==g_vtid_CTVAL:
				//hack for func
				pe_argi=exprctval(val.val)
			genCode(pe_argi,LEVEL_POSTFIX)
			replace_args.push("@"+toBase32(i-1))
			replace_args.push(g_code_buffer)
		g_code_buffer=sbk
		if replace_args.n:
			stemplate=stemplate.Replace(replace_args)
		if stemplate.StartsWith("@global:"):
			if expr_oplevel:
				errorAtExpr(ETYPE_ERROR,pecall,'"@global:..." C code cannot be used in expressions')
			g_c_global_buffer.push(stemplate[8:])
		else if stemplate.StartsWith("@decl:"):
			//declare a struct and obtain a pointer
			sdecl=g_c_scope_stack.back().outer_code_buffer
			sdecl.push(stemplate[6:].Replace("@1",'s7_v'+toBase32(pecall)))
			sdecl.push(';')
			if expr_oplevel:
				g_code_buffer.push('(')
			g_code_buffer.push('(void*)&s7_v')
			g_code_buffer.push(toBase32(pecall))
			if expr_oplevel:
				g_code_buffer.push(')')
		else if stemplate.StartsWith("@raw:"):
			//internal const
			g_c_global_buffer.push(stemplate[5:])
			vid=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+2),g_vtid_CNS)
			g_code_buffer.push('s7_CD')
			g_code_buffer.push(toBase32(vid))
		else
			if expr_oplevel:
				g_code_buffer.push('(')
			g_code_buffer.push(stemplate)
			if expr_oplevel:
				g_code_buffer.push(')')
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_C_wrap,fcompiler_callback.NULL,fcwrap_oneval,fcwrap_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	registerPrimitive(g_id_C_wrap_pure,fcompiler_callback.NULL,fcwrap_oneval,fcwrap_oncgen,FFLAG_SPECIAL|FFLAG_IS_PURE)
	//////////////////////////////////////
	//debug
	fcallstack_oncgen=function(PExpression pecall,int expr_oplevel){
		assert(g_enable_debug_instrumentation)
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		if pobjfn:
			//use a local variable to maintain that... ->dad at pop
			g_code_buffer.push("spapPushCallStack(&s7_Dd)")
			g_code_buffer.push(';')
			genLineInfoExpr(pecall)
			g_c_scope_stack.back().dbg_slots.push(pecall)
		else
			g_code_buffer.push("spapPopCallStack();")
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_callstack,fcompiler_callback.NULL,fcompiler_callback.NULL,fcallstack_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	fset_callstack_oncgen=function(PExpression pecall,int expr_oplevel){
		genLineInfoExpr(pecall)
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	}
	registerPrimitive(g_id_set_callstack,fcompiler_callback.NULL,fcompiler_callback.NULL,fset_callstack_oncgen,FFLAG_SPECIAL|FFLAG_IS_PRELIVE)
	//////////////////////////////////////
	//the operators: promote both sides, grand switch, do the op
	inline CreateArithOperator(string opname,char optoken,int level,const fop,const IS_INT_ONLY,const IS_CMP)
		id_opr=getid("operator"+string(opname))
		auto fop_oneval=function(PExpression pecall,int expr_oplevel){
			if checkOverload(id_opr,pecall):
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			n_args=getFCallNArgs(pecall)
			if n_args!=2:
				/*
				if optoken=='-'&&n_args==1:
					//translate into 0-
					pe_opr=readPool(pecall+EXPR_OFS_ARGS+0)
					t=getExprType(pe_opr)
					if !t:return TSCCPValue(){'tid':g_vtid_UNINIT}
					pe_neg_impl=indcall([readPool(pecall+EXPR_OFS_FUNCTION),call(g_id_cast,exprctval(t),expriptr(0)),pe_opr])
					pecaller=readPool(pecall+EXPR_OFS_CALLER)
					sccpQueueReach(insertCallAt(pecaller,pecall,function(){return pe_neg_impl}))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				*/
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			pe_opr_a=readPool(pecall+EXPR_OFS_ARGS+0);val_a=getExprValue(pe_opr_a)
			pe_opr_b=readPool(pecall+EXPR_OFS_ARGS+1);val_b=getExprValue(pe_opr_b)
			if optoken=='|':
				if val_a.tid==g_vtid_CTVAL&&val_b.tid==g_vtid_CTVAL:
					pobjfn_a=val_a.val
					pobjfn_b=val_b.val
					if readPool(pobjfn_a)==g_tid_TFunction&&readPool(pobjfn_b)==g_tid_TFunction:
						pobjfn_fn_or=getStdObject(pecall,STDFN_FUNCTIONAL_OR)
						if !pobjfn_fn_or:
							return TSCCPValue(){'tid':g_vtid_UNINIT}
						//just replace the op
						insertCallAt(pecall,0,function(){return exprctval(pobjfn_fn_or)})
						sccpQueueEval(pecall)
						return TSCCPValue(){'tid':g_vtid_UNINIT}
			if val_a.tid==g_vtid_CNS&&val_b.tid==g_vtid_CNS:
				//promoting add
				ca=Util.ctNumber(val_a.val)
				cb=Util.ctNumber(val_b.val)
				ta=getBuiltinType(ca.type)
				tb=getBuiltinType(cb.type)
				if optoken==TOK_LL||optoken==TOK_GG:
					//shift operators - tb should be i32
					if cb.type!=const_type(CTYPE_INT,32)&&cb.type!=const_type(CTYPE_INT,64):
						errorAtExpr(ETYPE_ERROR,pecall,"the bit count '@1' in shift operation '@2' can only be a 32/64-bit integer, not of type '@3'".Replace([
							"@1",citeexpr(readPool(pecall+EXPR_OFS_ARGS+1)),
							"@2",citeexpr(pecall),
							"@3",dumpType(tb)
						]))
						return TSCCPValue(){'tid':g_vtid_UNINIT}
					t_result=ta
				else
					t_result=typeMerge(pecall,ta,tb,pe_opr_a,pe_opr_b,1)
				if !t_result:
					//Writeln(dumpExpr(pecall,fcolor_abbrv_blocks))
					errorAtExpr(ETYPE_ERROR,pecall,"invalid operation @1 in expression '@2'".Replace([
						"@1",dumpType(ta)+string(opname)+dumpType(tb),
						"@2",citeexpr(pecall)
					]))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				//if !tisbuiltin(t_result):
				//	Writeln(dumpExpr(pecall,function(){return -1}))
				//	Writeln(ca.type,' ',cb.type,' ',ta,' ',tb,' ',t_result)
				ca=castConst(ca,t_result)
				cb=castConst(cb,t_result)
				ct_result=readPool(t_result+1)
				if IS_CMP:
					ca.type=const_type(CTYPE_INT,32)
					if ct_result==const_type(CTYPE_FLOAT,32):
						ca.val_bin=i64(u32(fop(__int_as_float(int(ca.val_bin)),__int_as_float(int(cb.val_bin)))))
					else if ct_result==const_type(CTYPE_FLOAT,64):
						ca.val_bin=i64(fop(__longlong_as_double(ca.val_bin),__longlong_as_double(cb.val_bin)))
				else if IS_INT_ONLY:
					if (ct_result&CTYPE_MASK)!=CTYPE_INT&&(ct_result&CTYPE_MASK)!=CTYPE_UINT:
						errorAtExpr(ETYPE_ERROR,pecall,"invalid operation @1 in expression '@2': the operator can only be applied to integers".Replace([
							"@1",dumpType(ta)+string(opname)+dumpType(tb),
							"@2",citeexpr(pecall)
						]))
						return TSCCPValue(){'tid':g_vtid_UNINIT}
				else
					if ct_result==const_type(CTYPE_FLOAT,32):
						ca.val_bin=i64(u32(__float_as_int(fop(__int_as_float(int(ca.val_bin)),__int_as_float(int(cb.val_bin))))))
					else if ct_result==const_type(CTYPE_FLOAT,64):
						ca.val_bin=__double_as_longlong(fop(__longlong_as_double(ca.val_bin),__longlong_as_double(cb.val_bin)))
				skip_eval=0
				if (ct_result&CTYPE_MASK)!=CTYPE_FLOAT:
					//-8000000000000000LL/-1LL case: just return -8000000000000000LL
					if optoken=='/':
						if ca.val_bin==0x8000000000000000LL&&cb.val_bin==-1LL:
							//nothing, the result is still 0x8000000000000000
							skip_eval=1
						else if isConstZero(cb):
							//don't even eval
							skip_eval=2
					if !skip_eval:
						if (ct_result&CTYPE_MASK)==CTYPE_INT:
							ca.val_bin=i64(fop(ca.val_bin,cb.val_bin))
						else
							ca.val_bin=i64(fop(u64(ca.val_bin),u64(cb.val_bin)))
				if skip_eval!=2:
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ca.type,ca.val_bin)}
			if optoken=='+':
				if val_a.tid==g_vtid_STR&&val_b.tid==g_vtid_STR:
					//const string concatenation
					return TSCCPValue(){'tid':g_vtid_STR,'val':catid(val_a.val,val_b.val)}
			if IS_CMP:
				if val_a.tid==g_vtid_STR&&val_b.tid==g_vtid_STR:
					//const string comparison
					cmp_result=i64(fop(getIdString(val_a.val),getIdString(val_b.val)))
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),cmp_result)}
				// < and stuff are needed for __compare
				if val_a.tid==g_vtid_CTVAL&&val_b.tid==g_vtid_CTVAL://&&(optoken==TOK_EQ||optoken==TOK_NE):
					cmp_result=i64(fop(val_a.val,val_b.val))
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(const_type(CTYPE_INT,32),cmp_result)}
			ta=getValueType(val_a)
			tb=getValueType(val_b)
			//type deduction
			if optoken==TOK_LL||optoken==TOK_GG:
				//shift operators - tb should be i32
				if tb!=getBuiltinType(const_type(CTYPE_INT,32))&&tb!=getBuiltinType(const_type(CTYPE_INT,64)):
					if tb:
						errorAtExpr(ETYPE_ERROR,pecall,"the bit count '@1' in shift operation '@2' can only be a 32/64-bit integer, not of type '@3'".Replace([
							"@1",citeexpr(readPool(pecall+EXPR_OFS_ARGS+1)),
							"@2",citeexpr(pecall),
							"@3",dumpType(tb)
						]))
					return TSCCPValue(){'tid':g_vtid_UNINIT}
				t_result=ta
			else
				t_result=typeMerge(pecall,ta,tb,pe_opr_a,pe_opr_b,1)
			//Writeln(parser.Canonical.dumpExpr(pecall,function(){return -1}))
			//Writeln(dumpType(ta),' ',dumpType(tb))
			if !t_result:
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			if optoken=='*'||optoken=='&':
				//*0, &0 shortcircuiting
				if (isValueZero(val_a)||isValueZero(val_b))&&tisbuiltin(t_result):
					ct_result=readPool(t_result+1)
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ct_result,0LL)}
			if optoken=='/':
				//0/ shortcircuiting
				if isValueZero(val_a)&&tisbuiltin(t_result):
					ct_result=readPool(t_result+1)
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ct_result,0LL)}
			if optoken=='%':
				//%1 shortcircuiting
				if isValueOne(val_b)&&tisbuiltin(t_result):
					ct_result=readPool(t_result+1)
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ct_result,0LL)}
			if optoken=='|':
				//|-1 shortcircuiting
				if (isValueNegOne(val_a)||isValueNegOne(val_b))&&tisbuiltin(t_result):
					ct_result=readPool(t_result+1)
					return TSCCPValue(){'tid':g_vtid_CNS,'val':getid_const(ct_result,-1LL)}
			if IS_CMP:
				t_result=getBuiltinType(const_type(CTYPE_INT,32))
			return TSCCPValue(){'tid':g_vtid_RTVAR,'val':t_result}
		}
		auto fop_oncgen=function(PExpression pecall,int outer_level){
			if checkOverload(id_opr,pecall):
				ta=getExprType(readPool(pecall+EXPR_OFS_ARGS+0))
				tb=getExprType(readPool(pecall+EXPR_OFS_ARGS+1))
				errorAtExpr(ETYPE_ERROR,pecall,"unresolved operator @1 in '@2'".Replace([
					"@1",dumpType(ta)+string(opname)+dumpType(tb),
					"@2",citeexpr(pecall)]))
			n_args=getFCallNArgs(pecall)
			if n_args==1:
				//unary case
				if outer_level&&outer_level<=level:
					got_bracket=1
					g_code_buffer.push('(')
				g_code_buffer.push(opname)
				genCode(readPool(pecall+EXPR_OFS_ARGS+0),LEVEL_PREFIX)
				if got_bracket://outer_level&&outer_level<level:
					g_code_buffer.push(')')
				return TSCCPValue(){'tid':g_vtid_UNINIT}
			assert(n_args==2)
			my_level=level
			got_bracket=0
			if g_enable_debug_instrumentation&&optoken=='/':
				my_level=LEVEL_ASSIGNMENT
			if outer_level&&outer_level<=my_level:
				got_bracket=1
				g_code_buffer.push('(')
			if g_enable_debug_instrumentation&&optoken=='/':
				genLineInfoExpr(pecall)
				g_code_buffer.push(',')
			genCode(readPool(pecall+EXPR_OFS_ARGS+0),level)
			g_code_buffer.push(opname)
			if optoken=='/':
				g_code_buffer.push(' ')//avoid /*
			genCode(readPool(pecall+EXPR_OFS_ARGS+1),level)
			if got_bracket:
				g_code_buffer.push(')')
			return TSCCPValue(){'tid':g_vtid_UNINIT}
		}
		registerPrimitive(id_opr,fcompiler_callback.NULL,fop_oneval,fop_oncgen,FFLAG_ARITHMETIC|FFLAG_IS_PURE)
		enableOverloading(id_opr)
	CreateArithOperator("*",'*',40,function(a,b){return a*b},0,0)
	CreateArithOperator("/",'/',40,function(a,b){return a/b},0,0)
	CreateArithOperator("%",'%',40,function(a,b){return a%b},1,0)
	CreateArithOperator("+",'+',50,function(a,b){return a+b},0,0)
	CreateArithOperator("-",'-',50,function(a,b){return a-b},0,0)
	CreateArithOperator(">>",char(TOK_GG),52,function(a,b){return a>>int(b)},1,0)
	CreateArithOperator("<<",char(TOK_LL),52,function(a,b){return a<<int(b)},1,0)
	CreateArithOperator("&",'&',54,function(a,b){return a&b},1,0)
	CreateArithOperator("|",'|',56,function(a,b){return a|b},1,0)
	CreateArithOperator("^",'^',55,function(a,b){return a^b},1,0)
	//////////////////////////////////////
	CreateArithOperator("<",'<',60,function(a,b){return a<b},0,1)
	CreateArithOperator(">",'>',60,function(a,b){return a>b},0,1)
	CreateArithOperator("<=",char(TOK_LE),60,function(a,b){return a<=b},0,1)
	CreateArithOperator(">=",char(TOK_GE),60,function(a,b){return a>=b},0,1)
	CreateArithOperator("==",char(TOK_EQ),60,function(a,b){return a==b},0,1)
	CreateArithOperator("!=",char(TOK_NE),60,function(a,b){return a!=b},0,1)
	//////////////////////////////////////
	//basic types
	registerConst(getid("i8"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,8)))
	registerConst(getid("i16"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,16)))
	registerConst(getid("i32"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,32)))
	registerConst(getid("i64"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,64)))
	registerConst(getid("u8"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_UINT,8)))
	registerConst(getid("u16"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_UINT,16)))
	registerConst(getid("u32"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_UINT,32)))
	registerConst(getid("u64"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_UINT,64)))
	registerConst(getid("f32"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_FLOAT,32)))
	registerConst(getid("f64"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_FLOAT,64)))
	registerConst(getid("char"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,8)))
	registerConst(getid("short"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,16)))
	registerConst(getid("int"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,32)))
	registerConst(getid("float"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_FLOAT,32)))
	registerConst(getid("double"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_FLOAT,64)))
	registerConst(getid("iptr"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_INT,Util.bitSize())))
	registerConst(getid("uptr"),g_vtid_CTVAL,getBuiltinType(const_type(CTYPE_UINT,Util.bitSize())))
	registerConst(getid("__pointer"),g_vtid_CTVAL,getBuiltinType(CTYPE_POINTER))
	registerConst(getid("NULL"),g_vtid_CNS,g_cid_null)

auto resolveNames(PExpression g_pe_top,int is_initial_resolve)
	struct TNameStackItem
		int id
		PCTObject pvar_previous
	saved_names=new TNameStackItem[]
	auto resolveVariablesDfs(PExpression pe)
		//////////////////////
		//translate epos
		epos0=readPool(pe+1)
		epos1=readPool(pe+2)
		//we don't have inline yet, just use this
		if epos0&&epos1>0:
			writePool(pe+1,makeAdvEpos(epos0,epos1))
			writePool(pe+2,-1)
		else if !epos1:
			writePool(pe+1,0)
		//////////////////////
		//resolve variables
		if isExpr(pe,EFLAG_FCALL):
			n_args=getFCallNArgs(pe)
			pe_func=readPool(pe+EXPR_OFS_FUNCTION)
			fid=0
			if isExpr(pe_func,EFLAG_VARIABLE):
				fid=getVariable(pe_func)
			has_local_scope=0
			if fid==g_id_block&&n_args>0:
				pearg0=readPool(pe+EXPR_OFS_ARGS+0)
				if readPool(pearg0)==EFLAG_STRING+g_id_block:
					//block with local scope
					has_local_scope=1
			else if fid==g_id_function:
				has_local_scope=1
			else if fid==g_id_namespace:
				has_local_scope=1
			else if fid==g_id_store:
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				//Writeln('store translation? ',dumpExpr(pe_var,NULL))
				if isExpr(pe_var,EFLAG_FCALL):
					n_args_pevar=readPool(pe_var)&~EFLAG_MASK
					as=new PExpression[n_args_pevar+2]
					for i=-1:n_args_pevar-1
						as[i+1]=readPool(pe_var+EXPR_OFS_ARGS+i)
					as[n_args_pevar+1]=readPool(pe+EXPR_OFS_ARGS+1)
					pe_stored_func=as[0]
					if isBuiltinR(pe_stored_func,g_id_dot):
						assert(readPool(pe_stored_func)==EFLAG_FCALL+2)
						pe_member_name=readPool(pe_stored_func+EXPR_OFS_ARGS+1)
						assert(isExpr(pe_member_name,EFLAG_STRING))
						writePool(pe_member_name,EFLAG_STRING|catid(g_id_set_,(readPool(pe_member_name)&~EFLAG_MASK)))
					else if isExpr(pe_stored_func,EFLAG_VARIABLE):
						writePool(pe_stored_func,EFLAG_VARIABLE|catid(g_id_set_,getVariable(pe_stored_func)))
					else
						bk=g_names_resolved;g_names_resolved=1
						errorAtExpr(ETYPE_ERROR,pe_var,"cannot assign a value to expression '@1'".Replace("@1",citeexpr(pe_var)))
						g_names_resolved=bk
						writePool(pe,EFLAG_CONST+getid_const(const_type(CTYPE_INT,32),0LL))
						return
					pecaller=readPool(pe+EXPR_OFS_CALLER)
					pestfunc=fillepos(indcall(as),readPool(pe+1),readPool(pe+2))
					resolveVariablesDfs(insertCallAt(pecaller,pe,function(){return pestfunc}))
					return
			//do it here: resolveVariablesDfs needs to check for has_local_scope guys itself, so we can't resolve it early
			resolveVariablesDfs(readPool(pe+EXPR_OFS_FUNCTION))
			if has_local_scope:return
			for i=0:n_args-1
				resolveVariablesDfs(readPool(pe+EXPR_OFS_ARGS+i))
		else if isExpr(pe,EFLAG_VARIABLE):
			//resolve
			id=getVariable(pe)
			pv=g_symbols[id].user_slot
			if !pv:
				//undeclared variable
				bk=g_names_resolved;g_names_resolved=1
				errorAtExpr(ETYPE_ERROR,pe,"undeclared variable '@1'".Replace("@1",getIdString(id)))
				g_names_resolved=bk
				writePool(pe,EFLAG_CONST+getid_const(const_type(CTYPE_INT,32),0LL))
			else if readPool(pv)==g_tid_TNameSpace:
				//dot search
				pobj_space=pv
				pv=0
				pe_cur=pe
				while pobj_space:
					pecaller=readPool(pe_cur+EXPR_OFS_CALLER)
					if isBuiltin(pecaller,g_id_dot)||isBuiltin(pecaller,g_id_stdot)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe_cur:
						pe_member_name=readPool(pecaller+EXPR_OFS_ARGS+1)
						member_name_flags=readPool(pe_member_name)
						assert((member_name_flags&EFLAG_MASK)==EFLAG_STRING)
						id_member_name=(member_name_flags&~EFLAG_MASK)
						l=0
						r=readPool(pobj_space+1)-1
						while l<=r
							m=(l+r)>>1
							id_item=readPool(pobj_space+2+m*2)
							if id_item<=id_member_name:
								l=m+1
							else
								r=m-1
						if r>=0&&readPool(pobj_space+2+r*2)==id_member_name:
							pobj_space_next=readPool(pobj_space+2+r*2+1)
							assert(!!pobj_space_next)
							pe_cur=pecaller
							if readPool(pobj_space_next)==g_tid_TNameSpace:
								pobj_space=pobj_space_next
							else
								//we found it
								pv=pobj_space_next
								break
						else
							bk=g_names_resolved;g_names_resolved=1
							errorAtExpr(ETYPE_ERROR,pe_cur,"namespace '@1' doesn't have member '@2'".Replace(["@1",citeexpr(pe_cur),"@2",getIdString(id_member_name)]))
							g_names_resolved=bk
							break
					else
						bk=g_names_resolved;g_names_resolved=1
						errorAtExpr(ETYPE_ERROR,pe_cur,"namespace '@1' cannot be used directly".Replace(["@1",citeexpr(pe_cur)]))
						g_names_resolved=bk
						break
				//Writeln('namespace: ',citeexpr(pe_cur))
				if pv:
					if isBuiltin(pe_cur,g_id_stdot):
						//we should be able to reach the 2nd param during later resolve
						tmp=g_names_resolved
						g_names_resolved=1
						pe_new=call(g_id_store,exprvar(pv),readPool(pe_cur+EXPR_OFS_ARGS+2))
						g_names_resolved=tmp
					else
						assert(isBuiltin(pe_cur,g_id_dot))
						pe_new=exprvar(pv)
					pecaller=readPool(pe_cur+EXPR_OFS_CALLER)
					insertCallAt(pecaller,pe_cur,function(){return pe_new})
				else
					pecaller=readPool(pe_cur+EXPR_OFS_CALLER)
					insertCallAt(pecaller,pe_cur,function(){return expriptr(0)})
			else
				writePool(pe,pv|EFLAG_VARIABLE)
	local_scope_children=new PExpression[]
	g_global_scope=PCTObject(0)
	auto findStoreDfs(PCTObject pf_owner,PCTObject pf_return_scope,PExpression pe)
		if isExpr(pe,EFLAG_FCALL):
			n_args=getFCallNArgs(pe)
			pe_func=readPool(pe+EXPR_OFS_FUNCTION)
			fid=0
			if isExpr(pe_func,EFLAG_VARIABLE):
				fid=getVariable(pe_func)
			if fid==g_id_block&&n_args>0:
				pearg0=readPool(pe+EXPR_OFS_ARGS+0)
				if readPool(pearg0)==EFLAG_STRING+g_id_block:
					//block with local scope
					local_scope_children.push(pe)
					return
			else if fid==g_id_function:
				local_scope_children.push(pe)
				return 
			else if fid==g_id_namespace:
				local_scope_children.push(pe)
				return
			else if fid==g_id_store:
				//declare it
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				if isExpr(pe_var,EFLAG_FCALL):
					//tuple ass has to be recursively translated, so do it here
					n_args_pevar=readPool(pe_var)&~EFLAG_MASK
					if isBuiltinR(pe_var,g_id_block)&&readPool(readPool(pe_var+EXPR_OFS_ARGS+0))==EFLAG_STRING+g_id_tuple:
						//tuple ass - get rid of the new, ass the original rvalues
						//as becomes useless later
						//destroy the tuple flag, remove the final var
						//Writeln('tuple ass!!! '+dumpExpr(pe_var,NULL))
						insertCallAt(pe_var,~0,function(){return expriptr(0)})
						writePool(pe_var,EFLAG_FCALL+n_args_pevar-1)
						//modify the new
						pe_new=readPool(pe_var+EXPR_OFS_ARGS+1)
						assert(isBuiltinR(pe_new,g_id_store))
						insertCallAt(pe_new,~1,function(){return readPool(pe+EXPR_OFS_ARGS+1)})
						//reverse the ass direction
						for i=2:n_args_pevar-2
							pe_store_dot_i=readPool(pe_var+EXPR_OFS_ARGS+i)
							assert(isBuiltinR(pe_store_dot_i,g_id_store))
							pe_dot_i=readPool(pe_store_dot_i+EXPR_OFS_ARGS+0)
							assert(isBuiltinR(pe_dot_i,g_id_dot))
							pe_value_i=readPool(pe_store_dot_i+EXPR_OFS_ARGS+1)
							assert(isExpr(readPool(pe_dot_i+EXPR_OFS_ARGS+0),EFLAG_VARIABLE))
							pv_temp=getVariable(readPool(pe_dot_i+EXPR_OFS_ARGS+0))
							assert(!!pv_temp)
							writePool(pe_store_dot_i+EXPR_OFS_ARGS+0,pe_value_i)
							writePool(pe_store_dot_i+EXPR_OFS_ARGS+1,pe_dot_i)
						//Writeln('tuple assed!!! '+dumpExpr(pe_var,NULL))
						//replace the original store
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						findStoreDfs(pf_owner,pf_return_scope,insertCallAt(pecaller,pe,function(){return pe_var}))
						return
				else if isExpr(pe_var,EFLAG_VARIABLE):
					id=getVariable(pe_var)
					if n_args>2||!g_symbols[id].user_slot:
						//declare
						saved_names.push(TNameStackItem(){'id':id,'pvar_previous':g_symbols[id].user_slot})
						pv=makevar(pf_owner)
						if isBuiltinR(readPool(pe+EXPR_OFS_ARGS+1),g_id_ldparam):
							setUserFlag(pv,VAR_FLAG_PARAM)
						//this is a must-have: we may need a lookup later
						writePool(pv+VAR_OFS_ID,id)
						g_symbols[id].user_slot=pv
						if id==g_id_return:
							if !readPool(pf_owner+FUNCTION_OFS_PVAR_RETURN):
								writePool(pf_owner+FUNCTION_OFS_PVAR_RETURN,pv)
							else
								errorAtExpr(ETYPE_ERROR,pe,"duplicate return variable")
								//assert(0)
						writePool(pv+VAR_OFS_DEFINING_STORE,pe)
					else
						if testUserFlag(pv,VAR_FLAG_PARAM):
							errorAtExpr(ETYPE_ERROR,pe,"function parameter '"+getIdString(id)+"' cannot be overwritten")
			else if fid==g_id_import:
				pobj_space=g_root_namespace
				for i=0:n_args-1
					assert(readPool(pobj_space)==g_tid_TNameSpace)
					pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
					assert(isExpr(pe_argi,EFLAG_STRING))
					id_space=readPool(pe_argi)&~EFLAG_MASK
					l=0
					r=readPool(pobj_space+1)-1
					while l<=r
						m=(l+r)>>1
						id_item=readPool(pobj_space+2+m*2)
						if id_item<=id_space:
							l=m+1
						else
							r=m-1
					auto getBadNamespace()
						serr=new string
						for j=0:i
							if j:serr.push('.')
							pe_argj=readPool(pe+EXPR_OFS_ARGS+i)
							assert(isExpr(pe_argj,EFLAG_STRING))
							id_space_j=readPool(pe_argj)&~EFLAG_MASK
							serr.push(getIdString(id_space_j))
						return serr
					if r>=0&&readPool(pobj_space+2+r*2)==id_space:
						pobj_space_next=readPool(pobj_space+2+r*2+1)
						if !pobj_space_next:
							serr=getBadNamespace()
							errorAtExpr(ETYPE_ERROR,pe_argi,"'@1' is not a namespace".Replace("@1",serr))
							writePool(pe,EFLAG_STRING+g_id_import)
							return
						else
							pobj_space=pobj_space_next
					else
						serr=getBadNamespace()
						errorAtExpr(ETYPE_ERROR,pe_argi,"undeclared namespace '@1'".Replace("@1",serr))
						writePool(pe,EFLAG_STRING+g_id_import)
						return
				writePool(pe,EFLAG_STRING+g_id_import)
				n_items=readPool(pobj_space+1)
				for i=0:n_items-1
					id_item=readPool(pobj_space+2+i*2)
					pobj_imported=readPool(pobj_space+3+i*2)
					saved_names.push(TNameStackItem(){'id':id_item,'pvar_previous':g_symbols[id_item].user_slot})
					g_symbols[id_item].user_slot=pobj_imported
			else if fid==g_id_blockex:
				pe_arg0=readPool(pe+EXPR_OFS_ARGS+0)
				if readPool(pe_arg0)==EFLAG_STRING+g_id_return:
					//resolve return using pf_return_scope
					writePool(pe_arg0,EFLAG_STRING+getReturnLabel(pf_return_scope))
			for i=-1:n_args-1
				findStoreDfs(pf_owner,pf_return_scope,readPool(pe+EXPR_OFS_ARGS+i))
	auto resolveDfs(PCTObject pf_owner,PCTObject pf_return_scope,PExpression pe,int fdepth)
		fdepth_recurse=fdepth
		if isExpr(pe,EFLAG_FCALL):
			n_args=getFCallNArgs(pe)
			pe_func=readPool(pe+EXPR_OFS_FUNCTION)
			fid=0
			if isExpr(pe_func,EFLAG_VARIABLE):
				fid=getVariable(pe_func)
			pf_owner_new=pf_owner
			pf_return_scope_new=pf_return_scope
			n0_saved_names=saved_names.n
			n0_local_scope_children=local_scope_children.n
			has_local_scope=0
			define_new_return_var=1
			auto bindNamespaceMembers(PCTObject pobj_space)
				assert(has_local_scope)
				auto n=readPool(pobj_space+1)
				for i=0:n-1
					id_item=readPool(pobj_space+2+i*2)
					obj_item=readPool(pobj_space+3+i*2)
					saved_names.push(TNameStackItem(){'id':id_item,'pvar_previous':g_symbols[id_item].user_slot})
					g_symbols[id_item].user_slot=obj_item
			if fid==g_id_block&&n_args>0:
				pearg0=readPool(pe+EXPR_OFS_ARGS+0)
				if readPool(pearg0)==EFLAG_STRING+g_id_block:
					//block with local scope
					has_local_scope=1
			else if fid==g_id_namespace:
				//bind the pre-declared variables
				has_local_scope=1
				placeholder_flag=readPool(readPool(pe+EXPR_OFS_ARGS+2))
				if (placeholder_flag&EFLAG_MASK)!=EFLAG_CTVAL:
					errorAtExpr(ETYPE_ERROR,pe,"namespaces cannot appear in other classes / functions")
				else
					bindNamespaceMembers(placeholder_flag&~EFLAG_MASK)
			else if fid==g_id_function:
				has_local_scope=2
				//set up ldparam
				//inline parameters don't have to be typed, could use va_arg(i), but ldparam could still take an auto type
				pe_decl=pe
				as=new int[]
				n_funcargs=(n_args-2)>>1
				all_pe_ldparam=new int[n_funcargs]
				for i=1:2:n_args-3
					//declare and define params
					petype=readPool(pe_decl+(EXPR_OFS_ARGS)+i)
					pe_argname=readPool(pe_decl+(EXPR_OFS_ARGS+1)+i)
					if (readPool(pe_argname)&EFLAG_MASK)!=EFLAG_STRING:
						errorAtExpr(ETYPE_ERROR,pe_argname,"this function parameter name should be a string")
						continue
					//coulddo: epos
					epos0=readPool(petype+1)
					if !epos0:epos0=readPool(pe_argname+1)
					epos1=readPool(pe_argname+2)
					if !epos1:epos1=readPool(petype+1)
					pe_ldparam=call(g_id_ldparam,expriptr(i>>1),cloneExpr(petype),cloneExpr(pe_argname))
					all_pe_ldparam[i>>1]=pe_ldparam
					as.push(fillepos(call(g_id_store,exprvar(readPool(pe_argname)&~EFLAG_MASK),pe_ldparam,expriptr(0)),epos0,epos1))
				if !as.n:
					//need something as the rc insert position of the lambda ctx
					as.push(call(g_id_nop))
				code_new=insertCallAt(pe_decl,~(n_args-1),function(PExpression code_old){as.push(code_old);return vcall(g_id_block,as)})
				//create the function object, save it in the value slot
				fn=TFunction(){'code':code_new,'pe_decl':pe_decl}
				fn.obj_oneval=0
				fn.obj_oncgen=0
				//fn.nest_depth=fdepth_recurse
				fdepth_recurse++
				pf_owner_new=poolObject(fn)
				pe_ccnv=readPool(pe+EXPR_OFS_ARGS)
				if readPool(pe_ccnv)==EFLAG_STRING+g_id_inline_loopbody:
					define_new_return_var=0
				else
					pf_return_scope_new=pf_owner_new
				p_param_values=int(g_ctobject_pool.n)
				writePool(pf_owner_new+FUNCTION_OFS_PPARAM_VALUE_SLOTS,p_param_values)
				assert(sizeof(TSCCPValue)/sizeof(int)==2)
				g_ctobject_pool.addn(n_funcargs*3)
				for i=0:n_funcargs-1
					writePool(p_param_values+i*3,g_vtid_UNINIT)
					writePool(p_param_values+i*3+2,all_pe_ldparam[i])
				writePool(pe+EXPR_OFS_VALUE,g_vtid_CTVAL)
				writePool(pe+EXPR_OFS_VALUE+1,pf_owner_new)
				if is_initial_resolve&&!g_global_scope:
					//declare all namespace variable in the newly-created global scope
					g_global_scope=pf_owner_new
					auto createNamespaceMembers(PCTObject pobj_space)
						auto n=readPool(pobj_space+1)
						for i=0:n-1
							id_item=readPool(pobj_space+2+i*2)
							obj_item=readPool(pobj_space+3+i*2)
							if !obj_item:
								pv=makevar(g_global_scope)
								writePool(pv+VAR_OFS_ID,id_item)
								writePool(pobj_space+3+i*2,pv)
							else
								createNamespaceMembers(obj_item)
					createNamespaceMembers(g_root_namespace)
					bindNamespaceMembers(g_root_namespace)
			if has_local_scope:
				if has_local_scope==2:
					//function level, force-clear the "return" slot, unless it's a foreach inline
					if define_new_return_var:
						saved_names.push(TNameStackItem(){'id':g_id_return,'pvar_previous':g_symbols[g_id_return].user_slot})
						g_symbols[g_id_return].user_slot=0
					pe_ccnv=readPool(pe+EXPR_OFS_ARGS)
					if readPool(pe_ccnv)==EFLAG_STRING+g_id_inline:
						//inline function - define "arguments"
						saved_names.push(TNameStackItem(){'id':g_id_arguments,'pvar_previous':g_symbols[g_id_arguments].user_slot})
						pv=makevar(pf_owner_new)
						writePool(pv+VAR_OFS_ID,g_id_arguments)
						g_symbols[g_id_arguments].user_slot=pv
				for i=0:n_args-1
					findStoreDfs(pf_owner_new,pf_return_scope_new,readPool(pe+EXPR_OFS_ARGS+i))
			else
				findStoreDfs(pf_owner,pf_return_scope,pe)
			n1=local_scope_children.n
			//Writeln('local_scope_children=',local_scope_children[n0_local_scope_children:n1-1])
			for i=n0_local_scope_children:n1-1
				resolveDfs(pf_owner_new,pf_return_scope_new,local_scope_children[i],fdepth_recurse)
			local_scope_children.resize(n0_local_scope_children)
			if has_local_scope:
				//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
				for i=0:n_args-1
					resolveVariablesDfs(readPool(pe+EXPR_OFS_ARGS+i))
				//call pass 1 at each local scope
				//Writeln(dumpExpr(pe,NULL))
				//restore context
				for i=saved_names.n-1:-1:n0_saved_names
					svitem=saved_names[i]
					g_symbols[svitem.id].user_slot=svitem.pvar_previous
				saved_names.resize(n0_saved_names)
				if fid==g_id_namespace:
					//replace the namespace with a normal scoped block
					writePool(pe,EFLAG_FCALL+2)
					insertCallAt(pe,0,function(){return exprvar(g_id_block)})
					insertCallAt(pe,~0,function(){return exprstr(g_id_block)})
	resolveDfs(0,0,g_pe_top,0)
	resolveVariablesDfs(g_pe_top)
	g_names_resolved=1

///////////////////////////////////////////////////////////////
auto registerPrimitive(int id,fcompiler_callback fonreach,fcompiler_callback foneval,fcompiler_callback foncgen,int flags)
	value=varWrap(poolObject(TFunction(){
		'pe_decl':call(g_id_function,exprstr(g_id_function)),
		'obj_onreach':registerCompilerCallback(fonreach),
		'obj_oneval':registerCompilerCallback(foneval),
		'obj_oncgen':registerCompilerCallback(foncgen),
		'id_name':id,
		'flags':flags}))
	g_symbols[id].user_slot=value

auto registerConst(int id,int tid,int val)
	value=poolObject(TVariable(){
		'id':id,
		'tid':tid,
		'val':val})
	g_symbols[id].user_slot=value

//struct TCompilerPrimitive
//	fcompiler_callback onreach
//	fcompiler_callback oneval
g_compiler_callbacks=[(fcompiler_callback)NULL]
auto registerCompilerCallback(fcompiler_callback f)
	if !f:return 0
	n0=int(g_compiler_callbacks.n)
	g_compiler_callbacks.push(f)
	//return poolObject(TCompilerFunction(){'cbid':int(n0)})
	//ret=int(g_ctobject_pool.n)
	//g_ctobject_pool.push(n0)
	//return ret
	return n0

auto varWrap(PCTObject v)
	//create a VARIABLE that is a TFunction that exports those two objects
	//do we need TFunction? positive
	return poolObject(TVariable(){'tid':g_vtid_CTVAL,'val':v})

auto cnsWrap(int cid)
	//create a VARIABLE that is a TFunction that exports those two objects
	//do we need TFunction? positive
	return poolObject(TVariable(){'tid':g_vtid_CNS,'val':cid})

auto createConstant(int cns)
	return cnsWrap(getid_const(const_type(CTYPE_INT,32),i64(cns)))

//////////////////////////////////////////////////
//sccp
//reach or eval is well-defined up reaching the thing
g_sccp_queue_reach=new PExpression[]
g_sccp_queue_eval=new PExpression[]
auto sccpQueueReach(PExpression pecaller)
	//assert(pecaller!=92937)
	flags=readPool(pecaller)
	if (flags&EFLAG_MASK)!=EFLAG_FCALL:
		setUserFlag(pecaller,QUEUE_FLAG_REACH)
		if (flags&EFLAG_MASK)!=EFLAG_VARIABLE:return pecaller
		g_sccp_queue_reach.push(pecaller)
		return pecaller
	if !testUserFlag(pecaller,QUEUE_FLAG_REACH)
		setUserFlag(pecaller,QUEUE_FLAG_REACH)
		g_sccp_queue_reach.push(pecaller)
		if DEBUG_REACH_LOG:
			Writeln(FormatAsText('queuereach ',pecaller,' ',dumpExpr(pecaller,fcolor_abbrv_blocks)))
	return pecaller
	
g_counters_final_code_size=0LL
g_counters_sccp_calls=0LL
g_counters_eval=0LL
g_counters_queue_eval=0LL
auto sccpQueueEval(PExpression pecaller)
	if Platform.BUILD=="debug":
		g_counters_queue_eval++
	if !pecaller:return 0
	flags=readPool(pecaller)
	if (flags&EFLAG_MASK)!=EFLAG_FCALL:
		//g_sccp_queue.push(pecaller)
		return 0
	if !testUserFlag(pecaller,QUEUE_FLAG_EVAL)
		if DEBUG_EVAL_LOG:
			Writeln('>> sccpQueueEval ',pecaller)
			if !testUserFlag(pecaller,QUEUE_FLAG_REACH):
				if !isBuiltin(pecaller,g_id_ldparam):
					Writeln("root="+dumpExpr(g_pe_top,fcolor_reach_eval))
					Writeln("cannot eval unreached: "+dumpExpr(pecaller,NULL))
					assert(0)
		setUserFlag(pecaller,QUEUE_FLAG_EVAL)
		//assert(testUserFlag(pecaller,QUEUE_FLAG_REACH))
		g_sccp_queue_eval.push(pecaller)
		//in case anything changed, re-reach it
		//need a flag to avoid dupicate re-reach
		if !testUserFlag(pecaller,QUEUE_FLAG_ONREACH_CALLED):
			if DEBUG_REACH_LOG:
				//Writeln(FormatAsText('re-reach ',pecaller,' ',dumpExpr(pecaller,fcolor_reach_eval)))
				Writeln(FormatAsText('re-reach ',pecaller,' ',dumpExpr(pecaller,NULL)))
			assert(testUserFlag(pecaller,QUEUE_FLAG_REACH)||isBuiltin(pecaller,g_id_ldparam))
			queueReachChild(pecaller)
		return 1
	return 0

auto queueEvalUsers(PCTObject pobj_var)
	vv=readPoolTyped(pobj_var,TVariable)
	for(peuser=vv.first_v_user;peuser;peuser=readPool(peuser+EXPR_OFS_NEXT_V_USER))
		if isExpr(peuser,EFLAG_VARIABLE)
			pecaller=readPool(peuser+EXPR_OFS_CALLER)
			if testUserFlag(pecaller,QUEUE_FLAG_REACH):
				sccpQueueEval(pecaller)
				if DEBUG_EVAL_LOG:
					Writeln('>> queueeval ',pecaller)
		else
			//if Platform.BUILD=="debug":
			//	if !isExpr(peuser,EFLAG_FCALL):
			//		Writeln('==============')
			//		Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
			//		Writeln('==============')
			//		Writeln(dumpExpr(peuser,NULL))
			if !isExpr(peuser,EFLAG_FCALL):
				//nuked expr
				assert(readPool(peuser)==EFLAG_STRING+g_empty_id)
				continue
			if testUserFlag(peuser,QUEUE_FLAG_REACH):
				sccpQueueEval(peuser)
				if DEBUG_EVAL_LOG:
					Writeln('>> queueeval ',peuser)

auto queueEvalFunction(PCTObject pobjfn)
	if !pobjfn:return
	//consider-as-changed
	writePool(pobjfn+FUNCTION_OFS_VALUE_TIME,++g_value_time)
	if DEBUG_EVAL_LOG:
		Writeln('queueEvalFunction ',g_value_time,' ',getIdString(readPoolTyped(pobjfn,TFunction).id_name))
	for(plistitem=readPool(pobjfn+FUNCTION_OFS_FUSER);plistitem;plistitem=readPool(plistitem))
		peuser=readPool(plistitem+1)
		//Writeln('>> ',dumpExpr(peuser,NULL))
		if peuser&0x80000000:
			sccpQueueEval(peuser&0x7fffffff)
		else
			pecaller=readPool(peuser+EXPR_OFS_CALLER)
			if pecaller:
				sccpQueueEval(pecaller)
	peuser=readPoolTyped(pobjfn,TFunction).pe_decl
	//Writeln('>> ',dumpExpr(peuser,NULL))
	pecaller=readPool(peuser+EXPR_OFS_CALLER)
	if pecaller:
		sccpQueueEval(pecaller)

auto getOwningFunction(PExpression pe)
	//enum scope from parents
	for(pei=pe;pei;)
		pe_parent=readPool(pei+EXPR_OFS_CALLER)
		if isBuiltin(pei,g_id_function):
			val=getExprValue(pei)
			assert(val.tid==g_vtid_CTVAL)
			return val.val
		pei=pe_parent
	if Platform.BUILD=="debug":
		Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
		Writeln(string(pe)+" "+dumpExpr(pe,fcolor_abbrv_blocks))
		Writeln(string(readPool(pe+EXPR_OFS_CALLER))+" "+dumpExpr(readPool(pe+EXPR_OFS_CALLER),fcolor_reach_eval))
		Writeln(string(readPool(readPool(pe+EXPR_OFS_CALLER)+EXPR_OFS_CALLER))+" "+dumpExpr(readPool(readPool(pe+EXPR_OFS_CALLER)+EXPR_OFS_CALLER),fcolor_abbrv_blocks))
	assert(0)
	return 0
	
auto invokeCallbackObject(PCTObject fcallback,PExpression pe,int arg0)
	if !fcallback:
		//failed
		return TSCCPValue(){'tid':g_vtid_UNINIT}
	//tid=readPool(fcallback)
	//if tid==g_tid_TCompilerFunction:
	//	return g_compiler_callbacks[readPoolTyped(fcallback,TCompilerFunction).cbid](pe,arg0)
	//errorAtExpr(ETYPE_ERROR,pe,"invalid compiler callback on expression '"+citeexpr(pe)+"'")
	//return TSCCPValue(){'tid':g_vtid_UNINIT}
	return g_compiler_callbacks[readPool(fcallback)](pe,arg0)
	
auto getExprType(PExpression pe)
	return getValueTypeEx(pe,getExprValue(pe))

auto evaluateAsType(PExpression pe)
	ret=getExprValueAs(pe,g_vtid_CTVAL)
	if !ret:return 0
	tid=readPool(ret)
	//&&(readPoolTyped(tid,TFunction).flags&FFLAG_TYPE)
	if tid==g_tid_TBuiltinType||tid==g_tid_TFunction:return ret
	return 0

auto isValueZero(TSCCPValue val)
	if val.tid==g_vtid_CNS:
		return isConstZero(ctNumber(val.val))
	else
		return 0

auto isValueNegOne(TSCCPValue val)
	if val.tid==g_vtid_CNS:
		return isConstNegOne(ctNumber(val.val))
	else
		return 0

auto isValueOne(TSCCPValue val)
	if val.tid==g_vtid_CNS:
		return isConstOne(ctNumber(val.val))
	else
		return 0

auto makeFunctionType(PExpression pe_queued,PCTObject pobjfn)
	//make a function type, check existing
	assert(getCcnv(pobjfn)!=g_id_inline&&getCcnv(pobjfn)!=g_id_inline_loopbody)
	pobj_var=getReturnVariable(pobjfn)
	if pobj_var:
		t_return=getVariableType(pobj_var)
		if !t_return:
			//we need to have a deducted return type
			//auto functions do not have fn.pvar_return, which has been determined during name resolution
			if DEBUG_EVAL_LOG:
				Writeln('  return type not ready - setused: ',dumpFunction(pobjfn))
			setFunctionUsed(pobjfn)
			setParameterSlotTypes(pobjfn)
			addFunctionUser(pobjfn,pe_queued|0x80000000)
			return 0
	pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	return makeFunctionTypeRaw(pe_queued,pe_decl,t_return,getFFlag(pobjfn))

auto makeFunctionTypeRaw(PExpression pe_queued,PExpression pe_decl,PCTObject t_return,int flags)
	n_args_pe_decl=readPool(pe_decl)
	n_args=(n_args_pe_decl-2)>>1
	ts=new PCTObject[n_args]
	for i=0:n_args-1
		ts[i]=getExprValueAs(readPool(pe_decl+EXPR_OFS_ARGS+i*2+1),g_vtid_CTVAL)
		if !ts[i]:
			return 0
	keys=[g_id_function_type]
	keys.push(t_return)
	keys.push(ts)
	pobj_ftype=readCtUniqueInEvalFlow(pe_queued,keys)
	if !pobj_ftype:
		ft=TFunctionType(){
			't_ret':t_return,
			'n_args':n_args,
			'p_arg_types':int(g_ctobject_pool.n),
			'flags':flags,
		}
		g_ctobject_pool.push(ts)
		pobj_ftype_raw=poolObject(ft)
		//instantiate the template immediately
		t_function_wrapper=getStdObject(pe_queued,STDTYPE_FUNCTION_IMPL)
		if !t_function_wrapper:
			if DEBUG_EVAL_LOG:
				Writeln('  function wrapper not ready')
			return 0
		t_variant=getStdObject(pe_queued,STDTYPE_VARIANT)
		if t_variant:setFunctionUsed(t_variant)
		pe_temp=indcall([exprctval(t_function_wrapper),exprctval(pobj_ftype_raw)])
		val_ftype=invokeCallbackObject(readPool(t_function_wrapper+FUNCTION_OFS_ONEVAL),pe_temp,0)
		assert(val_ftype.tid==g_vtid_CTVAL)
		pobj_ftype=val_ftype.val
		setFFlag(pobj_ftype,FFLAG_IS_FUNCTION)
		setFunctionUsed(pobj_ftype)
		writePool(pobj_ftype+FUNCTION_OFS_T_RAW_FUNCTION_TYPE,pobj_ftype_raw)
		writeCtUniqueInEvalFlow(keys,pobj_ftype)
	return pobj_ftype

g_stdtype_ids=[getid("stdtype.box"),getid("stdtype.array"),getid("stdtype.string"),getid("stdtype.variant"),getid("stdfn.functional_or"),getid("stdtype.function_impl"),getid("stdfn.make_function"),getid("stdfn.make_string"),getid("stdtype.map"),getid("stdfn.clone")]
g_stdtype_types=new PCTObject[g_stdtype_ids.n]
g_ctype_fixed=0//function and string types become __pointers after this becomes 1
auto getStdObject(PExpression pe_queued,int which)
	ret=g_stdtype_types[which]
	if !ret:
		ret=readCtUniqueInEvalFlow(pe_queued,[g_id_meta_state,g_stdtype_ids[which]])
		if ret:
			g_stdtype_types[which]=ret
	return ret

auto getValueTypeEx(PExpression pe_queued,TSCCPValue val)
	if val.tid==g_vtid_UNINIT:
		return 0
	else if val.tid==g_vtid_CTVAL:
		//if !val.val:
		//	Writeln(dumpCode(g_pe_top,NULL))
		if readPool(val.val)==g_tid_TFunction:
			if getCcnv(val.val)==g_id_function:
				if g_ctype_fixed:
					return getBuiltinType(CTYPE_POINTER)
				else
					return makeFunctionType(pe_queued,val.val)
			else
				//hack for typeof(inline) in member handling
				return getBuiltinType(CTYPE_POINTER)
		else
			if DEBUG_EVAL_LOG:
				Writeln('  ctval is not a function')
		return 0
	else if val.tid==g_vtid_RTVAR:
		return val.val
	else if val.tid==g_vtid_CNS:
		cval=Util.ctNumber(val.val)
		//if cval.type>50:
		//	Writeln('bad cns: ',val.val)
		if cval.type==CTYPE_TYPED_NULL:
			return PCTObject(cval.val_bin)
		return getBuiltinType(cval.type)
	else if val.tid==g_vtid_STR:
		if g_ctype_fixed:
			return getBuiltinType(CTYPE_POINTER)
		else
			return getStdObject(pe_queued,STDTYPE_STRING)
	//Writeln(getIdString(val.tid))
	assert(0)
	return 0

auto getValueType(TSCCPValue val)
	return getValueTypeEx(0,val)
	
auto mergeValues(PExpression pe,TSCCPValue val_old,TSCCPValue val_new0,PExpression pe_old,PExpression pe_new)
	val_new=val_new0
	assert(val_old.tid>=g_vtid_UNINIT&&val_old.tid<=g_vtid_CTVAL)
	assert(val_new.tid>=g_vtid_UNINIT&&val_new.tid<=g_vtid_CTVAL)
	if val_new.tid==g_vtid_CNS&&val_new.val==g_cid_null&&val_old.tid!=g_vtid_CNS:
		//NULL merge, cast NULL to the proper type
		t=getValueTypeEx(pe,val_old)
		if t:
			val_new.val=getid_const(CTYPE_TYPED_NULL,t)
	val_final=val_old
	if val_old.tid==g_vtid_UNINIT:
		val_final=val_new
	else if val_new.tid==g_vtid_UNINIT:
		//val_final=val_old
	else if val_old.tid==g_vtid_RTVAR:
		//val_final=val_old
		//already var, just do a type deduction
		t_old=val_old.val
		t_new=getValueType(val_new)
		if val_new.tid==g_vtid_CTVAL&&!t_new:
			//unready function, ignore for now
			val_final=val_old
		else
			val_final=val_old
			val_final.val=typeMerge(pe,t_old,t_new,pe_old,pe_new,0)
			if val_new.tid==g_vtid_CTVAL&&readPool(val_new.val)==g_tid_TFunction:
				setFunctionUsed(val_new.val)
				setParameterSlotTypes(val_new.val)
				//queueEvalFunction(val_new.val)
			if !val_final.val:
				val_final=val_old
	else if val_old.tid!=val_new.tid:
		//Writeln(getIdString(val_old.tid),' | ',getIdString(val_new.tid))
		val_final.tid=g_vtid_RTVAR
		t_old=getValueTypeEx(pe,val_old)
		t_new=getValueTypeEx(pe,val_new)
		val_final.val=typeMerge(pe,t_old,t_new,pe_old,pe_new,0)
		if !val_final.val:
			val_final=val_old
		if Platform.BUILD=="debug":
			if val_final.val&&readPool(val_final.val)==g_tid_TFunction:
				id_ccnv=getCcnv(val_final.val)
				if id_ccnv==g_id_inline||id_ccnv==g_id_inline_loopbody:
					Writeln(dumpExpr(pe,NULL))
					assert(0)
		if val_old.tid==g_vtid_CTVAL&&!t_old:
			setFunctionUsed(val_old.val)
			setParameterSlotTypes(val_old.val)
			//queueEvalFunction(val_old.val)
		if val_new.tid==g_vtid_CTVAL&&!t_new:
			setFunctionUsed(val_new.val)
			setParameterSlotTypes(val_new.val)
			//queueEvalFunction(val_new.val)
	else if val_old.val==val_new.val:
		//val_final=val_old
	else if val_old.tid==g_vtid_CNS:
		if Util.ctNumber(val_old.val)!=Util.ctNumber(val_new.val):
			val_final.tid=g_vtid_RTVAR
			val_final.val=typeMerge(pe,getValueType(val_old),getValueType(val_new),pe_old,pe_new,0)
			if !val_final.val:
				val_final=val_old
	else if val_old.tid==g_vtid_STR:
		//strings are interned
		val_final.tid=g_vtid_RTVAR
		val_final.val=getStdObject(pe,STDTYPE_STRING)
		if !val_final.val:
			val_final=val_old
	else if val_old.tid==g_vtid_CTVAL:
		//where val is a PCTObject
		//meta functions should refuse double-evaluation
		//this is definitely an error
		if readPool(val_old.val)==g_tid_TFunction&&readPool(val_new.val)==g_tid_TFunction:
			//what if we don't know about the return type
			t_old=getValueTypeEx(pe,val_old)
			t_new=getValueTypeEx(pe,val_new)
			if !t_old:
				setFunctionUsed(val_old.val)
				setParameterSlotTypes(val_old.val)
				//queueEvalFunction(val_old.val)
			if !t_new:
				setFunctionUsed(val_new.val)
				setParameterSlotTypes(val_new.val)
				//queueEvalFunction(val_new.val)
			t=typeMerge(pe,t_old,t_new,pe_old,pe_new,0)
			if t:
				val_final.tid=g_vtid_RTVAR
				val_final.val=t
			else
				if t_old&&t_new:
					errorAtExpr(ETYPE_ERROR,pe,"incompatible functions types at '@1': '@2' vs '@3',".Replace([
						"@1",citeexpr(pe),
						"@2",dumpType(t_old),
						"@3",dumpType(t_new),
					]))
		else
			errorAtExpr(ETYPE_ERROR,pe,"panic: compile-time expression '@1' must not be ambiguous".Replace(["@1",citeexpr(pe)]))
			//assert(0)
		//assert(0)
	return val_final

auto queueReachChild(PExpression pe)
	pobjfn=getExprFunction(pe)
	//Writeln('>>> ',pe,' ',getIdString(id),' ',pobj)
	if !pobjfn:
		pe_func=readPool(pe+EXPR_OFS_FUNCTION)
		val=getExprValue(pe_func)
		if val.tid!=g_vtid_UNINIT:
			//non-function call, could be a cast, queue it anyway
			n=(readPool(pe)&~EFLAG_MASK)
			for i=n-1:-1:-1
				sccpQueueReach(readPool(pe+EXPR_OFS_ARGS+i))
			setUserFlag(pe,QUEUE_FLAG_ONREACH_CALLED)
		else
			sccpQueueReach(pe_func)
			if DEBUG_REACH_LOG:
				Writeln('unknown func, skipping child reach - ',dumpExpr(pe,NULL))
		return
	setUserFlag(pe,QUEUE_FLAG_ONREACH_CALLED)
	cb_onreach=readPool(pobjfn+FUNCTION_OFS_ONREACH)
	if cb_onreach:
		//cb_onreach could be another TFunction (a meta)
		invokeCallbackObject(cb_onreach,pe,0)
		return
	n=(readPool(pe)&~EFLAG_MASK)
	//Writeln(getIdString(id),' -> default ',n)
	for i=n-1:-1:-1
		sccpQueueReach(readPool(pe+EXPR_OFS_ARGS+i))

auto sccpProcessReaches()
	while g_sccp_queue_reach.n:
		//Write('R')
		pe=g_sccp_queue_reach.pop()
		//variable can be reached, and it's significant
		flags=readPool(pe)
		if DEBUG_REACH_LOG:
			Writeln(FormatAsText('reach ',pe,' ',dumpExpr(pe,fcolor_reach_eval)))
		if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			//name-to-user link
			pobj=getVariable(pe)
			//need a more reliable flag
			if pobj&&isVariable(pobj):
				//if DEBUG_REACH_LOG:
				//	Writeln('shit! already queued!')
				if !testUserFlag(pe,QUEUE_FLAG_USERS):
					//if DEBUG_REACH_LOG:
					//	Writeln('add var to user queue ',getIdString(id),' ',pe,' pobj=',pobj,'@',ob_resolved,'.',id,' next=',readPool(pobj+VAR_OFS_USER_QUEUE))
					//writePool(pobj+offsetof(TSCCPValue.first_v_user),pe)
					//writePool(pe+offsetof(TVarExpression.next_v_user),pobj)
					setUserFlag(pe,QUEUE_FLAG_USERS)
					//writePool(pobj,g_vtid_UNINIT)
					writePool(pe+EXPR_OFS_NEXT_V_USER,readPool(pobj+VAR_OFS_USER_QUEUE))
					writePool(pobj+VAR_OFS_USER_QUEUE,pe)
			continue
		assert((flags&EFLAG_MASK)==EFLAG_FCALL)
		//er=readPoolTyped(pe,TExpression)
		//we can only reach anything once
		//unsetUserFlag(pe,QUEUE_FLAG_REACH)
		//////
		//if er.val.tid==g_vtid_UNREACHED:
		//	er.val.tid=g_vtid_UNINIT
		//	writePool(pe+EXPR_OFS_VALUE,g_vtid_UNINIT)
		//eval it later
		sccpQueueEval(pe)
		//queueeval calls queueReachChild for us
		//queueReachChild(pe)

auto addFunctionUser(PCTObject pobjfn,PExpression pe)
	pnext=readPool(pobjfn+FUNCTION_OFS_FUSER)
	plistitem=int(g_ctobject_pool.n)
	g_ctobject_pool.push(pnext)
	g_ctobject_pool.push(pe)
	writePool(pobjfn+FUNCTION_OFS_FUSER,plistitem)

auto sccp(PExpression g_pe_top)
	if Platform.BUILD=="debug":
		g_counters_sccp_calls++
	if g_pe_top:sccpQueueReach(g_pe_top)
	Q0=PExpression[].NULL
	q0head=0
	while g_sccp_queue_reach.n||g_sccp_queue_eval.n
		//sweep first, eval later
		//n0_eval=g_sccp_queue_eval.n
		//the reach queue is order sensitive, and it's not FIFO
		sccpProcessReaches()
		//reverse the queued eval jobs
		//n_reverse=g_sccp_queue_eval.n-n0_eval
		//for i=0:(n_reverse>>1)-1
		//	tmp=g_sccp_queue_eval[n0_eval+i]
		//	g_sccp_queue_eval[n0_eval+i]=g_sccp_queue_eval[n0_eval+(n_reverse-1-i)]
		//	g_sccp_queue_eval[n0_eval+(n_reverse-1-i)]=tmp
		/////////////
		if !Q0||q0head>=Q0.n:
			Q0=g_sccp_queue_eval
			g_sccp_queue_eval=new PExpression[]
			q0head=0
		for(;q0head<Q0.n;)
			if g_sccp_queue_reach.n:break
			pe=Q0[q0head++]
			assert((readPool(pe)&EFLAG_MASK)==EFLAG_FCALL)
			if DEBUG_EVAL_LOG:
				//if !isSpecial(pe):
				Writeln(FormatAsText('eval ',pe,' ',dumpExpr(pe,fcolor_abbrv_blocks)))
			//if g_dump_eval:
			//	Writeln('eval ',pe,' ',dumpExpr(pe,function(){return -1}))
			//er=readPoolTyped(pe,TExpression)
			unsetUserFlag(pe,QUEUE_FLAG_EVAL)
			/////////////////
			if isBuiltin(pe,g_id_nop):continue
			pecaller=readPool(pe+EXPR_OFS_CALLER)
			pecaller0=pecaller
			if !pecaller&&pe!=g_pe_top||pecaller&&isBuiltin(pecaller,g_id_nop):continue
			pecallee=readPool(pe+EXPR_OFS_FUNCTION)
			val_callee=getExprValue(pecallee)
			pobj=0
			pobjfn=0
			if val_callee.tid==g_vtid_CTVAL:
				pobj=val_callee.val
				pobjfn=getAsFunction(pobj)
			val_new=TSCCPValue(){'tid':g_vtid_UNINIT}
			if Platform.BUILD=="debug":
				g_counters_eval++
			if pobjfn:
				if Platform.BUILD=="debug":
					tbegin(tm_evalcb)
				cb_oneval=readPool(pobjfn+FUNCTION_OFS_ONEVAL)
				//if DEBUG_EVAL_LOG:
				//	Writeln('cb_oneval=',string.ToHex(cb_oneval))
				if cb_oneval:
					val_new=invokeCallbackObject(cb_oneval,pe,0)
					if Platform.BUILD=="debug":
						if !(val_new.tid>=g_vtid_UNINIT&&val_new.tid<=g_vtid_CTVAL):
							Writeln(dumpCode(g_pe_top,NULL))
							Writeln(FormatAsText('bad value after cb ',pe,' ',dumpExpr(pe,fcolor_abbrv_blocks),' ',val_new.tid,' ',getIdString(val_new.tid)))
							assert(0)
				else
					if DEBUG_EVAL_LOG:
						Writeln('  null callback: ',pobjfn+FUNCTION_OFS_ONEVAL)
				if Platform.BUILD=="debug":
					tend(tm_evalcb)
			else if !pobj&&val_callee.tid!=g_vtid_RTVAR:
				//not ready yet
				val_new=TSCCPValue(){'tid':g_vtid_UNINIT}
				if DEBUG_EVAL_LOG:
					Writeln('  function uninit')
			else
				if DEBUG_EVAL_LOG:
					Writeln('  indirect call')
				vtid=pobj?readPool(pobj):g_vtid_UNINIT
				val_new=TSCCPValue(){'tid':g_vtid_UNINIT}
				if pobj&&vtid==g_vtid_UNINIT:
					//somehow it's a variable, but the variable's value isn't ready yet
					//shouldn't happen
					assert(0)
				else if pobj&&vtid==g_tid_TBuiltinType:
					n_args=getFCallNArgs(pe)
					if n_args<=1:
						//builtin-type cast
						auto pecaller=readPool(pe+EXPR_OFS_CALLER)
						if n_args==1:
							peopr=readPool(pe+EXPR_OFS_ARGS+0)
							insertCallAt(pe,~0,function(){return expriptr(0)})
						else
							peopr=expriptr(0)
						insertCallAt(pe,0,function(){return expriptr(0)})
						//writePool(pecallee+EXPR_OFS_CALLER,0)
						//writePool(peopr+EXPR_OFS_CALLER,0)
						sccpQueueReach(insertCallAt(pecaller,pe,function(){return call(g_id_cast,pecallee,peopr)}))
						continue
					else
						errorAtExpr(ETYPE_ERROR,pe,"builtin-type '@1' cannot be constructed from @2 arguments".Replace(["@1",dumpType(pobj),"@2",string(n_args)]))
				else{
					//we're sure it's an indirect call
					val_new=TSCCPValue(){'tid':g_vtid_UNINIT}
					auto tcallee=getValueTypeEx(pe,val_callee)
					if tcallee&&tisfunction(tcallee):
						auto ft=readPoolTyped(getRawFunctionType(tcallee),TFunctionType)
						auto n_args=getFCallNArgs(pe)
						auto n_funcargs=ft.n_args
						if n_args<n_funcargs:
							errorAtExpr(ETYPE_ERROR,pecallee,"function '@1' takes @2 arguments, but only @3 is provided".Replace([
								"@1",citeexpr(pecallee),
								"@2",string(n_funcargs),
								"@3",string(n_args)]))
						else
							//error check -- # parameters and their types
							param_errored=0
							for i=0:n_funcargs-1
								pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
								t_expected=readPool(ft.p_arg_types+i)
								if !t_expected:continue
								t=getExprType(pe_argi)
								if !t:continue
								if !parameterTypeCheck(t_expected,t):
									errorAtExpr(ETYPE_ERROR,pe_argi,"parameter #@3 type mismatch: '@1' expected but '@2' provided".Replace(["@1",dumpType(t_expected),"@2",dumpType(t),"@3",string(i)]))
									param_errored=1
									continue
							if !param_errored:
								auto t_ret=ft.t_ret
								if t_ret:
									val_new=TSCCPValue(){'tid':g_vtid_RTVAR,'val':t_ret}
				}
			val_old=readPoolTyped(pe+EXPR_OFS_VALUE,TSCCPValue)
			val_final=mergeValues(pe,val_old,val_new, pe,pe)
			if val_old.tid==val_final.tid&&val_old.val==val_final.val:
				//if nothing changed, change nothing
				continue
			//the value changed, eval the caller
			//the caller is a must-queue
			writePoolTyped(pe+EXPR_OFS_VALUE,val_final)
			//pecaller=readPool(pe+EXPR_OFS_CALLER)
			//we must not re-read pecaller - even if the tree changed in the middle, we still need to queue the original caller
			if DEBUG_EVAL_LOG:
				Write('  changed - queue caller ',pecaller0,' ',getIdString(val_old.tid),' -> ',getIdString(val_final.tid))
				if val_final.tid==g_vtid_CNS:
					Write(' ',dumpConst(Util.g_const_values[val_final.val]))
				else if val_final.tid==g_vtid_STR:
					Write(' ',getIdString(val_final.val))
				else if val_final.tid==g_vtid_CTVAL:
					Write(' ',dumpObject(val_final.val))
				else if val_final.tid==g_vtid_RTVAR:
					Write(' ',dumpType(val_final.val))
				Writeln()
			if val_final.tid==g_vtid_RTVAR:
				assert(!!val_final.val)
			//if (val_old.tid==g_vtid_UNINIT||val_final.tid==g_vtid_RTVAR)&&readPool(pecaller+EXPR_OFS_FUNCTION)==pe:
			//	//suddenly, we know what the function is, need to re-queue the reaches
			//	queueReachChild(pecaller)
			sccpQueueEval(pecaller0)
			//check whether we need to add something to a function queue
			if val_final.tid==g_vtid_CTVAL&&isFunction(val_final.val):
				//add to function queue
				//first_function_user
				//if DEBUG_EVAL_LOG:
				//	Writeln('  addFunctionUser (CTVAL)')
				pobjfn_value=val_final.val
				addFunctionUser(pobjfn_value,pe)
	//////////////

g_cdf_hash=uptr(0)
g_cdf_unchanged_count=0
g_has_untranslated_cdf=0
auto evalCodeDependingFunctions()
	cdf_set=new PExpression[]
	changed=0
	auto evalcdf_dfs(PExpression pe)
		ret=0
		if isExpr(pe,EFLAG_FCALL):
			if !testUserFlag(pe,QUEUE_FLAG_REACH):return 0
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				ret|=evalcdf_dfs(readPool(pe+EXPR_OFS_ARGS+i))
			pobjfn=getExprFunction(pe)
			if pobjfn&&(getFFlag(pobjfn)&FFLAG_DEPENDS_ON_OTHER_CODE):
				//Writeln('evalCodeDependingFunctions: '+dumpExpr(pe,fcolor_abbrv_blocks))
				cdf_set.push(pe)
				cb_oneval=readPool(pobjfn+FUNCTION_OFS_ONEVAL)
				if cb_oneval:
					val_new=invokeCallbackObject(cb_oneval,pe,1)
					val_old=readPoolTyped(pe+EXPR_OFS_VALUE,TSCCPValue)
					val_final=mergeValues(pe,val_old,val_new, pe,pe)
					if !(val_old.tid==val_final.tid&&val_old.val==val_final.val):
						writePoolTyped(pe+EXPR_OFS_VALUE,val_final)
						changed=1
					//we need to do it again if we've evaluated anything - any of them is a code changer
					ret=1
		return ret
	//Writeln('g_sccp_queue_eval=',g_sccp_queue_eval.n)
	ret=evalcdf_dfs(g_pe_top)
	if !changed&&cdf_set.n>0:
		h=uptr(cdf_set.__hash__())
		if g_cdf_hash==h:
			g_cdf_unchanged_count++
			if g_cdf_unchanged_count>=3:
				foreach pe in cdf_set
					errorAtExpr(ETYPE_ERROR,pe,"failed to translate code-depending function @1".Replace("@1",citeexpr(pe)))
					setnop(pe)
				return 0//force-continue
		else
			g_cdf_unchanged_count=0
		g_cdf_hash=h
	else
		g_cdf_unchanged_count=0
		g_cdf_hash=uptr(0)
	g_has_untranslated_cdf=(cdf_set.n>0)
	return ret

g_strflatten_monitored_variables=new PCTObject[][PExpression]
//g_strflatten_monitored_variables=new PCTObject[]
//g_strflatten_eval_queue=new PExpression[]
//tm_flatten_step0=tnew(">strflatten step0")
//tm_flatten_step1=tnew(">strflatten step1")
//tm_flatten_step2=tnew(">strflatten step2")
//tm_flatten_step3=tnew(">strflatten step3")
//one remaining problem - const vector lambdas in derivs may get mistakenly flattened
auto strflatten(PExpression pe_top,PExpression monitoring_base)
	VAR_USER_UNFLATTENABLE=1
	VAR_USER_GOT_NEW=2
	VAR_USER_KEEP_ORIGINAL=4
	VAR_USER_FLATTENED_VAR_IS_WRITTEN=8
	USER_FLAG_EMPTY_NEW_TESTED=1
	USER_FLAG_IS_EMPTY_NEW=2
	//which-function-accesses-what-member analysis... useless - passing in a class usually accesses its member
	//passed to anything other than dot/stdot = no
	//focus on local objects
	//for each variable, we can compute a global flattenablity flag
	//to make it local... replace the *appeared* obj-member combos with plain variables
	//tbegin(tm_flatten_step0)
	clearUserFlags(pe_top,USER_FLAG_ACTIVATED)
	unflattenable_types=new PCTObject[]
	fmark_flattability=function(PExpression pe,PCTObject pf_owner){
		if isExpr(pe,EFLAG_VARIABLE):
			pobj_var=getVariable(pe)
			if testUserFlag(pobj_var,VAR_USER_UNFLATTENABLE):
				return 0
			if (readPool(pobj_var+VAR_OFS_OWNER)!=pf_owner||
			readPool(pobj_var)!=g_vtid_RTVAR||
			!tisclass(readPool(pobj_var+1))||
			readPool(pobj_var+VAR_OFS_ID)==g_id_this||
			readGlobalI2Hash(int2(pobj_var,0))||
			tisclass(pf_owner)):
				//deny non-locals
				//ignore consts
				//ignore non-class/struct
				//deny "this"
				//ignore already-flattened
				//ignore class members
				//variables accessed elsewhere are striked out here
				if DEBUG_DUMP_FLATTEN:
					Writeln('unflattenable (generic): '+dumpExpr(pe,NULL))
				setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
				return 0
			t=readPool(pobj_var+1)
			pecaller=readPool(pe+EXPR_OFS_CALLER)
			if !testUserFlag(pecaller,QUEUE_FLAG_REACH):
				if DEBUG_DUMP_FLATTEN:
					Writeln('unflattenable (caller unreached): '+dumpExpr(pecaller,NULL))
				setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
				return 0
			if (isBuiltin(pecaller,g_id_dot)||isBuiltin(pecaller,g_id_stdot))&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
				//dot usages are flattenable
				pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
				pe_member_name=readPool(pecaller+EXPR_OFS_ARGS+1)
				flags=readPool(pe_member_name)
				if readPool(pecaller_caller+EXPR_OFS_FUNCTION)==pecaller||(flags&EFLAG_MASK)==EFLAG_CTVAL&&!isVariable(flags&~EFLAG_MASK):
					//but not method calls or CTVAL hack dots
					//Writeln('method call: '+dumpExpr(pecaller_caller,fcolor_abbrv_blocks))
					if DEBUG_DUMP_FLATTEN:
						Writeln('unflattenable (method call): '+dumpExpr(pe,NULL)+" "+dumpExpr(pecaller,NULL))
					setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
				else if readPool(pecaller)==EFLAG_FCALL+3:
					//stdot
					pe_value=readPool(pecaller+EXPR_OFS_ARGS+2)
					if getExprValue(pe_value).tid==g_vtid_UNINIT:
						//nor are structs hosting unresolved members
						//make sure it's not the ctor __uninit
						pobj_member=getDotMember(pecaller,1)
						if readPool(pobj_member)==g_vtid_UNINIT:
							//guilty
							//if DEBUG_DUMP_FLATTEN:
							//	Writeln('unflattenable (unresolved value): '+dumpExpr(pe,NULL)+" "+dumpExpr(pecaller,NULL))
							//assert(0)
							errorAtExpr(ETYPE_LOW_LEVEL_ERROR,pe_value,"unresolved expression '@1'".Replace(["@1",citeexpr(pe_value)]))
							setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
							t=getVariableType(pobj_var)
							if t:unflattenable_types.push(t)
				return 0
			if isBuiltin(pecaller,g_id_store):
				if readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
					is_write=1
				else
					assert(readPool(pecaller+EXPR_OFS_ARGS+1)==pe)
					is_write=0
				if tisrealclass(t):
					//for classes... ass = reference, only one new is allowed
					//VAR_USER_GOT_NEW
					if is_write:
						pe_value=readPool(pecaller+EXPR_OFS_ARGS+1)
						if isExpr(pe_value,EFLAG_FCALL)&&getExprValueAs(readPool(pe_value+EXPR_OFS_FUNCTION),g_vtid_CTVAL)==t:
							if testUserFlag(pobj_var,VAR_USER_GOT_NEW):
								if DEBUG_DUMP_FLATTEN:
									Writeln('unflattenable (multiple new): '+dumpExpr(pe,NULL))
								setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
							else
								setUserFlag(pobj_var,VAR_USER_GOT_NEW)
						else
							if DEBUG_DUMP_FLATTEN:
								Writeln('unflattenable (not newed): '+dumpExpr(pe,NULL))
							setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
					else
						if DEBUG_DUMP_FLATTEN:
							Writeln('unflattenable (class referenced): '+dumpExpr(pe,NULL))
						setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
				else
					//for structs, it's ok to ass to anything else... where we need to default up the non-flattened - store the flattened back and do the ass as is
					//only elim the ctor call for the trivialest structs - float3
					//deadelim should get rid of it... questionable
					if is_write:
						//do not flatten force-cast pointers - they are usually __memory
						//neither should we flatten dots - they are in the middle of some other object
						//unless we're in symderiv
						pe_value=readPool(pecaller+EXPR_OFS_ARGS+1)
						if isBuiltin(pe_value,g_id_cast):
							if DEBUG_DUMP_FLATTEN:
								Writeln('unflattenable (memory struct): '+dumpExpr(pe,NULL))
							setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
						if isBuiltin(pe_value,g_id_dot):
							for(;;)
								if (getFFlag(pf_owner)&FFLAG_IS_SYMDERIV_TEMP):
									pe_dot_object=readPool(pe_value+EXPR_OFS_ARGS+0)
									if isExpr(pe_dot_object,EFLAG_VARIABLE):
										pv_dot_object=getVariable(pe_dot_object)
										if testUserFlag(pv_dot_object,VAR_FLAG_PARAM):
											//we can flatten members of symderiv's param
											break
								if DEBUG_DUMP_FLATTEN:
									Writeln('unflattenable (member of another class): '+dumpExpr(pe,NULL))
								setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
								break
				return 0
			if isBuiltin(pecaller,g_id_stdot)&&readPool(pecaller+EXPR_OFS_ARGS+2)==pe&&tisstruct(t):
				//struct stdot copy is fine
				return 0
			if isBuiltin(pecaller,g_id_typeof)||isBuiltin(pecaller,g_id_has_member):
				//typeof/has_member are fine
				return 0
			if DEBUG_DUMP_FLATTEN:
				Writeln('unflattenable (unrecognized function): '+dumpExpr(pe,NULL)+" "+dumpExpr(pecaller,NULL))
			setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
		else
			if !testUserFlag(pe,QUEUE_FLAG_REACH):
				if g_has_untranslated_cdf&&!isBuiltin(readPool(pe+EXPR_OFS_CALLER),g_id_function):
					//there is cdf left
					//we cannot skip unreached ifs / unrecognized functions - they can get reached after we translate the CDF!
					//but that doesn't apply to function overloading... hacky
				else
					return 0
			if isBuiltin(pe,g_id_function):
				//don't flatten a return value
				pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
				if getFFlag(pobjfn)&FFLAG_IS_SYMDERIV_TEMP:
					//deriv dup, it's OK
					return 1
				pv_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
				//Writeln('pv_return: ',dumpObject(pv_return))
				setUserFlag(pv_return,VAR_USER_UNFLATTENABLE)
			else if isBuiltin(pe,g_id_assert_ctval):
				//ignore assert_ctval
				return 0
		return 1
	}
	dfsExprEx(pe_top,0,fmark_flattability)
	//////////////
	//re-mark the unflattenable types
	unflattenable_types.Sort()
	unflattenable_types.Unique()
	if unflattenable_types.n:
		foreach t in unflattenable_types
			setFFlag(t,FFLAG_TEMP_UNFLATTENABLE)
		fmark_flattability_from_types=function(PExpression pe){
			if isExpr(pe,EFLAG_VARIABLE):
				pobj_var=getVariable(pe)
				if testUserFlag(pobj_var,VAR_USER_UNFLATTENABLE):
					return 0
				if readPool(pobj_var)==g_vtid_RTVAR:
					assert(tisclass(readPool(pobj_var+1)))
					if getFFlag(readPool(pobj_var+1))&FFLAG_TEMP_UNFLATTENABLE:
						setUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)
			return 1
		}
		dfsExpr(pe_top,fmark_flattability_from_types)
		foreach t in unflattenable_types
			writePool(t+FUNCTION_OFS_FLAGS,readPool(t+FUNCTION_OFS_FLAGS)&~FFLAG_TEMP_UNFLATTENABLE)
	//tend(tm_flatten_step0)
	//actually flatten the stuff
	//flattened_items=new int2[]
	if DEBUG_DUMP_FLATTEN:
		//Writeln(g_ctobject_pool.n)
		Writeln(">>> before flatten\n"+dumpExpr(pe_top,fcolor_reach_eval))
	//struct TFlattenedMember
	//	PCTObject pobj_var
	//	PCTObject t
	//all_flattened_members=new TFlattenedMember[]
	n_replaced=0
	auto getFlattenedVariable(PCTObject pobj_var,PCTObject pobj_member,int is_write)
		pobj_ret=readGlobalI2Hash(int2(pobj_var,pobj_member))
		if !pobj_ret:
			pobj_ret=makevar(readPool(pobj_var+VAR_OFS_OWNER))
			setUserFlag(pobj_ret,VAR_USER_UNFLATTENABLE)
			writePool(pobj_ret+VAR_OFS_FLATTENING_OWNER,pobj_var)
			if g_readable_c_code:
				id_obj=readPool(pobj_var+VAR_OFS_ID)
				id_child=readPool(pobj_member+VAR_OFS_ID)
				if id_obj:
					id_child=catid(id_obj,catid(getid("."),id_child))
				writePool(pobj_ret+VAR_OFS_ID,id_child)
			//flattened_items.push(int2(pobj_var,pobj_member))
			writeGlobalI2Hash(int2(pobj_var,pobj_member),pobj_ret)
			writeGlobalI2Hash(int2(pobj_var,0),1)
			if DEBUG_DUMP_FLATTEN:
				Writeln('flatten: ',dumpObject(pobj_var),'.',getIdString(readPool(pobj_member+VAR_OFS_ID)),' ',pobj_ret)
				//pobj_member=lookupFunctionVariable(getVariableType(pobj_var),id_member)
				assert(isVariable(pobj_member))
			n_replaced++
			//rtvar-ify for nested structs - needed in copy
			//assert(readPool(pobj_member)==g_vtid_RTVAR)
			if readPool(pobj_member)==g_vtid_RTVAR:
				t=readPool(pobj_member+1)
				if tisstruct(t):
					//we need to set the type - no one sets it *for* us before it's needed
					//well, we must generate one - using transformCode?
					//it's defined during the memcpies
					//pe_parent_definition=readPool(pobj_var+VAR_OFS_DEFINING_STORE)
					//assert(!!pe_parent_definition)
					//pe_my_definition=call(g_id_store,exprvar(pobj_ret),indcall([exprctval(t)]))
					//transformCode(pe_parent_definition,NULL, [pe_my_definition],0,NULL)
					//writePool(pobj_ret+VAR_OFS_DEFINING_STORE,pe_my_definition)
					///////
					writePool(pobj_ret+0,g_vtid_RTVAR)
					writePool(pobj_ret+1,t)
					setUserFlag(pobj_ret,VAR_FLAG_FLATTENED_STRUCT_MEMBER)
			//all_flattened_members.push(TFlattenedMember(){'pobj_var':pobj_ret;'t':t})
		if is_write:
			setUserFlag(pobj_ret,VAR_USER_FLATTENED_VAR_IS_WRITTEN)
		return pobj_ret
	//tbegin(tm_flatten_step1)
	empty_news=new PExpression[]
	need_renaming=0
	rename_map=new PCTObject[PCTObject]
	fflatten_struct_variables=function(PExpression pe0){
		pe=pe0
		if !testUserFlag(pe,QUEUE_FLAG_REACH):
			if !isExpr(pe,EFLAG_VARIABLE):return 0
		if isBuiltin(pe,g_id_dot)||isBuiltin(pe,g_id_stdot):
			//this has to be tested before the memcpy stdot branch
			//Writeln("dot detected: "+dumpExpr(pe,fcolor_abbrv_blocks))
			pe_object=readPool(pe+EXPR_OFS_ARGS+0)
			if isExpr(pe_object,EFLAG_VARIABLE):
				pobj_var=getVariable(pe_object)
				assert(pobj_var)
				if !testUserFlag(pobj_var,VAR_USER_UNFLATTENABLE):
					//we reached something flattenable
					if isBuiltin(pe,g_id_dot)&&getExprValue(pe).tid!=g_vtid_RTVAR:
						//ignore constants
						return 1
					pobj_member=getDotMember(pe,0)//getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
					if pobj_member:
						assert(isVariable(pobj_member))
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						//Writeln("dot replaced: "+dumpExpr(pe,fcolor_abbrv_blocks))
						is_write=isBuiltin(pe,g_id_stdot)
						is_class_owned=(!tisstruct(readPool(pobj_var+1)))
						pobj_ret=getFlattenedVariable(pobj_var,pobj_member,is_write)
						//check for store(ptr,dot(nested,"member"))
						t=getVariableType(pobj_member)
						if !is_write&&tisstruct(t):
							if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+1)==pe:
								//bingo
								pe_store_target=readPool(pecaller+EXPR_OFS_ARGS+0)
								pobj_var_target=getVariable(pe_store_target)
								need_renaming=1
								rename_map[pobj_var_target]=pobj_ret
								if DEBUG_DUMP_FLATTEN:
									Writeln('make into renaming: ',dumpExpr(pecaller,NULL))
								setnop(pecaller)
								return 0
						//flatten it
						if is_class_owned:
							//class member, keep the original write
							if is_write:
								transformCode(pe,NULL, NULL,call(g_id_store,exprvar(pobj_ret),readPool(pe+EXPR_OFS_ARGS+2)),[call(g_id_stdot,exprvar(pobj_var),exprctval(pobj_member),exprvar(pobj_ret))])
							else
								transformCode(pe,NULL, NULL,exprvar(pobj_ret),[call(g_id_dummy_use,exprvar(pobj_var))])
						else
							if is_write:
								freplacer=function(){return call(g_id_store,exprvar(pobj_ret),readPool(pe+EXPR_OFS_ARGS+2))}
							else
								freplacer=function(){return exprvar(pobj_ret)}
							pe=sccpQueueReach(insertCallAt(pecaller,pe,freplacer))
						//we need to continue processing for nested flattens
		if isBuiltin(pe,g_id_store)||isBuiltin(pe,g_id_stdot):
			if isBuiltin(pe,g_id_stdot):
				pe_var=0
				pe_value=readPool(pe+EXPR_OFS_ARGS+2)
				pobj_tar=0
			else
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				pe_value=readPool(pe+EXPR_OFS_ARGS+1)
				pobj_tar=getVariable(pe_var)
			pobj_src=(isExpr(pe_value,EFLAG_VARIABLE)?getVariable(pe_value):0)
			if pobj_tar&&!testUserFlag(pobj_tar,VAR_USER_UNFLATTENABLE)||pobj_src&&!testUserFlag(pobj_src,VAR_USER_UNFLATTENABLE):
				//need to translate this store
				if !testUserFlag(pobj_tar,VAR_USER_UNFLATTENABLE):
					//if readPool(pobj_tar)!=g_vtid_RTVAR:
					//	Writeln("!!! "+dumpExpr(pe,NULL))
					assert(readPool(pobj_tar)==g_vtid_RTVAR)
					t_tar=readPool(pobj_tar+1)
					//Writeln(dumpExpr(pe,fcolor_abbrv_blocks))
					if pobj_src&&!testUserFlag(pobj_src,VAR_USER_UNFLATTENABLE):
						//both ends are flattened... trade the appeared member set in another pass... or just copy the full set of members
						//enumMembers
						assert(readPool(pobj_src)==g_vtid_RTVAR)
						t_src=readPool(pobj_src+1)
						if DEBUG_DUMP_FLATTEN:
							Writeln('flat-memcpy(both): ',dumpExpr(pe,NULL),' ',t_tar,' ',dumpType(t_tar),' ',t_src,' ',dumpType(t_src))
						if t_src!=t_tar:
							//error, ignore it
							return 1
						assert(tisstruct(t_src))
						enableNameLookup(t_tar)
						p_members=readPool(t_tar+FUNCTION_OFS_PMEMBER_LIST)
						n_members=readPool(t_tar+FUNCTION_OFS_NMEMBER_LIST)
						as=new PExpression[]
						for i=0:n_members-1
							id_member=readPool(p_members+i)
							if id_member==g_id_this||id_member==g_id_return:continue
							pobj_member=lookupFunctionVariable(t_tar,id_member)
							if DEBUG_DUMP_FLATTEN:
								Writeln('  ',getIdString(id_member),' ',getIdString(readPool(pobj_member)))
							//assert(readPool(pobj_member)!=g_vtid_UNINIT)
							//need to flatten uninit for symderiv
							vtid=readPool(pobj_member)
							if vtid!=g_vtid_RTVAR:continue//&&vtid!=g_vtid_UNINIT
							pv_tar=getFlattenedVariable(pobj_tar,pobj_member,1)
							pe_cpy=call(g_id_store,exprvar(pv_tar),exprvar(getFlattenedVariable(pobj_src,pobj_member,0)))
							//if !readPool(pv_tar+VAR_OFS_DEFINING_STORE):
							//	writePool(pv_tar+VAR_OFS_DEFINING_STORE,pe_cpy)
							as.push(pe_cpy)
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						sccpQueueReach(insertCallAt(pecaller,pe,function(){return vcall(g_id_block,as)}))
					else
						if isExpr(pe_value,EFLAG_FCALL)&&getExprFunction(pe_value)==t_tar:
							//Writeln(FormatAsText('new ',dumpExpr(pe,fcolor_abbrv_blocks)))
							//a new - is it empty? mark using a user flag
							assert(tisstruct(t_tar)||tisrealclass(t_tar))
							pe_decl_t_tar=readPool(t_tar+FUNCTION_OFS_PEDECL)
							if !testUserFlag(pe_decl_t_tar,USER_FLAG_EMPTY_NEW_TESTED):
								//test for empty new
								pvret_t_tar=readPool(t_tar+FUNCTION_OFS_PVAR_RETURN)
								is_empty=1
								f_test_emptiness=function(PExpression pe){
									if isExpr(pe,EFLAG_FCALL):
										if isBuiltin(pe,g_id_block):return 1
										if isBuiltin(pe,g_id_nop):return 0
										//only allow zero-valued stores and the standard getcontext / return
										//and methods
										//do not recurse into valid stores
										if !isBuiltin(pe,g_id_store):
											if DEBUG_DUMP_FLATTEN:
												if is_empty:
													Writeln(dumpObject(t_tar)+' not empty: '+dumpExpr(pe,fcolor_abbrv_blocks))
											is_empty=0
											return 0
										auto pe_var=readPool(pe+EXPR_OFS_ARGS+0)
										auto pe_value=readPool(pe+EXPR_OFS_ARGS+1)
										if isBuiltin(pe_value,g_id_get_lambda_context):return 0
										if readPool(pe_var)==EFLAG_VARIABLE+pvret_t_tar:return 0
										var_value=getExprValue(pe_var)
										if var_value.tid!=g_vtid_RTVAR:
											//not a real member, ignore
											return 0
										val_value=getExprValue(pe_value)
										if isValueZero(val_value)||isBuiltin(pe_value,g_id_uninit):
											//zero valued
											return 0
										is_empty=0
										if DEBUG_DUMP_FLATTEN:
											if is_empty:
												Writeln(dumpObject(t_tar)+' not empty: '+dumpExpr(pe,fcolor_abbrv_blocks))
									return is_empty
								}
								dfsExpr(readPool(t_tar+FUNCTION_OFS_CODE),f_test_emptiness)
								if is_empty:
									setUserFlag(pe_decl_t_tar,USER_FLAG_IS_EMPTY_NEW)
									if DEBUG_DUMP_FLATTEN:
										Writeln('ctor detected as empty: '+dumpObject(t_tar))
							if testUserFlag(pe_decl_t_tar,USER_FLAG_IS_EMPTY_NEW):
								//empty new indeed, do nothing, if turns out the var itself is eliminatable in the end, setnop in a next pass
								empty_news.push(pe)
								return 1
						else if isBuiltin(pe_value,g_id_uninit):
							//tuple-in-a-struct, get rid of it
							setnop(pe)
							return 1
						else
							//Writeln(FormatAsText('not-new ',getExprFunction(pe_value),' ',t_tar,' ',dumpExpr(pe,fcolor_abbrv_blocks)))
							if Platform.BUILD=="debug":
								//if !tisstruct(t_tar):
								if !tisclass(t_tar):
									Writeln(dumpExpr(pe,fcolor_abbrv_blocks))
							//assert(tisstruct(t_tar))
							assert(tisclass(t_tar))
						if DEBUG_DUMP_FLATTEN:
							Writeln('flat-memcpy(tar-only): ',dumpExpr(pe,NULL))
						//read back from tar after the store, also, tar itself can no longer be eliminated
						//we could get a class new here
						setUserFlag(pobj_tar,VAR_USER_KEEP_ORIGINAL)
						if DEBUG_DUMP_FLATTEN:
							Writeln(FormatAsText('keep-original ',dumpExpr(pe,fcolor_abbrv_blocks)))
						as=new PExpression[]
						//Writeln(dumpObject(t_tar))
						enableNameLookup(t_tar)
						p_members=readPool(t_tar+FUNCTION_OFS_PMEMBER_LIST)
						n_members=readPool(t_tar+FUNCTION_OFS_NMEMBER_LIST)
						for i=0:n_members-1
							id_member=readPool(p_members+i)
							if id_member==g_id_this||id_member==g_id_return:continue
							pobj_member=lookupFunctionVariable(t_tar,id_member)
							if DEBUG_DUMP_FLATTEN:
								Writeln('  ',getIdString(id_member),' ',getIdString(readPool(pobj_member)))
							//need to flatten uninit for symderiv
							vtid=readPool(pobj_member)
							if vtid!=g_vtid_RTVAR:continue//&&vtid!=g_vtid_UNINIT
							pv_tar=getFlattenedVariable(pobj_tar,pobj_member,1)
							pe_cpy=call(g_id_store,exprvar(pv_tar),call(g_id_dot,exprvar(pobj_tar),exprctval(pobj_member)))
							//if !readPool(pv_tar+VAR_OFS_DEFINING_STORE):
							//	writePool(pv_tar+VAR_OFS_DEFINING_STORE,pe_cpy)
							as.push(pe_cpy)
						transformCode(pe,NULL, NULL,0,as)
				else
					t_src=readPool(pobj_src+1)
					assert(tisstruct(t_src))
					if DEBUG_DUMP_FLATTEN:
						Writeln('flat-memcpy(src-only): ',dumpExpr(pe,NULL),' ',dumpType(t_src))
					//directly write to tar
					as=new PExpression[]
					if isBuiltin(pe,g_id_stdot):
						//tempify and generate pe_var
						pv_temp=makevar(readPool(pobj_src+VAR_OFS_OWNER))
						as.push(call(g_id_store,exprvar(pv_temp),call(g_id_dot,readPool(pe+EXPR_OFS_ARGS+0),readPool(pe+EXPR_OFS_ARGS+1))))
						writePool(pv_temp+VAR_OFS_DEFINING_STORE,as.back())
					else
						pv_temp=pobj_tar
					enableNameLookup(t_src)
					p_members=readPool(t_src+FUNCTION_OFS_PMEMBER_LIST)
					n_members=readPool(t_src+FUNCTION_OFS_NMEMBER_LIST)
					for i=0:n_members-1
						id_member=readPool(p_members+i)
						if id_member==g_id_this||id_member==g_id_return:continue
						pobj_member=lookupFunctionVariable(t_src,id_member)
						if DEBUG_DUMP_FLATTEN:
							Writeln('  ',getIdString(id_member),' ',getIdString(readPool(pobj_member)))
						vtid=readPool(pobj_member)
						if vtid!=g_vtid_RTVAR:continue
						as.push(call(g_id_stdot,exprvar(pv_temp),exprctval(pobj_member),exprvar(getFlattenedVariable(pobj_src,pobj_member,0))))
					transformCode(pe,NULL, as,expriptr(0),NULL)
		else if isBuiltin(pe,g_id_assert_ctval):
			//ignore assert_ctval
			return 0
		else if isBuiltin(pe,g_id_typeof)||isBuiltin(pe,g_id_has_member):
			val=getExprValue(pe)
			if val.tid==g_vtid_CTVAL||val.tid==g_vtid_CNS:
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				if isExpr(pe_var,EFLAG_VARIABLE):
					pobj_var=getVariable(pe_var)
					if pobj_var&&!testUserFlag(pobj_var,VAR_USER_UNFLATTENABLE)&&readPool(pobj_var)==g_vtid_RTVAR&&tisstruct(readPool(pobj_var+1)):
						//the meta stuff should be made constant if the variable is about to disappear
						pesubstitute=poolCode(TCnsExpression(){'flags_cid':val.val+((val.tid==g_vtid_CNS)?EFLAG_CONST:EFLAG_CTVAL)})
						transformCode(pe,NULL, NULL,pesubstitute,NULL)
						return 0
		return 1
	}
	dfsExpr(pe_top,fflatten_struct_variables)
	//tend(tm_flatten_step1)
	//rename ptr to flattened members
	if need_renaming:
		frename_vars=function(PExpression pe){
			if isExpr(pe,EFLAG_VARIABLE):
				pv0=getVariable(pe)
				pv1=rename_map[pv0]
				if pv1:
					writePool(pe,EFLAG_VARIABLE+pv1)
			return 1
		}
		dfsExpr(pe_top,frename_vars)
	if DEBUG_DUMP_FLATTEN:
		//Writeln(g_ctobject_pool.n)
		Writeln(">>> after flatten\n"+dumpExpr(pe_top,NULL))
	//expand the monitored variable lists
	//tbegin(tm_flatten_step2)
	if monitoring_base:
		//foreach pv_list,pe_key in g_strflatten_monitored_variables
		for pe_key=monitoring_base+0:monitoring_base+1
			pv_list=g_strflatten_monitored_variables[pe_key]
			pv_list2=new PCTObject[]
			did=0
			foreach pobj_src in pv_list
				if DEBUG_DUMP_FLATTEN:
					Writeln('monitoring ',pobj_src,' ',testUserFlag(pobj_src,VAR_USER_UNFLATTENABLE))
				if testUserFlag(pobj_src,VAR_USER_UNFLATTENABLE):
					pv_list2.push(pobj_src)
				else
					t_src=getVariableType(pobj_src)
					if !tisclass(t_src):continue
					enableNameLookup(t_src)
					p_members=readPool(t_src+FUNCTION_OFS_PMEMBER_LIST)
					n_members=readPool(t_src+FUNCTION_OFS_NMEMBER_LIST)
					for i=0:n_members-1
						id_member=readPool(p_members+i)
						//if DEBUG_DUMP_FLATTEN:
						//	Writeln('  ',getIdString(id_member))
						if id_member==g_id_this||id_member==g_id_return:continue
						pobj_member=lookupFunctionVariable(t_src,id_member)
						//if DEBUG_DUMP_FLATTEN:
						//	Writeln('  ',dumpObject(pobj_member))
						//need to flatten uninit for symderiv
						vtid=readPool(pobj_member)
						if vtid!=g_vtid_RTVAR:continue//&&vtid!=g_vtid_UNINIT
						pv_list2.push(getFlattenedVariable(pobj_src,pobj_member,0))
					did=1
			if did:
				if DEBUG_DUMP_FLATTEN:
					Writeln('expanded g_strflatten_monitored_variables[',pe_key,']=',pv_list2)
				g_strflatten_monitored_variables[pe_key]=pv_list2
			else
				if DEBUG_DUMP_FLATTEN:
					Writeln('unchanged g_strflatten_monitored_variables[',pe_key,']=',pv_list)
	//reeval the flatten-waiters
	//foreach pe in g_strflatten_eval_queue
	//	sccpQueueEval(pe)
	//g_strflatten_eval_queue.clear()
	//eliminate empty news
	foreach pe in empty_news
		assert(isBuiltin(pe,g_id_store))
		pe_var=readPool(pe+EXPR_OFS_ARGS+0)
		pobj_tar=getVariable(pe_var)
		if !testUserFlag(pobj_tar,VAR_USER_KEEP_ORIGINAL):
			if DEBUG_DUMP_FLATTEN:
				Writeln(FormatAsText('remove-new ',dumpExpr(pe,fcolor_abbrv_blocks)))
			pe_value=readPool(pe+EXPR_OFS_ARGS+1)
			pe_func=readPool(pe_value+EXPR_OFS_FUNCTION)
			//zero out the members and setnop the ctor
			assert(readPool(pobj_tar)==g_vtid_RTVAR)
			t_tar=readPool(pobj_tar+1)
			p_members=readPool(t_tar+FUNCTION_OFS_PMEMBER_LIST)
			n_members=readPool(t_tar+FUNCTION_OFS_NMEMBER_LIST)
			as=new PExpression[]
			for i=0:n_members-1
				id_member=readPool(p_members+i)
				if id_member==g_id_this||id_member==g_id_return:continue
				pobj_member=lookupFunctionVariable(t_tar,id_member)
				vtid=readPool(pobj_member)
				if vtid!=g_vtid_RTVAR:continue
				pobj_flattened=getFlattenedVariable(pobj_tar,pobj_member,0)
				if !testUserFlag(pobj_flattened,VAR_USER_FLATTENED_VAR_IS_WRITTEN)&&readPool(pobj_member)==g_vtid_RTVAR:
					//zero it out
					t_member=readPool(pobj_member+1)
					if tisbuiltin(t_member):
						cid=getid_const(readPool(t_member+1),0LL)
					else
						cid=getid_const(CTYPE_TYPED_NULL,t_member)
					as.push(call(g_id_store,exprvar(pobj_flattened),exprcns(cid)))
					//Writeln('zero out, cid=',cid,' type=',t_member,':',dumpType(t_member),' ',getBuiltinType(const_type(CTYPE_FLOAT,64)),' ',dumpExpr(as.back(),NULL))
			if isBuiltin(pe_func,g_id_function):
				//it's a tuple construction, keep the function BUT STILL ZERO OUT THE MEMBERS
				//pecaller=readPool(pe+EXPR_OFS_CALLER)
				//sccpQueueReach(insertCallAt(pecaller,pe,function(){return pe_func}))
				transformCode(pe,NULL, as,pe_func,NULL)
			else
				transformCode(pe,NULL, as,0,NULL)
				setnop(pe)
		else
			if DEBUG_DUMP_FLATTEN:
				Writeln(FormatAsText('kept ',dumpExpr(pe,fcolor_abbrv_blocks)))
	//tend(tm_flatten_step2)
	//tbegin(tm_flatten_step3)
	clearUserFlags(pe_top,0)
	//tend(tm_flatten_step3)
	return n_replaced

auto structCnsToVar(PExpression pecall,PCTObject[] var_list_ret)
	foreach pobj_var in var_list_ret
		t=getVariableType(pobj_var)
		if tisstruct(t):
			varifyDblMembers(pecall,t)

auto localflatten(PExpression pecall,PCTObject pobjfn_dup)
	var_list_ret=g_strflatten_monitored_variables[pecall+0]
	var_list_params=g_strflatten_monitored_variables[pecall+1]
	structCnsToVar(pecall,var_list_ret)
	structCnsToVar(pecall,var_list_params)
	sccp(0)//structCnsToVar invalidates sccp, we need to reeval before the real flattening
	return strflatten(readPool(pobjfn_dup+FUNCTION_OFS_PEDECL), pecall)

tm_sccp=tnew(":sccp")
tm_sccp2=tnew(":sccp2")
auto grandsccp()
	tbegin(tm_sccp)
	if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' 1st SCCP: ')}
	sccp(g_pe_top)
	if DEBUG_DUMP_PASSES:{Writeln('done')}
	for(;;)
		if DEBUG_DUMP_FLATTEN||DEBUG_EVAL_LOG||DEBUG_DUMP_SCCP:
			Writeln('>>> after one sccp pass')
			Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
		if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' CDF: ')}
		evalCodeDependingFunctions()
		if DEBUG_DUMP_PASSES:{if g_has_untranslated_cdf:{Writeln('[TRY AGAIN]');}else{Writeln('done');}}
		if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' more SCCP: ')}
		sccp(0)
		if DEBUG_DUMP_PASSES:{Writeln('done')}
		if !g_has_untranslated_cdf:break
	if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' fixConstantTypes: ')}
	fixConstantTypes()
	if DEBUG_DUMP_PASSES:{Writeln('done')}
	if g_enable_dump:
		Writeln('>>> after fixing constant types')
		Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
	tend(tm_sccp)
	tbegin(tm_sccp2)
	////////////////////////////
	//we reached the final code
	for(;;)
		did=0
		tbegin(tm_strflatten)
		if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' strflatten: ')}
		if strflatten(g_pe_top,0):
			did=1
			sccp(0)
			if DEBUG_DUMP_PASSES:{Writeln('[WORKED]')}
		else
			if DEBUG_DUMP_PASSES:{Writeln('dry fire')}
		tend(tm_strflatten)
		if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' SSA-GVN: ')}
		if partialSSAGVN(g_pe_top,0,1):
			did=1
			sccp(0)
			if DEBUG_DUMP_PASSES:{Writeln('[WORKED]')}
		else
			if DEBUG_DUMP_PASSES:{Writeln('dry fire')}
		if DEBUG_DUMP_FLATTEN||DEBUG_EVAL_LOG:
			Writeln('>>> after one flatten / deadelim / ssa iteration')
			Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
		if ENABLE_DEADELIM:
			if DEBUG_DUMP_PASSES:{Write(string(System.Time.t,2),' deadelim: ')}
			if deadelim():
				did=1
				sccp(0)
				//cleaning up the nop is *worth* it
				g_pe_top=dfsFlattenBlocks(NULL,g_pe_top,0,0)
				if DEBUG_DUMP_PASSES:{Writeln('[WORKED]')}
			else
				if DEBUG_DUMP_PASSES:{Writeln('dry fire')}
		if !did:break
	tend(tm_sccp2)

auto isSSAStatementHost(PExpression pe)
	if !isStatementHost(pe):
		return 0
	else if isBuiltin(pe,g_id_blockex):
		id_word=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_STR)
		if id_word!=g_id_for:
			//not a loop, not statement host
			return 0
	else if isBuiltin(pe,g_id_if):
		val=getExprValue(readPool(pe+EXPR_OFS_ARGS+0))
		if val.tid==g_vtid_CNS:
			//const if, ignore it
			return 0
	else
		return 1
	
auto fcolor_ssa(PExpression pe)
	//val=getExprValue(pe)
	//if val.tid==g_vtid_UNINIT:
	//	if !testUserFlag(pe,QUEUE_FLAG_REACH):
	//		if isExpr(pe,EFLAG_FCALL)&&!isBuiltin(pe,g_id_ldparam):
	//			return -2
	//		else
	//			return -1
	//	if isBuiltin(pe,g_id_block):return -1
	//	return -1
	if isExpr(pe,EFLAG_FCALL)&&isSSAStatementHost(pe):
		return -2
	else
		return -1

//////////////////////////////////////
struct TGVNValue
	//function, a, b
	int3 key
	PCTObject pv_backing
	int epos
class TTraitGVNValue
	TKey=int3
	inline getHash(int id)
		key=g_gvn_values[id].key
		return iptr(key.x^key.y^(key.z<<8))
	inline computeHash(int3 key)
		return iptr(key.x^key.y^(key.z<<8))
	inline isKeyEqual(int id,int3 key)
		key0=g_gvn_values[id].key
		return key0.x==key.x&&key0.y==key.y&&key0.z==key.z
	inline createNew(int3 key,iptr hash)
		key2=TGVNValue(){'key':key}
		ret=int(g_gvn_values.n)
		g_gvn_values.push(key2)
		//g_gvn_backing_var.push(0)
		//assert(g_gvn_backing_var.n==g_gvn_values.n)
		return ret

g_gvn_values=[TGVNValue()]
g_gvn_unique=new CUniqueIDProvider(TTraitGVNValue)
//g_gvn_backing_var=new int[1]

inline get_gvn_id(int3 key,int epos)
	ret=g_gvn_unique._find(1,key)
	if ret==int(g_gvn_values.n-1):
		g_gvn_values.back().epos=epos
	return int(ret)

inline test_gvn_id(int3 key)
	return int(g_gvn_unique._find(0,key))

//should have deadelim before this pass? or after - we could reuse some dead...
//then we'll need single-use remat for ANM? benefit only comes from linear coalescing

auto partialSSAGVN(PExpression pe_top,int aggressive_linear_coalescing,int is_global)
	FLAG_SSA_RENAMED=USER_FLAG_ACTIVATED
	did=0
	sccp(0)
	//label the non-ssa-friendly - those accessed in another function
	//conservative renaming... loops, phi it? ignore phi-ed values
	//our goal: strength reduction, live range separation
	//build and flatten back, only merging phi cliques? copyprop...
	//phi rollback - after SSA, rename phi's relevant asses (ignoring copyprop) to the phi target
	//only if the phi is used
	//just do the basic block thing - split basic blocks first
	//if DEBUG_DUMP_SSA:
	//	Writeln('=== before SSA\n',dumpExpr(pe_top,fcolor_ssa))
	clearUserFlags(pe_top,0)
	all_bbs=new PExpression[]
	auto fcreatebb(PExpression pe,int block_id)
		if isExpr(pe,EFLAG_VARIABLE):
			//set var block id
			pobj_var=getVariable(pe)
			flag0=readPool(pobj_var+VAR_OFS_USER_FLAGS)
			block_id_old=(flag0&USER_FLAG_MASK)
			block_id_write=block_id+1
			if block_id_old&&block_id_old!=block_id_write||block_id==-1||readPool(pobj_var)!=g_vtid_RTVAR||tisstruct(readPool(pobj_var+1)):
				block_id_write=USER_FLAG_MASK
			else
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if pecaller&&isBuiltin(pecaller,g_id_aliased)||readPool(pobj_var)==g_vtid_RTVAR&&tisclass(pobj_var+1):
					//don't mess with the aliased! or class/struct!
					block_id_write=USER_FLAG_MASK
			writePool(pobj_var+VAR_OFS_USER_FLAGS,(flag0&~USER_FLAG_MASK)|block_id_write)
			return
		if !testUserFlag(pe,QUEUE_FLAG_REACH):return
		if isExpr(pe,EFLAG_FCALL):
			block_id_recurse=block_id
			if isBuiltin(pe,g_id_block):
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if !pecaller||isSSAStatementHost(pecaller):
					all_bbs.push(pe)
					block_id_recurse=int(all_bbs.n-1)
					if pecaller&&isBuiltin(pecaller,g_id_function):
						pobjfn=getExprValueAs(pecaller,g_vtid_CTVAL)
						id_ccnv=getCcnv(pobjfn)
						if id_ccnv==g_id_struct||id_ccnv==g_id_class:
							//not allowed
							all_bbs.pop()
							block_id_recurse=-1
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				fcreatebb(readPool(pe+EXPR_OFS_ARGS+i),block_id_recurse)
	fcreatebb(pe_top,-1)
	//////////////////////////////////////
	//give up gvn purity for now - call graph not ready yet
	//do it in deadelim
	//////////////////////////////////////
	//be conservative when coalescing unless we're in ANM -- we don't want to make it O(n^2)
	//only do it when the intermedates were left unused, or when we have aggressive_linear_coalescing
	//is it safe when there are breaks in the middle? should be, we're conservative about used-outside guys, and the fact we reached somewhere means it didn't break
	//g_gvn - hashed op + operand list, int pool, call graph pureness test when we have is_global, C function pureness labeling
	UNPREDICTABLE_VID_BASE=0x40000000
	g_unpredictable_values=new PExpression[]
	ssa_names=new TSSAName[]
	tentative_backing_gvnid=new int[PExpression]
	//is_different_from_code is made global on purpose - it's manipulated during recursion but only saved at impure-pure boundaries
	is_different_from_code=0
	is_referring_to_unpredictable=0
	pf_curblock=0
	p_newly_generated_point=0
	as_just_generated_cse=new PExpression[]
	removable_stores=new PExpression[]
	the_single_use=new PExpression[PCTObject]
	auto initGVN(PExpression pe)
		g_gvn_values.resize(1)
		g_gvn_unique.clear()
		g_unpredictable_values.clear()
		ssa_names.clear()
		tentative_backing_gvnid.clear()
		is_different_from_code=0
		is_referring_to_unpredictable=0
		pf_curblock=getOwningFunction(pe)
		removable_stores.clear()
		the_single_use.clear()
	inline make_unpredictable(PExpression pe)
		g_unpredictable_values.push(pe)
		return int(UNPREDICTABLE_VID_BASE+(g_unpredictable_values.n-1))
	struct TSSAName
		PCTObject pv_original
		PCTObject pv_current
		int gvn_id
	inline isCopyPropFriendlyExpr(PExpression pe_value)
		if isExpr(pe_value,EFLAG_VARIABLE):
			auto pobj_var=getVariable(pe_value)
			auto flag0=readPool(pobj_var+VAR_OFS_USER_FLAGS)
			auto bid=(flag0&USER_FLAG_MASK)
			if bid!=USER_FLAG_MASK&&bid&&(bid&FLAG_SSA_RENAMED):
				return 1
			else
				return 0
		else
			return 0
	auto isCopyPropFriendly(PExpression pe_value,int gvn_id_value)
		//avoid the source-ass problem by only allowing ssa -> ssa propagation
		if ENABLE_GVN:
			//use gvn_id as the test - SSA store creates "var-backed-ness"
			if gvn_id_value&UNPREDICTABLE_VID_BASE:
				return isCopyPropFriendlyExpr(g_unpredictable_values[gvn_id_value-UNPREDICTABLE_VID_BASE])
			else
				return g_gvn_values[gvn_id_value].pv_backing>0
		return isCopyPropFriendlyExpr(pe_value)
	auto getGvnVariable(PExpression pe,int gvn_id)
		if !ENABLE_GVN:
			return getVariable(pe)
		else
			if gvn_id&UNPREDICTABLE_VID_BASE:
				pobj_ret=getVariable(g_unpredictable_values[gvn_id-UNPREDICTABLE_VID_BASE])
				assert(!!pobj_ret)
				return pobj_ret
			else
				pobj_ret=g_gvn_values[gvn_id].pv_backing
				assert(pobj_ret>0)
				return pobj_ret
	auto gvn_generate(int gvn_id,int still_linear)
		if DEBUG_DUMP_SSA:
			Writeln('gvn_generate ',string.ToHex(gvn_id))
		if gvn_id&UNPREDICTABLE_VID_BASE:
			pe_ret=g_unpredictable_values[gvn_id-UNPREDICTABLE_VID_BASE]
			assert(!!pe_ret)
			if isExpr(pe_ret,EFLAG_VARIABLE):
				//variables can get dupped
				pe_ret=fillepos(exprvar(getVariable(pe_ret)),readPool(pe_ret+EXPR_OFS_EPOS),readPool(pe_ret+EXPR_OFS_EPOS+1))
				if DEBUG_DUMP_SSA:
					Writeln('  unpredictable var - ',dumpExpr(pe_ret,NULL))
				return pe_ret
			g_unpredictable_values[gvn_id-UNPREDICTABLE_VID_BASE]=0
			if DEBUG_DUMP_SSA:
				Writeln('  unpredictable - ',dumpExpr(pe_ret,NULL))
			return pe_ret
		else
			pobj_var=g_gvn_values[gvn_id].pv_backing
			//we may need a clone...
			//if aggressive_linear_coalescing:
			//	if still_linear:pobj_var=0
			if pobj_var<0:
				//CSE - already-generated-ness test
				pe_previous=(pobj_var&0x7fffffff)
				pobj_var=makevar(pf_curblock)
				if DEBUG_DUMP_SSA:
					Writeln('CSE: ',dumpExpr(readPool(pe_previous+EXPR_OFS_CALLER),NULL),' ',dumpObject(pobj_var))
				if pe_previous>=p_newly_generated_point:
					//just-generated code got CSEed, smash!
					if DEBUG_DUMP_SSA:
						Writeln('  handled locally')
					as_just_generated_cse.push(fillepos(call(g_id_store,exprvar(pobj_var),cloneExpr(pe_previous)),g_gvn_values[gvn_id].epos,-1))
					writePool(pe_previous,EFLAG_VARIABLE+pobj_var)
				else
					if DEBUG_DUMP_SSA:
						Writeln('  transformCode')
					transformCode(pe_previous,function(){return fillepos(call(g_id_store,exprvar(pobj_var),pe_previous),g_gvn_values[gvn_id].epos,-1)}, NULL,exprvar(pobj_var),NULL)
				g_gvn_values[gvn_id].pv_backing=pobj_var
			if pobj_var:
				pe_ret=fillepos(exprvar(pobj_var),g_gvn_values[gvn_id].epos,-1)
				if DEBUG_DUMP_SSA:
					Writeln('  var - ',dumpExpr(pe_ret,NULL))
				return pe_ret
			gvn_key=g_gvn_values[gvn_id].key
			if gvn_key.x==g_fakectval_gvn_cns:
				pe_ret=exprcns(gvn_key.y)
			else if gvn_key.x==g_fakectval_gvn_str:
				pe_ret=exprstr(gvn_key.y)
			else
				if gvn_key.y==-1:
					args=new(g_ctunique_items[gvn_key.z].key)
					for i=1:args.n-1
						args[i]=gvn_generate(args[i],0)
				else
					still_linear_recurse=still_linear
					if still_linear_recurse:
						if !(gvnkeyIsBuiltin(gvn_key,g_id_operator_add)||gvnkeyIsBuiltin(gvn_key,g_id_operator_sub)):
							still_linear_recurse=0
						else if !gvn_key.y||!gvn_key.z:
							still_linear_recurse=0
					args=[0,gvn_key.y?gvn_generate(gvn_key.y,still_linear_recurse):0,gvn_key.z?gvn_generate(gvn_key.z,still_linear_recurse):0]
					if !gvn_key.z:args.n--
					if !gvn_key.y:args.n--
				args[0]=exprctval(gvn_key.x)
				//Writeln(args,' ',gvn_key,' ',dumpObject(gvn_key.x))
				pe_ret=indcall(args)
				//don't CSE constants - only do it here
				//we may have unwiped leftovers?
				if g_gvn_values[gvn_id].pv_backing<=0:
					g_gvn_values[gvn_id].pv_backing=0x80000000+pe_ret
			if DEBUG_DUMP_SSA:
				Writeln('  ',dumpExpr(pe_ret,NULL))
			return fillepos(pe_ret,g_gvn_values[gvn_id].epos,-1)
	auto solidifyTentativeBacking(PExpression pe)
		gvn_id=tentative_backing_gvnid[pe]
		if !gvn_id:return
		tentative_backing_gvnid[pe]=0
		if DEBUG_DUMP_SSA:
			if g_gvn_values[gvn_id].pv_backing==0x80000000+pe:
				//if !is_different_from_code:
				Writeln('solidify the tentative backing: ',gvn_id,' ',dumpExpr(pe,NULL))
		if isExpr(pe,EFLAG_FCALL):
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				wipeoutStaleBackingExpr(readPool(pe+EXPR_OFS_ARGS+i))
	auto wipeoutStaleBackingExpr(PExpression pe)
		gvn_id=tentative_backing_gvnid[pe]
		if !gvn_id:return
		tentative_backing_gvnid[pe]=0
		if g_gvn_values[gvn_id].pv_backing==0x80000000+pe:
			g_gvn_values[gvn_id].pv_backing=0
			if DEBUG_DUMP_SSA:
				//if !is_different_from_code:
				Writeln('wipe out the stale backing: ',gvn_id,' ',dumpExpr(pe,NULL))
		if isExpr(pe,EFLAG_FCALL):
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				wipeoutStaleBackingExpr(readPool(pe+EXPR_OFS_ARGS+i))
	auto gvn_replace(PExpression pe,int gvn_id)
		if !ENABLE_GVN:
			//nothing
		else
			//aggressive_linear_coalescing should disable that?
			if gvn_id&UNPREDICTABLE_VID_BASE:return
			if !isExpr(pe,EFLAG_FCALL):
				if isExpr(pe,EFLAG_VARIABLE)&&is_different_from_code:
					//variable renaming case
					//n0=g_ctobject_pool.n
					if DEBUG_DUMP_PASSES&&DEBUG_DUMP_GVN_DETAILS:{Writeln('>>> replace ',dumpExpr(pe,NULL))}
					p_newly_generated_point=int(g_ctobject_pool.n)
					as_just_generated_cse=new PExpression[]
					pe_replacement=gvn_generate(gvn_id,1)
					transformCode(pe,NULL, as_just_generated_cse,pe_replacement,NULL)
					if DEBUG_DUMP_PASSES&&DEBUG_DUMP_GVN_DETAILS:{Writeln('<<< into ',dumpExpr(pe_replacement,NULL))}
					did=1
					//else
					//	g_ctobject_pool'n':n0
				solidifyTentativeBacking(pe)
				return
			if !is_different_from_code:
				//value changed-ness test - can only be caused by peephole and ssa renaming, is_different_from_code
				solidifyTentativeBacking(pe)
				return
			//wipe out the backing vars first
			if DEBUG_DUMP_SSA:
				Writeln('gvn_replace ',dumpExpr(pe,NULL))
			if DEBUG_DUMP_PASSES&&DEBUG_DUMP_GVN_DETAILS:{if !did:Write(dumpExpr(pe,NULL),' -> ')}
			wipeoutStaleBackingExpr(pe)
			p_newly_generated_point=int(g_ctobject_pool.n)
			as_just_generated_cse=new PExpression[]
			pe_replacement=gvn_generate(gvn_id,1)
			transformCode(pe,NULL, as_just_generated_cse,pe_replacement,NULL)
			if DEBUG_DUMP_PASSES&&DEBUG_DUMP_GVN_DETAILS:{if !did:Write(dumpExpr(pe_replacement,NULL),' ')}
			did=1
	inline gvnkeyIsBuiltin(int3 gvn_key,int id)
		return gvn_key.x==getBuiltin(id)
	inline gvnIsBuiltin(int gvn_id,int id)
		if gvn_id&UNPREDICTABLE_VID_BASE:return 0
		gvn_key=g_gvn_values[gvn_id].key
		return gvn_key.x==getBuiltin(id)
	inline gvnIsCns(int gvn_id)
		if gvn_id&UNPREDICTABLE_VID_BASE:return 0
		gvn_key=g_gvn_values[gvn_id].key
		return gvn_key.x==g_fakectval_gvn_cns
	inline gvnIsZero(int gvn_id)
		if gvn_id&UNPREDICTABLE_VID_BASE:return 0
		gvn_key=g_gvn_values[gvn_id].key
		return gvn_key.x==g_fakectval_gvn_cns&&isConstZero(ctNumber(gvn_key.y))
	inline gvnIsOne(int gvn_id)
		if gvn_id&UNPREDICTABLE_VID_BASE:return 0
		gvn_key=g_gvn_values[gvn_id].key
		return gvn_key.x==g_fakectval_gvn_cns&&isConstOne(ctNumber(gvn_key.y))
	inline gvnIsNegOne(int gvn_id)
		if gvn_id&UNPREDICTABLE_VID_BASE:return 0
		gvn_key=g_gvn_values[gvn_id].key
		return gvn_key.x==g_fakectval_gvn_cns&&isConstNegOne(ctNumber(gvn_key.y))
	auto gvn_peephole(int3 gvn_key0,PExpression pe)
		n_args=getFCallNArgs(pe)
		gvn_key=gvn_key0
		pe_arg0=0
		pe_arg1=1
		if n_args>0:{pe_arg0=readPool(pe+EXPR_OFS_ARGS+0);gvn_key.y=bbssa(pe_arg0)}
		if n_args>1:{pe_arg1=readPool(pe+EXPR_OFS_ARGS+1);gvn_key.z=bbssa(pe_arg1)}
		epos=readPool(pe+EXPR_OFS_EPOS)
		if ENABLE_GVN:
			if pe_arg0:
				t=getExprType(pe_arg0)
				if t&&tisbuiltin(t):
					for(;;)
						//non-zero-and-predictable test
						if u32(gvn_key.y-1)<u32(UNPREDICTABLE_VID_BASE-1)&&u32(gvn_key.z)<u32(UNPREDICTABLE_VID_BASE-1):
							//Write('.')
							//linear merging: a+b*a, b*a+c*a
							if gvnkeyIsBuiltin(gvn_key,g_id_operator_add)||gvnkeyIsBuiltin(gvn_key,g_id_operator_sub):
								if DEBUG_DUMP_SSA:
									Writeln('test linear merging ',dumpExpr(pe,NULL))
								key_arg0=g_gvn_values[gvn_key.y].key
								if key_arg0.x==g_id_operator_mul&&key_arg0.y>0&&key_arg0.z>0&&gvnIsCns(key_arg0.z):
									tmp=key_arg0.y
									key_arg0.y=key_arg0.z
									key_arg0.z=tmp
								key_arg1=g_gvn_values[gvn_key.z].key
								if key_arg0.y==g_id_operator_mul&&key_arg1.y>0&&key_arg1.z>0&&gvnIsCns(key_arg1.z):
									tmp=key_arg1.y
									key_arg1.y=key_arg1.z
									key_arg1.z=tmp
								if key_arg0.x==g_id_operator_mul&&key_arg1.x==g_id_operator_mul&&key_arg1.z==key_arg0.z&&gvnIsCns(key_arg1.y)&&gvnIsCns(key_arg0.y):
									//b*a+c*a
									cb=ctNumber(g_gvn_values[key_arg0.y].key.y)
									cc=ctNumber(g_gvn_values[key_arg1.y].key.y)
									if cb.type==cc.type:
										if gvnkeyIsBuiltin(gvn_key,g_id_operator_add):
											if cb.type==const_type(CTYPE_FLOAT,32):
												cb.val_bin=i64(u32(__float_as_int((__int_as_float(int(cb.val_bin))+__int_as_float(int(cc.val_bin))))))
											else if cb.type==const_type(CTYPE_FLOAT,64):
												cb.val_bin=__double_as_longlong((__longlong_as_double(cb.val_bin)+__longlong_as_double(cc.val_bin)))
											else
												cb.val_bin+=cc.val_bin
										else
											if cb.type==const_type(CTYPE_FLOAT,32):
												cb.val_bin=i64(u32(__float_as_int((__int_as_float(int(cb.val_bin))-__int_as_float(int(cc.val_bin))))))
											else if cb.type==const_type(CTYPE_FLOAT,64):
												cb.val_bin=__double_as_longlong((__longlong_as_double(cb.val_bin)-__longlong_as_double(cc.val_bin)))
											else
												cb.val_bin-=cc.val_bin
										is_different_from_code=1
										gvn_key.x=getBuiltin(g_id_operator_mul)
										gvn_key.y=get_gvn_id(int3(g_fakectval_gvn_cns,getid_const(cb.type,cb.val_bin),0),epos)
										gvn_key.z=key_arg0.z
								else if key_arg1.x==g_id_operator_mul&&key_arg1.z==gvn_key.y&&gvnIsCns(key_arg1.y):
									//a+b*a
									cb=ctNumber(g_gvn_values[key_arg1.y].key.y)
									if gvnkeyIsBuiltin(gvn_key,g_id_operator_add):
										if cb.type==const_type(CTYPE_FLOAT,32):
											cb.val_bin=i64(u32(__float_as_int((1.0f+__int_as_float(int(cb.val_bin))))))
										else if cb.type==const_type(CTYPE_FLOAT,64):
											cb.val_bin=__double_as_longlong(1.0+__longlong_as_double(cb.val_bin))
										else
											cb.val_bin++
									else
										if cb.type==const_type(CTYPE_FLOAT,32):
											cb.val_bin=i64(u32(__float_as_int((1.0f-__int_as_float(int(cb.val_bin))))))
										else if cb.type==const_type(CTYPE_FLOAT,64):
											cb.val_bin=__double_as_longlong(1.0-__longlong_as_double(cb.val_bin))
										else
											cb.val_bin=1LL-cb.val_bin
									is_different_from_code=1
									gvn_key.x=getBuiltin(g_id_operator_mul)
									gvn_key.z=get_gvn_id(int3(g_fakectval_gvn_cns,getid_const(cb.type,cb.val_bin),0),epos)
							//negation canonicalization: a+-(-b), (-a)+b, -a-b, -a*-b
							key_arg0=g_gvn_values[gvn_key.y].key
							key_arg1=g_gvn_values[gvn_key.z].key
							//gvnkeyIsBuiltin(gvn_key,g_id_operator_add)||
							if gvnkeyIsBuiltin(gvn_key,g_id_operator_sub):
								if gvnkeyIsBuiltin(key_arg1,g_id_operator_neg):
									//try to make everything a +, which is swappable
									//there for we do a-(-b) and ignore a+(-b)
									//we don't want to make (-a)+(-b) and (-a)-(-b) into different expressions
									is_different_from_code=1
									if gvnkeyIsBuiltin(gvn_key,g_id_operator_add):
										gvn_key.x=getBuiltin(g_id_operator_sub)
									else
										gvn_key.x=getBuiltin(g_id_operator_add)
									gvn_key.z=key_arg1.y
									continue
							//if gvnkeyIsBuiltin(gvn_key,g_id_operator_add):
							//	if gvnkeyIsBuiltin(key_arg0,g_id_operator_neg):
							//		//-a+b -> b-a
							//		is_different_from_code=1
							//		gvn_key.x=getBuiltin(g_id_operator_sub)
							//		gvn_key.y=gvn_key.z
							//		gvn_key.z=key_arg0.y
							//		continue
							//else if gvnkeyIsBuiltin(gvn_key,g_id_operator_sub):
							//	//-a-b
							//	//gvn_peephole isn't reentrant for now
							//	//if gvnkeyIsBuiltin(key_arg0,g_id_operator_neg):
							//	//	gvnid_addition=gvn_peephole(int3(getBuiltin(g_id_operator_add),key_arg0.y,gvn_key.z),pe)
							//	//	gvn_key=int3(getBuiltin(g_id_operator_neg),gvnid_addition,0)
							//	//	continue
							//else 
							if gvnkeyIsBuiltin(gvn_key,g_id_operator_mul):
								is_neg0=(key_arg0.x==getBuiltin(g_id_operator_neg))
								is_neg1=(key_arg1.x==getBuiltin(g_id_operator_neg))
								if is_neg0&&is_neg1&&!(key_arg0.y&UNPREDICTABLE_VID_BASE)&&!(key_arg1.y&UNPREDICTABLE_VID_BASE):
									is_different_from_code=1
									gvn_key.y=key_arg0.y
									gvn_key.z=key_arg1.y
									continue
								/*
								//if one side is a negation and the other side is a subtraction, negate the subtraction
								if is_neg0&&gvnkeyIsBuiltin(key_arg1,g_id_operator_sub):
									is_different_from_code=1
									gvn_key.y=key_arg0.y
									gvn_key.z=get_gvn_id(int3(key_arg1.x,key_arg1.z,key_arg1.y),g_gvn_values[gvn_key.z].epos)
									continue
								if is_neg1&&gvnkeyIsBuiltin(key_arg0,g_id_operator_sub):
									is_different_from_code=1
									gvn_key.y=get_gvn_id(int3(key_arg0.x,key_arg0.z,key_arg0.y),g_gvn_values[gvn_key.y].epos)
									gvn_key.z=key_arg1.y
									continue
								//subtraction * subtraction: try to negate both sides and see if we can get a smaller id
								if gvnkeyIsBuiltin(key_arg0,g_id_operator_sub)&&gvnkeyIsBuiltin(key_arg1,g_id_operator_sub):
									id_pair=int2(gvn_key.y,gvn_key.z);if id_pair.x>id_pair.y:{tmp=id_pair.x;id_pair'x':id_pair.y;id_pair'y':tmp}
									id_pair2=int2(
										get_gvn_id(int3(key_arg0.x,key_arg0.z,key_arg0.y),g_gvn_values[gvn_key.y].epos),
										get_gvn_id(int3(key_arg1.x,key_arg1.z,key_arg1.y),g_gvn_values[gvn_key.z].epos));
									if id_pair2.x>id_pair2.y:{tmp=id_pair2.x;id_pair2'x':id_pair2.y;id_pair2'y':tmp}
									if id_pair2.y<id_pair.y:
										is_different_from_code=1
										gvn_key'y':id_pair2.x
										gvn_key.z=id_pair2.y
										continue
								*/
						break
					//Writeln('#')
					//trivial arith
					if gvnkeyIsBuiltin(gvn_key,g_id_operator_add)||gvnkeyIsBuiltin(gvn_key,g_id_operator_or)||gvnkeyIsBuiltin(gvn_key,g_id_operator_xor):
						if gvnIsZero(gvn_key.y):{is_different_from_code=1;return gvn_key.z}
						if gvnIsZero(gvn_key.z):{is_different_from_code=1;return gvn_key.y}
					else if gvnkeyIsBuiltin(gvn_key,g_id_operator_mul):
						if gvnIsOne(gvn_key.y):{is_different_from_code=1;return gvn_key.z}
						if gvnIsOne(gvn_key.z):{is_different_from_code=1;return gvn_key.y}
						if gvnIsZero(gvn_key.y):{is_different_from_code=1;return gvn_key.y}
						if gvnIsZero(gvn_key.z):{is_different_from_code=1;return gvn_key.z}
					else if gvnkeyIsBuiltin(gvn_key,g_id_operator_and):
						if gvnIsZero(gvn_key.y):{is_different_from_code=1;return gvn_key.y}
						if gvnIsZero(gvn_key.z):{is_different_from_code=1;return gvn_key.z}
					else if gvnkeyIsBuiltin(gvn_key,g_id_operator_sub)||gvnkeyIsBuiltin(gvn_key,g_id_operator_shl)||gvnkeyIsBuiltin(gvn_key,g_id_operator_shr):
						if gvnIsZero(gvn_key.z):{is_different_from_code=1;return gvn_key.y}
					else if gvnkeyIsBuiltin(gvn_key,g_id_operator_div):
						if gvnIsOne(gvn_key.z):{is_different_from_code=1;return gvn_key.y}
						if gvnIsZero(gvn_key.y):{is_different_from_code=1;return gvn_key.y}
						//coulddo: *rcp
						//if gvnIsCns(gvn_key.z)
					//forms of negation
					if gvnkeyIsBuiltin(gvn_key,g_id_operator_mul):
						if gvnIsNegOne(gvn_key.y):
							is_different_from_code=1
							gvn_key.x=getBuiltin(g_id_operator_neg)
							gvn_key.y=gvn_key.z;gvn_key.z=0
						else if gvnIsNegOne(gvn_key.z):
							is_different_from_code=1
							gvn_key.x=getBuiltin(g_id_operator_neg)
							gvn_key.z=0
					else if gvnkeyIsBuiltin(gvn_key,g_id_operator_sub):
						if gvnIsZero(gvn_key.y):
							is_different_from_code=1
							gvn_key.x=getBuiltin(g_id_operator_neg)
							gvn_key.y=gvn_key.z
							gvn_key.z=0
						id_neg_b=test_gvn_id(int3(getBuiltin(g_id_operator_neg),gvn_key.z,0))
						if id_neg_b>0:
							//a-b, -b already created, make into a+(-b)
							is_different_from_code=1
							gvn_key.x=getBuiltin(g_id_operator_add)
							gvn_key.z=id_neg_b
					//-(-a)
					if gvnkeyIsBuiltin(gvn_key,g_id_operator_neg):
						if gvnIsBuiltin(gvn_key.y,g_id_operator_neg):
							is_different_from_code=1
							return g_gvn_values[gvn_key.y].key.y
					//coulddo: more convolved examples -- >>24 &0xff or something
					//duplicate operand case
					if gvn_key.y==gvn_key.z:
						if gvnkeyIsBuiltin(gvn_key,g_id_operator_add):
							is_different_from_code=1
							gvn_key.x=getBuiltin(g_id_operator_mul)
							gvn_key.z=get_gvn_id(int3(g_fakectval_gvn_cns,idCastConstI32(2,t),0),epos)
						else if gvnkeyIsBuiltin(gvn_key,g_id_operator_sub)||gvnkeyIsBuiltin(gvn_key,g_id_operator_xor):
							is_different_from_code=1
							gvn_key.x=g_fakectval_gvn_cns
							gvn_key.y=get_gvn_id(int3(g_fakectval_gvn_cns,idCastConstI32(0,t),0),epos)
							gvn_key.z=0
						else if gvnkeyIsBuiltin(gvn_key,g_id_operator_and)||gvnkeyIsBuiltin(gvn_key,g_id_operator_or):
							is_different_from_code=1
							return gvn_key.y
					//the swapping case
					if gvnkeyIsBuiltin(gvn_key,g_id_operator_add)||gvnkeyIsBuiltin(gvn_key,g_id_operator_or)||gvnkeyIsBuiltin(gvn_key,g_id_operator_xor)||gvnkeyIsBuiltin(gvn_key,g_id_operator_and)||gvnkeyIsBuiltin(gvn_key,g_id_operator_mul):
						if gvn_key.y>gvn_key.z&&gvn_key.z:
							//is_different_from_code=1
							tmp=gvn_key.y
							gvn_key.y=gvn_key.z
							gvn_key.z=tmp
		gvn_id_ret=get_gvn_id(gvn_key,epos)
		return gvn_id_ret
	auto bbssa(PExpression pe0)
		pe=pe0
		if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isExpr(pe,EFLAG_FCALL):
			//Writeln('unreach ',dumpExpr(pe,NULL))
			is_referring_to_unpredictable=1
			return make_unpredictable(0)
		if isExpr(pe,EFLAG_VARIABLE):
			pobj_var=getVariable(pe)
			if readPool(pobj_var)==g_vtid_RTVAR:
				flag0=readPool(pobj_var+VAR_OFS_USER_FLAGS)
				bid=(flag0&USER_FLAG_MASK)
				if bid!=USER_FLAG_MASK&&bid:
					if !(bid&FLAG_SSA_RENAMED):
						//uninit, smash it - could be a loop
						//t=getVariableType(pobj_var)
						//if t&&!tisstruct(t):
						//	errorAtExpr(ETYPE_WARNING,pe,"uninitialized variable '@1'".Replace(["@1",citeexpr(pe)]))
						writePool(pobj_var+VAR_OFS_USER_FLAGS,flag0|USER_FLAG_MASK)
					else
						//do the renaming
						ssa_vid=(bid&~FLAG_SSA_RENAMED)
						pobj_var_renamed=ssa_names[ssa_vid].pv_current
						if readPool(pe)!=EFLAG_VARIABLE+pobj_var_renamed:
							is_different_from_code=1
							//sccpQueueEval(pe)
							//writePool(pe,EFLAG_VARIABLE+pobj_var_renamed)
							//for the queue
							transformCode(pe,NULL, NULL,exprvar(pobj_var_renamed),NULL)
						return ssa_names[ssa_vid].gvn_id
		else if isExpr(pe,EFLAG_FCALL):
			is_store=0
			is_pure=0
			if isBuiltin(pe,g_id_store):
				is_store=1
			//purity - flagging FFLAG_IS_PURE for c imports... intrinsic __fflag, global int[] for param gvn ids
			pobjfn=getExprFunction(pe)
			if pobjfn&&(getFFlag(pobjfn)&FFLAG_IS_PURE):
				is_pure=1
				if ENABLE_GVN:
					val=getExprValue(pe)
					if val.tid==g_vtid_CNS:
						return get_gvn_id(int3(g_fakectval_gvn_cns,val.val,0),readPool(pe+EXPR_OFS_EPOS))
					else if val.tid==g_vtid_STR:
						return get_gvn_id(int3(g_fakectval_gvn_str,val.val,0),readPool(pe+EXPR_OFS_EPOS))
			gvn_key=int3(pobjfn,0,0)
			n_args=getFCallNArgs(pe)
			if !isSSAStatementHost(pe):
				gvn_id_ret=0
				//gvn - int3 hash - if we have more than 3, we know (it's a weird function), just ctUnique the rest into one of the 3 ints
				if is_store:
					pe_var=readPool(pe+EXPR_OFS_ARGS+0)
					pobj_var=getVariable(pe_var)
					assert(!is_pure)
					bk=is_different_from_code
					bk2=is_referring_to_unpredictable
					is_different_from_code=0
					is_referring_to_unpredictable=0
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					gvn_id_value=bbssa(pe_value)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)//var renaming may have changed it
					remove_single_use=(!is_referring_to_unpredictable)
					gvn_replace(pe_value,gvn_id_value)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					is_referring_to_unpredictable=bk2
					is_different_from_code=bk
					if readPool(pobj_var)==g_vtid_RTVAR:
						flag0=readPool(pobj_var+VAR_OFS_USER_FLAGS)
						bid=(flag0&USER_FLAG_MASK)
						if bid!=USER_FLAG_MASK&&bid:
							if DEBUG_DUMP_SSA:
								Writeln('SSA-friendly store ',dumpExpr(pe,NULL))
							if !(bid&FLAG_SSA_RENAMED):
								//mode switch to SSA, but the variable name remains unchanged
								bid--
								writePool(pobj_var+VAR_OFS_USER_FLAGS,(flag0&~USER_FLAG_MASK)+(FLAG_SSA_RENAMED+int(ssa_names.n)))
								pv_current=pobj_var
								if isCopyPropFriendly(pe_value,gvn_id_value):
									//copyprop
									pv_current=getGvnVariable(pe_value,gvn_id_value)
									if DEBUG_DUMP_SSA:
										Writeln('1st-copy-prop rename: ',dumpExpr(pe,NULL),' ',string.ToHex(gvn_id_value),' ',dumpObject(pv_current))
									//the ANM/deriv returns should have been protected this way
									if readPool(pobj_var+VAR_OFS_ID)==g_id_return:
										transformCode(pe_value,NULL, NULL,exprvar(pv_current),NULL)
									else
										setnop(pe)
								ssa_names.push(TSSAName(){'pv_original':pobj_var,'pv_current':pv_current,'gvn_id':gvn_id_value})
								ssa_vid=int(ssa_names.n)-1
							else
								ssa_vid=(bid&~FLAG_SSA_RENAMED)
								//give the variable a new name
								if isCopyPropFriendly(pe_value,gvn_id_value):
									//copyprop
									ssa_names[ssa_vid].pv_current=getGvnVariable(pe_value,gvn_id_value)
									ssa_names[ssa_vid].gvn_id=gvn_id_value
									if DEBUG_DUMP_SSA:
										Writeln('copy-prop rename: ',dumpExpr(pe,NULL),' ',dumpObject(ssa_names[ssa_vid].pv_current))
									//the ANM/deriv returns should have been protected this way
									if readPool(pobj_var+VAR_OFS_ID)==g_id_return:
										transformCode(pe_value,NULL, NULL,exprvar(ssa_names[ssa_vid].pv_current),NULL)
									else
										setnop(pe)
								else
									//true new value
									pv_dup=makevar(readPool(pobj_var+VAR_OFS_OWNER))
									writePool(pv_dup+VAR_OFS_FLATTENING_OWNER,readPool(pobj_var+VAR_OFS_FLATTENING_OWNER))
									ssa_names[ssa_vid].pv_current=pv_dup
									ssa_names[ssa_vid].gvn_id=gvn_id_value
									if DEBUG_DUMP_SSA:
										Writeln('rename: ',dumpExpr(pe,NULL),' ',dumpObject(ssa_names[ssa_vid].pv_current))
									writePool(pv_dup+VAR_OFS_ID,readPool(pobj_var+VAR_OFS_ID))
									//writePool(pe_var,EFLAG_VARIABLE+pv_dup)
									//transformCode(pe_var,NULL, NULL,exprvar(pv_dup),NULL)
									//sccpQueueEval(pe)
									//we gotta replace pe for the queue
									pe_renamed=transformCode(pe,NULL, NULL,call(g_id_store,exprvar(pv_dup),pe_value),NULL)
									setnop(pe)
									pe=pe_renamed
									if DEBUG_DUMP_PASSES&&DEBUG_DUMP_GVN_DETAILS:{if !did:Write('SSA rename')}
									did=1
							if remove_single_use:
								//only remove the SSA-friendly ones, put it here -- pe may have changed due to renaming
								removable_stores.push(pe)
							if gvn_id_value&UNPREDICTABLE_VID_BASE:
								g_unpredictable_values[gvn_id_value-UNPREDICTABLE_VID_BASE]=exprvar(ssa_names[ssa_vid].pv_current)
								if DEBUG_DUMP_SSA:
									Writeln('GVN-backing-var-set-unp ',string.ToHex(gvn_id_value),' ',dumpExpr(pe,NULL))
							else
								//if remove_single_use:
								//	if DEBUG_DUMP_SSA:
								//		Writeln('single-use variable removed ',dumpExpr(pe,NULL))
								//	//don't touch pe, wait for it to get deadelimed
								//	//wipe it out so that no one CSEs the shit
								//	//if is_different_from_code:
								//	wipeoutStaleBackingExpr(pe_value)
								if g_gvn_values[gvn_id_value].pv_backing<=0:
									//avoid replacing the backing var
									g_gvn_values[gvn_id_value].pv_backing=ssa_names[ssa_vid].pv_current
									if DEBUG_DUMP_SSA:
										Writeln('GVN-backing-var-set ',string.ToHex(gvn_id_value),' ',dumpExpr(pe,NULL))
								else
									if DEBUG_DUMP_SSA:
										Writeln('backing-var remained as ',dumpObject(g_gvn_values[gvn_id_value].pv_backing)," even though it's assigned to ",dumpObject(ssa_names[ssa_vid].pv_current))
						else
							if DEBUG_DUMP_SSA:
								Writeln('SSA-hostile store ',dumpExpr(pe,NULL))
					gvn_id_ret=make_unpredictable(pe)
				else if is_pure&&n_args<=2:
					assert(!is_store)
					bk2=is_referring_to_unpredictable
					bbssa(readPool(pe+EXPR_OFS_ARGS+-1))
					is_referring_to_unpredictable=bk2
					//simplify the special cases
					gvn_id_ret=gvn_peephole(gvn_key,pe)
					if DEBUG_DUMP_SSA:
						if gvn_id_ret&UNPREDICTABLE_VID_BASE:
							Writeln('GVN number ',gvn_id_ret,' ',dumpExpr(pe,NULL),' (peephole)',is_different_from_code?" ***":"")
						else
							Writeln('GVN number ',gvn_id_ret,' ',dumpExpr(pe,NULL),' (peephole)',is_different_from_code?" ***":"",' ',g_gvn_values[gvn_id_ret].key)
				else if is_pure:
					arg_values=new int[]
					arg_values.push(g_id_gvn_ctunique)
					for i=-1:n_args-1
						bk2=is_referring_to_unpredictable
						val_i=bbssa(readPool(pe+EXPR_OFS_ARGS+i))
						if i>=0:
							arg_values.push(val_i)
						else
							is_referring_to_unpredictable=bk2
					gvn_key.y=-1
					gvn_key.z=ctUnique(arg_values)
					gvn_id_ret=get_gvn_id(gvn_key,readPool(pe+EXPR_OFS_EPOS))
					if DEBUG_DUMP_SSA:
						Writeln('GVN number ',gvn_id_ret,' ',dumpExpr(pe,NULL))
				else
					for i=-1:n_args-1
						bk=is_different_from_code
						bk2=is_referring_to_unpredictable
						is_different_from_code=0
						is_referring_to_unpredictable=0
						peargi=readPool(pe+EXPR_OFS_ARGS+i)
						gvn_id_i=bbssa(peargi)
						peargi=readPool(pe+EXPR_OFS_ARGS+i)
						gvn_replace(peargi,gvn_id_i)
						is_referring_to_unpredictable=bk2
						is_different_from_code=bk
					is_referring_to_unpredictable=1
					gvn_id_ret=make_unpredictable(pe)
			else
				for i=-1:n_args-1
					peargi=readPool(pe+EXPR_OFS_ARGS+i)
					if !isBuiltin(peargi,g_id_block):
						bk=is_different_from_code
						bk2=is_referring_to_unpredictable
						is_different_from_code=0
						is_referring_to_unpredictable=0
						gvn_id_i=bbssa(peargi)
						peargi=readPool(pe+EXPR_OFS_ARGS+i)
						gvn_replace(peargi,gvn_id_i)
						is_referring_to_unpredictable=bk2
						is_different_from_code=bk
				is_referring_to_unpredictable=1
				gvn_id_ret=make_unpredictable(pe)
			if !(gvn_id_ret&UNPREDICTABLE_VID_BASE):
				tentative_backing_gvnid[pe]=gvn_id_ret//set this no matter what - needed for the wipe check
				if !g_gvn_values[gvn_id_ret].pv_backing:
					//if !is_different_from_code:
					//tentative backing - must set this on is_different_from_code - we need to do a dfs wipe later
					if DEBUG_DUMP_SSA:
						//if !is_different_from_code:
						Writeln('set tentative backing: ',gvn_id_ret,' ',dumpExpr(pe,NULL))
					g_gvn_values[gvn_id_ret].pv_backing=0x80000000+pe
				else
					//non-trivial expression has an old value, CSE opportunity
					if DEBUG_DUMP_SSA:
						if !is_different_from_code:
							Writeln('value not new in GVN: ',gvn_id_ret,' ',g_gvn_values[gvn_id_ret].pv_backing,' ',dumpExpr(pe,NULL))
					is_different_from_code=1
			assert(gvn_id_ret!=0)
			return gvn_id_ret
		if ENABLE_GVN:
			val=getExprValue(pe)
			if val.tid==g_vtid_CNS:
				return get_gvn_id(int3(g_fakectval_gvn_cns,val.val,0),readPool(pe+EXPR_OFS_EPOS))
			else if val.tid==g_vtid_STR:
				return get_gvn_id(int3(g_fakectval_gvn_str,val.val,0),readPool(pe+EXPR_OFS_EPOS))
		is_referring_to_unpredictable=1
		return make_unpredictable(pe)
	auto countUsesSSA(PExpression pe)
		if isExpr(pe,EFLAG_VARIABLE):
			pobj_var=getVariable(pe)
			if readPool(pobj_var)==g_vtid_RTVAR:
				pe0=the_single_use[pobj_var]
				if pe0==0x40000000:
					the_single_use[pobj_var]=pe
				else if pe0>=0:
					the_single_use[pobj_var]=-1
		else if isExpr(pe,EFLAG_FCALL):
			if !testUserFlag(pe,QUEUE_FLAG_REACH):return
			n_args=getFCallNArgs(pe)
			if !isSSAStatementHost(pe):
				if isBuiltin(pe,g_id_store):
					pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
					assert(!!pobj_var)
					//detect multiple stores - we must have exactly one store and exactly one use
					pe0=the_single_use[pobj_var]
					if pe0!=0:
						pe0=-1
					else
						pe0=0x40000000
					the_single_use[pobj_var]=pe0
					countUsesSSA(readPool(pe+EXPR_OFS_ARGS+1))
				else
					for i=-1:n_args-1
						countUsesSSA(readPool(pe+EXPR_OFS_ARGS+i))
			else
				for i=-1:n_args-1
					peargi=readPool(pe+EXPR_OFS_ARGS+i)
					if !isBuiltin(peargi,g_id_block):
						countUsesSSA(peargi)
	foreach pe_bb in all_bbs
		initGVN(pe_bb)
		if DEBUG_DUMP_SSA:
			Writeln('=== before SSA\n',dumpExpr(pe_bb,fcolor_ssa))
		bbssa(pe_bb)
		if removable_stores.n:
			sccpProcessReaches()//need to get the reaches right
			countUsesSSA(pe_bb)
			foreach pe in removable_stores
				if isBuiltin(pe,g_id_nop):continue//copy-proped, don't do it again
				pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
				assert(!!pobj_var)
				pe_use=the_single_use[pobj_var]
				if pe_use>0&&pe_use!=0x40000000:
					//remove the single-use
					if DEBUG_DUMP_SSA:
						Writeln('remove: ',dumpExpr(pe,NULL),' ',dumpExpr(readPool(pe_use+EXPR_OFS_CALLER),NULL))
					did=1
					transformCode(pe_use,NULL,NULL,readPool(pe+EXPR_OFS_ARGS+1),NULL)
					setnop(pe)
		if DEBUG_DUMP_SSA:
			Writeln('=== after SSA\n',dumpExpr(pe_bb,fcolor_ssa))
	return did

auto deadelim()
	if DEBUG_DUMP_DEADELIM:
		Writeln('=== before deadelim')
		Writeln(dumpExpr(g_pe_top,fcolor_just_reach))
	did=0
	//redoDefUseChains()
	//expr liveness labeling
	FLAG_IS_LIVE=1
	FLAG_EXPR_PARENT_SCAN_DONE=2
	clearUserFlags(g_pe_top,0)
	Q=new PExpression[]
	fn_caller_lists=new PExpression[][PCTObject]
	dfsRootLives=function(PExpression pe){
		if !isExpr(pe,EFLAG_FCALL):return 0
		if !testUserFlag(pe,QUEUE_FLAG_REACH):
			return 0
		auto pobjfn=getExprFunction(pe)
		if !pobjfn:
			Q.push(pe)
			return 1
		else
			auto fflag=getFFlag(pobjfn)
			if (fflag&FFLAG_IMPORTED)&&!(fflag&FFLAG_IS_PURE)||(fflag&FFLAG_IS_PRELIVE):
				Q.push(pe)
				return 1
			//else if isBuiltin(pe,g_id_set_memory)||isBuiltin(pe,g_id_C_wrap)||isBuiltin(pe,g_id_force_alive)||isBuiltin(pe,g_id_export)||isBuiltin(pe,g_id_blockex):
			//	Q.push(pe)
			//	return 1
			if isBuiltin(pe,g_id_stdot):
				pobj_member=getDotMember(pe,0)
				if pobj_member&&readPool(pobj_member)==g_vtid_RTVAR:
					if tisclass(readPool(pobj_member+1)):
						//class member store / struct memcpy - it's prelive
						Q.push(pe)
						return 1
			else if isBuiltin(pe,g_id_store):
				pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
				if pobj_var&&readPool(pobj_var)==g_vtid_RTVAR:
					if tisstruct(readPool(pobj_var+1)):
						//implicit memcpy - it's prelive
						Q.push(pe)
						return 1
			if pobjfn:
				callers=fn_caller_lists[pobjfn]
				if !callers:
					callers=new PExpression[]
					fn_caller_lists[pobjfn]=callers
				callers.push(pe)
		return 1
	}
	dfsExpr(g_pe_top,dfsRootLives)
	foreach pe in Q
		setUserFlag(pe,FLAG_IS_LIVE)
	///////////////////////////////
	//propagating the liveness
	auto marklive(PExpression pe)
		if !testUserFlag(pe,FLAG_IS_LIVE):
			Q.push(pe)
			setUserFlag(pe,FLAG_IS_LIVE)
	auto marklive_var(PCTObject pobj_var)
		if !testUserFlag(pobj_var,FLAG_IS_LIVE):
			Q.push(pobj_var|0x80000000)
			setUserFlag(pobj_var,FLAG_IS_LIVE)
	auto markreturn(PCTObject pobjfn)
		pobj_var_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
		if pobj_var_return:
			if DEBUG_DUMP_DEADELIM:
				Writeln('  return var: ',dumpObject(pobj_var_return))
			marklive_var(pobj_var_return)
	//Writeln('==========')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	for(head=0;head<Q.n;head++)
		auto Q_i=Q[head]
		if Q_i<0:
			//var to definition
			pobj_var=(Q_i&0x7fffffff)
			vtid=readPool(pobj_var)
			if vtid==g_vtid_RTVAR:
				t=getVariableType(pobj_var)
				if tisfunction(t):
					//function types are force-alived if there is at least 1 var
					dfsExpr(readPool(t+FUNCTION_OFS_CODE),function(PExpression pe){marklive(pe);return 1})
			else if vtid==g_vtid_CTVAL
				pobjfn=getAsFunction(readPool(pobj_var+1))
				if pobjfn:markreturn(pobjfn)
			if DEBUG_DUMP_DEADELIM:
				Writeln('var live: ',dumpObject(pobj_var))
			for(pestore=readPool(pobj_var+VAR_OFS_STORE_QUEUE);pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
				if DEBUG_DUMP_DEADELIM:
					Writeln('  mark store: ',dumpExpr(pestore,fcolor_abbrv_blocks))
				marklive(pestore)
		else
			pecall=Q_i
			if DEBUG_DUMP_DEADELIM:
				Writeln('expr live: ',dumpExpr(pecall,fcolor_abbrv_blocks))
			if isExpr(pecall,EFLAG_FCALL):
				//call to param
				if !isBuiltin(pecall,g_id_block):
					n_args=getFCallNArgs(pecall)
					for i=-1:n_args-1
						peargi=readPool(pecall+EXPR_OFS_ARGS+i)
						marklive(peargi)
				if isBuiltin(pecall,g_id_dot)||isBuiltin(pecall,g_id_stdot):
					pobj_member=getDotMember(pecall,0)
					if pobj_member:
						marklive_var(pobj_member)
				pobjfn=getExprFunction(pecall)
				if pobjfn&&!(getFFlag(pobjfn)&FFLAG_BUILTIN)&&!isBuiltin(readPool(pecall+EXPR_OFS_CALLER),g_id_block):
					//return value use
					markreturn(pobjfn)
			else if isExpr(pecall,EFLAG_CTVAL):
				//function to declaration and return value
				pobj_ctval=(readPool(pecall)&~EFLAG_MASK)
				pobjfn=getAsFunction(pobj_ctval)
				if pobjfn:
					//pecode=readPool(pobjfn+FUNCTION_OFS_CODE)
					//marklive(pecode)
					assert(readPool(pobjfn)==g_tid_TFunction)
					if !(getFFlag(pobjfn)&FFLAG_BUILTIN):
						marklive(readPool(pobjfn+FUNCTION_OFS_PEDECL))
						markreturn(pobjfn)
			else if isExpr(pecall,EFLAG_VARIABLE):
				marklive_var(getVariable(pecall))
			//depending control flow, containing function
			for(pei=pecall;pei;pei=readPool(pei+EXPR_OFS_CALLER))
				if testUserFlag(pei,FLAG_EXPR_PARENT_SCAN_DONE):break
				setUserFlag(pei,FLAG_EXPR_PARENT_SCAN_DONE)
				if isBuiltin(pei,g_id_if)||isBuiltin(pei,g_id_blockex):
					//don't propagate to block params... but make itself alive
					marklive(pei)
				else if isBuiltin(pei,g_id_function):
					//owning function becomes impure, mark all callers
					pobjfn=getExprValueAs(pei,g_vtid_CTVAL)
					assert(!!pobjfn)
					if pobjfn:
						if tisclass(pobjfn):
							//if it's a class, the return value is always alive
							markreturn(pobjfn)
						callers=fn_caller_lists[pobjfn]
						if callers:
							foreach pecaller in callers
								marklive(pecaller)
					break
	///////////////////////////////
	//prune the dead
	auto dfsPruneDead(PExpression pe,PExpression[] as)
		if isExpr(pe,EFLAG_FCALL):
			if !testUserFlag(pe,QUEUE_FLAG_REACH):return
			if isBuiltin(pe,g_id_nop):return
			n_args=getFCallNArgs(pe)
			as_recurse=PExpression[].NULL
			dead_parent=0
			if isBuiltin(pe,g_id_function):
				//test the return value - if it gets dead, we remove it
				pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
				pobj_var_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
				if pobj_var_return&&!testUserFlag(pobj_var_return,FLAG_IS_LIVE):
					writePool(pobjfn+FUNCTION_OFS_PVAR_RETURN,0)
				//remove dead members from member lists
				if (getFFlag(pobjfn)&FFLAG_NAME_LOOKUP_READY):
					p_members=readPool(pobjfn+FUNCTION_OFS_PMEMBER_LIST)
					n_members=readPool(pobjfn+FUNCTION_OFS_NMEMBER_LIST)
					n2=0
					for i=0:n_members-1
						id_member=readPool(p_members+i)
						pobj_var=lookupFunctionVariable(pobjfn,id_member)
						if testUserFlag(pobj_var,FLAG_IS_LIVE):
							writePool(p_members+n2,id_member)
							n2++
					if n2<n_members:
						writePool(pobjfn+FUNCTION_OFS_NMEMBER_LIST,n2)
				if DEBUG_DUMP_DEADELIM:
					Writeln('begin ',dumpFunction(pobjfn))
			else if !testUserFlag(pe,FLAG_IS_LIVE)&&!isBuiltin(pe,g_id_block):
				as_recurse=new PExpression[]
				dead_parent=1
			for i=-1:n_args-1
				peargi=readPool(pe+EXPR_OFS_ARGS+i)
				dfsPruneDead(peargi,as_recurse)
			if DEBUG_DUMP_DEADELIM:
				if isBuiltin(pe,g_id_function):
					dbg_pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
					Writeln('end ',dumpFunction(dbg_pobjfn))
			if dead_parent:
				did=1
				//dead parent - live param
				if DEBUG_DUMP_DEADELIM:
					dbg_is_trivial_dead=0
					if isBuiltin(pe,g_id_store):
						dbg_val=getExprValue(readPool(pe+EXPR_OFS_ARGS+1))
					else
						dbg_val=getExprValue(pe)
					if dbg_val.tid!=g_vtid_RTVAR:
						dbg_is_trivial_dead=1
					if !dbg_is_trivial_dead:
						Writeln('dead: ',dumpExpr(pe,fcolor_abbrv_blocks))
				if as_recurse.n:
					//if as_recurse.n==1:
					//	transformCode(pe,NULL, NULL,as_recurse[0],NULL)
					//else
					transformCode(pe,NULL, NULL,vcall(g_id_block,as_recurse),NULL)
				else
					setnop(pe)
			else
				if as:as.push(pe)
	dfsPruneDead(g_pe_top,NULL)
	if DEBUG_DUMP_DEADELIM:
		Writeln('=== after deadelim')
		Writeln(dumpExpr(g_pe_top,fcolor_just_reach))
	clearUserFlags(g_pe_top,0)
	return did
	
g_pe_top=PExpression(0)
g_root_namespace=PCTObject(0)
g_t_root_namespace=PCTObject(0)

auto removeUselessReturns(PExpression pe,int id_return_label)
	if !isBuiltin(pe,g_id_block):
		return
	n_args=getFCallNArgs(pe)
	for(;;)
		if !n_args:break
		pe_last=readPool(pe+EXPR_OFS_ARGS+n_args-1)
		//Writeln("removeUselessReturns "+dumpExpr(pe_last,fcolor_abbrv_blocks))
		if isBuiltin(pe_last,g_id_if):
			n_args_if=readPool(pe_last)&~EFLAG_MASK
			for i=1:2:n_args_if-1
				removeUselessReturns(readPool(pe_last+EXPR_OFS_ARGS+i),id_return_label)
			break
		else if isBuiltin(pe_last,g_id_block):
			removeUselessReturns(pe_last,id_return_label)
			break
		else if isBuiltin(pe_last,g_id_blockex)&&readPool(readPool(pe_last+EXPR_OFS_ARGS+0))==EFLAG_STRING+id_return_label:
			//remove the now useless tail return
			n_args--
			writePool(pe,EFLAG_FCALL+n_args)
		else
			break
	
auto flattenAfterParsing(PExpression[] block_as,PExpression pe)
	if !isExpr(pe,EFLAG_FCALL):
		return pe
	n_args=getFCallNArgs(pe)
	if isBuiltin(pe,g_id_block):
		pecaller=readPool(pe+EXPR_OFS_CALLER)
		if !pecaller||isStatementHost(pecaller):
			//it's a valid host
			as_new=new PExpression[]
			for i=0:n_args-1
				peargi=readPool(pe+EXPR_OFS_ARGS+i)
				assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
				peargi=flattenAfterParsing(as_new,peargi)
				if peargi:as_new.push(peargi)
			n2=0
			foreach pei in as_new
				as_new[n2++]=pei
			as_new.resize(n2)
			pe_ret=replaceBlockArgs(pe,as_new,0)
			return pe_ret
		else
			//we should pull it out
			for i=0:n_args-2
				peargi=readPool(pe+EXPR_OFS_ARGS+i)
				assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
				peargi=flattenAfterParsing(block_as,peargi)
				writePool(peargi+EXPR_OFS_CALLER,0)
				block_as.push(peargi)
			peargi=readPool(pe+EXPR_OFS_ARGS+n_args-1)
			assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
			peargi=flattenAfterParsing(block_as,peargi)
			writePool(peargi+EXPR_OFS_CALLER,0)
			return peargi
	else
		//just dfs
		is_function=isBuiltin(pe,g_id_function)
		for i=-1:n_args-1
			peargi0=readPool(pe+EXPR_OFS_ARGS+i)
			assert(readPool(peargi0+EXPR_OFS_CALLER)==pe)
			peargi=flattenAfterParsing(block_as,peargi0)
			if peargi!=peargi0:
				if is_function&&i==n_args-1:
					//__function case: replace fn.code
					pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
					writePool(pobjfn+FUNCTION_OFS_CODE,peargi)
				writePool(pe+EXPR_OFS_ARGS+i,peargi)
				writePool(peargi+EXPR_OFS_CALLER,pe)
			if is_function&&i==n_args-1:
				pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
				removeUselessReturns(peargi,getReturnLabel(pobjfn))
		return pe

if Platform.BUILD=="debug":
	auto validateEPoses(PExpression pe)
		//fwarning=function(PExpression pe){
		//	if isBuiltinR(pe,g_id_block):return -2
		//	return 10
		//}
		ferror=function(PExpression pe){
			if isBuiltinR(pe,g_id_block):return -2
			return 12
		}
		fvalidate=function(PExpression pe){
			epos0=readPool(pe+1)
			epos1=readPool(pe+2)
			if !epos0&&!epos1:
				if isExpr(pe,EFLAG_VARIABLE)||isExpr(pe,EFLAG_STRING)||isExpr(pe,EFLAG_CONST):
					//vid=getVariable(pe)
					//if vid==g_id_store||vid==g_id_dot:return 0
					return 0
				//Writeln("no epos: "+dumpExpr(pe,fwarning))
			else if !epos0||!epos1:
				Writeln("half epos "+string(!epos1)+": "+dumpExpr(pe,ferror))
			else
				//id_fn0=getLineInfo(epos0)
				//id_fn1=getLineInfo(epos1)
				//if id_fn0!=id_fn1:
				//	Writeln("bad epos: "+dumpExpr(pe,ferror))
			return 1
		}
		dfsExpr(pe,fvalidate)
	
auto createRootExpression(string s_main_function_name)
	//scan namespaces
	auto scan_for_namespaces(PExpression pe,int2[] items_list)
		if isExpr(pe,EFLAG_FCALL)
			n_args=getFCallNArgs(pe)
			if isBuiltinR(pe,g_id_namespace):
				//a namespace
				items_list_recurse=new int2[]
				scan_for_namespaces(readPool(pe+EXPR_OFS_ARGS+1),items_list_recurse)
				pobj_space=poolObject(TNameSpace(){'n_members':int(items_list_recurse.n)})
				items_list_recurse.Sort(function(a,b){return a.x<b.x})
				g_ctobject_pool.push(items_list_recurse[0:].ConvertToAsBinary(int))
				//add the namespace itself and set it to the expression
				assert((readPool(readPool(pe+EXPR_OFS_ARGS+0))&EFLAG_MASK)==EFLAG_STRING)
				items_list.push(int2(readPool(readPool(pe+EXPR_OFS_ARGS+0))&~EFLAG_MASK,pobj_space))
				assert(!!pobj_space)
				writePool(readPool(pe+EXPR_OFS_ARGS+2),EFLAG_CTVAL+pobj_space)
				return pobj_space
			else if isBuiltinR(pe,g_id_store):
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				pe_value=readPool(pe+EXPR_OFS_ARGS+1)
				//if items_list&&readPool(pe)==3+EFLAG_FCALL&&readPool(readPool(pe+EXPR_OFS_ARGS+2))==EFLAG_STRING+g_id_namespace:
				if items_list&&isExpr(pe_var,EFLAG_VARIABLE):
					id_var=getVariable(pe_var)
					if !isTempId(id_var)&&id_var!=g_id_this&&id_var!=g_id_return:
						items_list.push(int2(id_var,0))
						if readPool(pe)==EFLAG_FCALL+3:
							//force disable autos
							writePool(pe,EFLAG_FCALL+2)
				scan_for_namespaces(pe_value,items_list)
				return 0
			else
				items_list_recurse=items_list
				if isBuiltinR(pe,g_id_function)||isBuiltinR(pe,g_id_block)&&n_args>=1&&readPool(readPool(pe+EXPR_OFS_ARGS+0))==EFLAG_STRING+g_id_block:
					//function / "__block" boundary, reset the item list
					items_list_recurse=NULL
				ret=0
				for i=-1:n_args-1
					ret_i=scan_for_namespaces(readPool(pe+EXPR_OFS_ARGS+i),items_list_recurse)
					if !ret&&ret_i:ret=ret_i
				return ret
		return 0
	if Platform.BUILD=="debug":
		foreach pe in g_top_level_exprs
			validateEPoses(pe)
	g_top_block=vcall(g_id_block,g_top_level_exprs)
	g_pe_top=call(g_id_export,exprstr(getid(s_main_function_name)),call(g_id_function,exprstr(g_id_function),g_top_block))
	//have to scan g_top_block instead of g_pe_top - the function wrapper resets the item list
	root_items=new int2[]
	scan_for_namespaces(g_top_block,root_items)
	g_root_namespace=poolObject(TNameSpace(){'n_members':int(root_items.n)})
	root_items.Sort(function(a,b){return a.x<b.x})
	g_ctobject_pool.push(root_items[0:].ConvertToAsBinary(int))
	if Platform.BUILD=="debug":
		if g_enable_dump:
			auto dumpNamespace(int n_tabs,PCTObject pobj_space)
				assert(readPool(pobj_space)==g_tid_TNameSpace)
				auto n=readPool(pobj_space+1)
				for i=0:n-1
					id_item=readPool(pobj_space+2+i*2)
					for j=0:n_tabs-1
						Write('  ')
					Write(getIdString(id_item),':')
					pobj_child_space=readPool(pobj_space+2+i*2+1)
					if pobj_child_space:
						Writeln('{')
						dumpNamespace(n_tabs+1,pobj_child_space)
						for j=0:n_tabs-1
							Write('  ')
						Writeln('},')
					else
						Writeln('...;')
			dumpNamespace(0,g_root_namespace)
	g_top_level_exprs=PExpression[].NULL
	//resolve names
	//Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
	resolveNames(g_pe_top,1)
	//flatten nested blocks
	g_pe_top=flattenAfterParsing(PExpression[].NULL,g_pe_top)

auto clearUserFlags(PExpression pe,int flag0)
	writePool(pe+EXPR_OFS_USER_FLAGS,flag0|(readPool(pe+EXPR_OFS_USER_FLAGS)&~USER_FLAG_MASK))
	flags=readPool(pe)
	if (flags&EFLAG_MASK)==EFLAG_FCALL:
		nargs=(flags&~EFLAG_MASK)
		for i=-1:nargs-1
			clearUserFlags(readPool(pe+EXPR_OFS_ARGS+i),flag0)
	else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
		pobj=getVariable(pe)
		if pobj:
			writePool(pobj+VAR_OFS_USER_FLAGS,flag0|(readPool(pobj+VAR_OFS_USER_FLAGS)&~VAR_USER_FLAG_MASK))
			//if g_ctobject_pool.n>371:
			//	if !g_ctobject_pool[371]:
			//		Writeln('smash! ',dumpExpr(pe,NULL))
			//	assert(!!g_ctobject_pool[371])
	///////////

auto isSpecial(PExpression pe)
	assert((readPool(pe)&EFLAG_MASK)==EFLAG_FCALL)
	pobjfn=getExprFunction(pe)
	if pobjfn:
		fn=readPoolTyped(pobjfn,TFunction)
		//ccnv=getCcnv(fn)
		return (fn.flags&FFLAG_SPECIAL)
	return 0

auto isStatementHost(PExpression pe)
	assert((readPool(pe)&EFLAG_MASK)==EFLAG_FCALL)
	pobjfn=getExprFunction(pe)
	if pobjfn:
		fn=readPoolTyped(pobjfn,TFunction)
		//ccnv=getCcnv(fn)
		return (fn.flags&FFLAG_STATEMENT_HOST)
	return 0

auto isArithmetic(PExpression pe)
	assert((readPool(pe)&EFLAG_MASK)==EFLAG_FCALL)
	pobjfn=getExprFunction(pe)
	if pobjfn:
		fn=readPoolTyped(pobjfn,TFunction)
		//ccnv=getCcnv(fn)
		return (fn.flags&FFLAG_ARITHMETIC)
	return 0

auto getNumberOfArguments(PCTObject pobjfn)
	pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	n_args=getFCallNArgs(pe_decl+0)
	return (n_args-2)>>1

auto getReturnVariable(PCTObject pobjfn)
	return readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)

auto getVariableType(PCTObject pobj_var)
	return getValueType(readPoolTyped(pobj_var,TSCCPValue))

auto getReturnType(PCTObject pobjfn)
	pobj_var=getReturnVariable(pobjfn)
	if !pobj_var:return 0
	return getVariableType(pobj_var)

auto getStoreTarget(PExpression pe)
	er=readPoolTyped(pe,TExpression)
	if er.flags_n_args!=2+EFLAG_FCALL&&er.flags_n_args!=3+EFLAG_FCALL:return 0
	pevarname=readPool(pe+(EXPR_OFS_ARGS))
	if (readPool(pevarname)&EFLAG_MASK)!=EFLAG_VARIABLE:
		return 0
	//create the variable
	return getVariable(pevarname)

auto setFunctionUsed(PCTObject pobjfn)
	fn=readPoolTyped(pobjfn,TFunction)
	//reach the value and set up a scope
	//if getExprValue(fn.code).tid==g_vtid_UNREACHED:
	//pe_decl=fn.pe_decl
	if !testUserFlag(fn.code,QUEUE_FLAG_REACH)
		sccpQueueReach(fn.code)
		return 1
	return 0

auto cloneFunction(PCTObject pobjfn)
	pobjfn_cloned=cloneFunctionEx(pobjfn,new PCTObject[PCTObject],CLONE_WIPE_TO_UNREACHED|CLONE_VARS|CLONE_KEEP_VAR_IDS)
	pe_decl_old=readPool(pobjfn+FUNCTION_OFS_PEDECL)
	pe_decl_cloned=readPool(pobjfn_cloned+FUNCTION_OFS_PEDECL)
	//pe_decl_caller=readPool(pe_decl_old+EXPR_OFS_CALLER)
	transformCode(pe_decl_old,ftransformer_callback.NULL, [pe_decl_cloned],pe_decl_old,PExpression[].NULL)
	return pobjfn_cloned

auto enableNameLookup(PCTObject pobjfn)
	assert(readPool(pobjfn)==g_tid_TFunction)
	if (getFFlag(pobjfn)&FFLAG_NAME_LOOKUP_READY):return
	pecode=readPool(pobjfn+FUNCTION_OFS_CODE)
	//Writeln("enableNameLookup ",dumpExpr(pecode,NULL))
	all_decls=new PCTObject[]
	fscan_for_decls=function(PExpression pe){
		if isBuiltin(pe,g_id_function):return 0
		if isBuiltin(pe,g_id_store):
			pe_var=readPool(pe+EXPR_OFS_ARGS+0)
			pobj_var=getVariable(pe_var)
			//Writeln(pobj_var,' ',getIdString(readPool(pobj_var+VAR_OFS_ID)),' ',dumpObject(readPool(pobj_var+VAR_OFS_OWNER)),' ',dumpObject(pobjfn))
			if pobj_var&&readPool(pobj_var+VAR_OFS_OWNER)==pobjfn:
				id=readPool(pobj_var+VAR_OFS_ID)
				if id&&!isTempId(id):
					all_decls.push(pobj_var)
			return 1
		return 1
	}
	dfsExpr(pecode,fscan_for_decls)
	all_decls.Sort()
	all_decls.Unique()
	all_ids=new int[all_decls.n]
	foreach pobj_var,I in all_decls
		id=readPool(pobj_var+VAR_OFS_ID)
		writeGlobalI2Hash(int2(pobjfn,id),pobj_var)
		all_ids[I]=id
	n0=int(g_ctobject_pool.n)
	g_ctobject_pool.push(all_ids)
	writePool(pobjfn+FUNCTION_OFS_PMEMBER_LIST,n0)
	writePool(pobjfn+FUNCTION_OFS_NMEMBER_LIST,int(all_ids.n))
	setFFlag(pobjfn,FFLAG_NAME_LOOKUP_READY)

tm_lookup=tnew("lookupFunctionVariable")
tm_evalcb=tnew("eval_callbacks")
tm_strflatten=tnew("strflatten")
auto lookupFunctionVariable(PCTObject pobjfn,int id)
	//tbegin(tm_lookup)
	enableNameLookup(pobjfn)
	ret=readGlobalI2Hash(int2(pobjfn,id))
	//tend(tm_lookup)
	return ret

auto readCtUniqueInEvalFlow(PExpression pe_queued,int[] key)
	pobj_ret=ctUnique(key)
	if pobj_ret:
		if readPool(pobj_ret)!=g_tid_TCtUniqueEvalQueue:
			return pobj_ret
	if pe_queued:
		key2=new(key)
		key2.push(1)
		is_in_queue=ctUnique(key2)
		if is_in_queue:return 0
		ctUnique(key2)=1
		ctUnique(key)=poolObject(TCtUniqueEvalQueue(){'next':pobj_ret,'pe':pe_queued})
	return 0

auto writeCtUniqueInEvalFlow(int[] key,PCTObject pobj)
	pobj_old=ctUnique(key)
	if pobj_old:
		if readPool(pobj_old)!=g_tid_TCtUniqueEvalQueue:
			if Platform.BUILD=="debug":
				Writeln('bad writeCtUniqueInEvalFlow: ',dumpObject(pobj_old),' already there ',key)
			assert(0)
			return
		for(;pobj_old;)
			qitem=readPoolTyped(pobj_old,TCtUniqueEvalQueue)
			pobj_old=qitem.next
			pe=qitem.pe
			flags=readPool(pe)
			if (flags&EFLAG_MASK)!=EFLAG_FCALL:
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if pecaller:sccpQueueEval(pecaller)
			else
				sccpQueueEval(pe)
	ctUnique(key)=pobj

////////////////////////////////////
auto replaceBlockArgs(PExpression pe,PExpression[] as_new,int do_insertcallat)
	n_args=getFCallNArgs(pe)
	if int(as_new.n)<=n_args:
		n2=int(as_new.n)
		writePool(pe,n2+EFLAG_FCALL)
		for i=0:n2-1
			writePool(pe+EXPR_OFS_ARGS+i,as_new[i])
			writePool(as_new[i]+EXPR_OFS_CALLER,pe)
	else
		fexpandblock=function(PExpression pe){
			pe_ret=vcall(g_id_block,as_new)
			writePool(pe_ret+1,readPool(pe+1))
			writePool(pe_ret+2,readPool(pe+2))
			writePool(pe_ret+EXPR_OFS_USER_FLAGS,readPool(pe+EXPR_OFS_USER_FLAGS))
			//writePool(pe_ret+EXPR_OFS_NAME_OR_VAR,readPool(pe+EXPR_OFS_NAME_OR_VAR))
			writePool(pe_ret+EXPR_OFS_VALUE,readPool(pe+EXPR_OFS_VALUE))
			writePool(pe_ret+EXPR_OFS_VALUE+1,readPool(pe+EXPR_OFS_VALUE+1))
			foreach pe_argi in as_new
				writePool(pe_argi+EXPR_OFS_CALLER,pe_ret)
			return pe_ret
		}
		pecaller=readPool(pe+EXPR_OFS_CALLER)
		if do_insertcallat&&pecaller:
			return sccpQueueReach(insertCallAt(pecaller,pe,fexpandblock))
		else
			return fexpandblock(pe)
	return pe

auto appendCode(PCTObject pobjfn,PExpression[] new_args)
	//fn=readPoolTyped(pobjfn,TFunction)
	code=readPool(pobjfn+FUNCTION_OFS_CODE)
	assert(isBuiltin(code,g_id_block))
	n_args=getFCallNArgs(code)
	as_new=new int[n_args]
	for i=0:n_args-1
		as_new[i]=readPool(code+EXPR_OFS_ARGS+i)
	foreach pe in new_args
		sccpQueueReach(pe)
		as_new.push(pe)
	code=replaceBlockArgs(code,as_new,1)
	writePool(pobjfn+FUNCTION_OFS_CODE,code)

auto fillNestDepths()
	auto dfsFillNestDepth(PExpression pe,int nest_depth)
		nest_depth_recurse=nest_depth
		if isExpr(pe,EFLAG_FCALL)
			if isBuiltin(pe,g_id_function):
				nest_depth_recurse++
				pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
				assert(!!pobjfn)
				if pobjfn:
					writePool(pobjfn+FUNCTION_OFS_NEST_DEPTH,nest_depth)
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				dfsFillNestDepth(readPool(pe+EXPR_OFS_ARGS+i),nest_depth_recurse)
	dfsFillNestDepth(g_pe_top,0)

//returns replacement_expression, (simple) has_sideeffect
auto dfsFlattenBlocks(PExpression[] block_as,PExpression pe,int nest_depth, int do_cleanup)
	//ignore the unreached
	//if getExprValue(pe).tid==g_vtid_UNREACHED:
	//Writeln(pe,' ',dumpExpr(pe,fcolor_abbrv_blocks))
	nest_depth_recurse=nest_depth
	if isBuiltin(pe,g_id_function):
		nest_depth_recurse++
		pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
		assert(!!pobjfn)
		if pobjfn:
			writePool(pobjfn+FUNCTION_OFS_NEST_DEPTH,nest_depth)
	//if !testUserFlag(pe,QUEUE_FLAG_REACH):
	//	//Writeln("X "+dumpExpr(pe,fcolor_abbrv_blocks))
	//	return pe,1
	//Writeln("F "+dumpExpr(pe,fcolor_abbrv_blocks))
	//if do_cleanup:
	//this should have been safe for non-final uses
	if isExpr(pe,EFLAG_VARIABLE)||isExpr(pe,EFLAG_FCALL)&&(isBuiltin(pe,g_id_dot)&&readPool(readPool(pe+EXPR_OFS_CALLER)+EXPR_OFS_FUNCTION)!=pe||isBuiltin(pe,g_id_ldlambda)||isBuiltin(pe,g_id_cast)||isBuiltin(pe,g_id_has_member)||isArithmetic(pe)):
		val=getExprValue(pe)
		if val.tid==g_vtid_CNS||val.tid==g_vtid_STR||val.tid==g_vtid_CTVAL:
			if val.tid==g_vtid_CTVAL:
				pesubstitute=poolCode(TCnsExpression(){'flags_cid':val.val+EFLAG_CTVAL})
			else
				pesubstitute=poolCode(TCnsExpression(){'flags_cid':val.val+((val.tid==g_vtid_CNS)?EFLAG_CONST:EFLAG_STRING)})
			return int2(pesubstitute,0)
		//return pe,1
	if !isExpr(pe,EFLAG_FCALL):
		return int2(pe,0)
	n_args=getFCallNArgs(pe)
	if isBuiltin(pe,g_id_block):
		pecaller=readPool(pe+EXPR_OFS_CALLER)
		//assert(n_args>0)
		//pe_args=readPool(pe+EXPR_OFS_ARGS+0)
		//bflags=getExprValueAs(pe_args,g_vtid_CNS)
		//Writeln('scanning block: ',dumpExpr(pe,NULL))
		if !pecaller||isStatementHost(pecaller)://||(bflags&(BFLAG_LOOP|BFLAG_BREAK_CONTINUE_USED)):
			//it's a valid host
			//Writeln('not-pulled ',pe,' ',pecaller,' ',pecaller?isStatementHost(pecaller):0)
			as_new=new PExpression[]
			for i=0:n_args-1
				peargi=readPool(pe+EXPR_OFS_ARGS+i)
				assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
				peargi=dfsFlattenBlocks(as_new,peargi,nest_depth_recurse, do_cleanup).x
				if peargi&&!isBuiltin(peargi,g_id_nop):
					as_new.push(peargi)
			n2=0
			foreach pei in as_new
				//isBuiltin(pei,g_id_function)
				if isExpr(pei,EFLAG_VARIABLE)||isExpr(pei,EFLAG_CONST)||isExpr(pei,EFLAG_STRING)||isExpr(pei,EFLAG_CTVAL):
					//nothing
				else
					as_new[n2++]=pei
			as_new.resize(n2)
			pe_ret=replaceBlockArgs(pe,as_new,0)
			return int2(pe_ret,1)
		else
			//we should pull it out
			//Writeln('pull out ',dumpExpr(pe,NULL))
			for i=0:n_args-2
				peargi=readPool(pe+EXPR_OFS_ARGS+i)
				assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
				peargi=dfsFlattenBlocks(block_as,peargi,nest_depth_recurse, do_cleanup).x
				writePool(peargi+EXPR_OFS_CALLER,0)
				if peargi&&!isBuiltin(peargi,g_id_nop):
					block_as.push(peargi)
			peargi=readPool(pe+EXPR_OFS_ARGS+n_args-1)
			assert(readPool(peargi+EXPR_OFS_CALLER)==pe)
			dfsret=dfsFlattenBlocks(block_as,peargi,nest_depth_recurse, do_cleanup)
			(peargi,has_sideeffect)=(dfsret.x,dfsret.y)
			writePool(peargi+EXPR_OFS_CALLER,0)
			return int2(peargi,has_sideeffect)
	else
		//just dfs
		if isBuiltin(pe,g_id_assert_ctval)||isBuiltin(pe,g_id_dummy_use):return int2(0,0)
		if do_cleanup&&isBuiltin(pe,g_id_if):
			pe_cond=readPool(pe+EXPR_OFS_ARGS+0)
			val_cond=getExprValue(pe_cond)
			//if val_cond.tid==g_vtid_UNINIT:
			//	assert(0)
			if val_cond.tid==g_vtid_CNS||val_cond.tid==g_vtid_STR:
				//todo: condition's side effect
				cns_branch=computeConstIfBranch(pe,val_cond)
				pe_chosen_branch=readPool(pe+EXPR_OFS_ARGS+cns_branch)
				setnop(pe)
				//Writeln(">>> "+dumpExpr(pe_chosen_branch,fcolor_reach_eval))
				dfsret=dfsFlattenBlocks(block_as,pe_chosen_branch,nest_depth_recurse, do_cleanup)
				(pesubstitute,has_sideeffect)=(dfsret.x,dfsret.y)
				return int2(pesubstitute,has_sideeffect)
		if isBuiltin(pe,g_id_store):{
			if n_args==3:
				//force-declaration no longer makes sense
				writePool(pe,2|EFLAG_FCALL)
			//clean up the expr
			peargi0=readPool(pe+EXPR_OFS_ARGS+1)
			assert(readPool(peargi0+EXPR_OFS_CALLER)==pe)
			dfsret=dfsFlattenBlocks(block_as,peargi0,nest_depth_recurse, do_cleanup)
			(peargi,has_sideeffect)=(dfsret.x,dfsret.y)
			if peargi!=peargi0:
				writePool(pe+EXPR_OFS_ARGS+1,peargi)
				writePool(peargi+EXPR_OFS_CALLER,pe)
			if do_cleanup&&!has_sideeffect:
				//eliminate side-effect-free stores
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				val=getExprValue(pe_var)
				if val.tid==g_vtid_CNS||val.tid==g_vtid_STR||val.tid==g_vtid_CTVAL:
					//pobj_var=getVariable(pe_var)
					//if readPool(pobj_var+VAR_OFS_ID)!=g_id_return:
					return int2(0,0)
			return int2(pe,1)
		}
		has_sideeffect=!isArithmetic(pe)
		is_function=isBuiltin(pe,g_id_function)
		for i=-1:n_args-1
			peargi0=readPool(pe+EXPR_OFS_ARGS+i)
			if Platform.BUILD=="debug":
				if readPool(peargi0+EXPR_OFS_CALLER)!=pe:
					Writeln(FormatAsText(dumpExpr(pe,fcolor_abbrv_blocks),' ',dumpExpr(peargi0,fcolor_abbrv_blocks)))
			assert(readPool(peargi0+EXPR_OFS_CALLER)==pe)
			dfsret=dfsFlattenBlocks(block_as,peargi0,nest_depth_recurse, do_cleanup)
			(peargi,has_sideeffect_i)=(dfsret.x,dfsret.y)
			has_sideeffect|=has_sideeffect_i
			if peargi!=peargi0:
				if is_function&&i==n_args-1:
					//__function case: replace fn.code
					pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
					writePool(pobjfn+FUNCTION_OFS_CODE,peargi)
				writePool(pe+EXPR_OFS_ARGS+i,peargi)
				writePool(peargi+EXPR_OFS_CALLER,pe)
		if do_cleanup&&!has_sideeffect:
			val=getExprValue(pe)
			if val.tid==g_vtid_CNS||val.tid==g_vtid_STR:
				pesubstitute=poolCode(TCnsExpression(){'flags_cid':val.val+((val.tid==g_vtid_CNS)?EFLAG_CONST:EFLAG_STRING)})
				return int2(pesubstitute,0)
		//return removeTrivialArithmetic(pe),1
		return int2(pe,1)

auto flattenBlocks()
	//g_pe_top=dfsFlattenBlocks(NULL,g_pe_top,0,1)
	g_pe_top=dfsFlattenBlocks(PExpression[].NULL,g_pe_top,0,0).x
	
auto cleanup()
	g_pe_top=dfsFlattenBlocks(PExpression[].NULL,g_pe_top,0,1).x
	if Platform.BUILD=="debug":
		dfsExpr(g_pe_top,function(PExpression pe){g_counters_final_code_size++;return 1;})

////////////////////////////////////
//the type system
//inline PExpression castto(PExpression petype,PExpression pe)
//	return call(g_id_cast,petype,pe)

auto typeMerge(PExpression pe,PCTObject t_old,PCTObject t_new,PExpression pe_old,PExpression pe_new,int is_arith)
	if t_old==t_new:return t_old
	if !t_old||!t_new:return 0
	if g_ctype_fixed:
		if t_new==getBuiltinType(CTYPE_POINTER)&&tisclass(t_old):
			//ignore fixed new types
			return t_old
		if t_old==getBuiltinType(CTYPE_POINTER)&&tisclass(t_new):
			//ignore changed old types
			return t_new
	if is_arith:
		if tisbuiltin(t_old)&&tisbuiltin(t_new):
			ct_old=readPool(t_old+1)
			ct_new=readPool(t_new+1)
			if (ct_old&CTYPE_MASK)==(ct_new&CTYPE_MASK):
				return getBuiltinType(max(ct_old,ct_new))
			//todo: promote to float
			if (ct_old&CTYPE_MASK)==CTYPE_FLOAT||(ct_new&CTYPE_MASK)==CTYPE_FLOAT:
				return getBuiltinType(max(ct_old&~CTYPE_MASK,ct_new&~CTYPE_MASK)+CTYPE_FLOAT)
			//todo: report invalid type promotion
			return 0
	if pe_old<0:
		//it's different assignments of a same variable
		pobj_var=(pe_old&0x7fffffff)
		all_t_olds=new PCTObject[]
		all_pe_olds=new PExpression[]
		for(pestore=readPool(pobj_var+VAR_OFS_STORE_QUEUE);pestore;pestore=readPool(pestore+EXPR_OFS_NEXT_V_USER))
			if isBuiltin(pestore,g_id_store):
				pe_value=readPool(pestore+EXPR_OFS_ARGS+1)
			else if isBuiltin(pestore,g_id_stdot):
				pe_value=readPool(pestore+EXPR_OFS_ARGS+2)
			else
				assert(0)
				continue
			t_old_2=getExprType(pe_value)
			if t_old_2!=t_new&&t_old_2:
				all_t_olds.push(t_old_2)
				all_pe_olds.push(pestore)
		if !all_pe_olds.n:
			s_t_olds=dumpType(t_old)
			s_pe_olds="<unknown>"
		else
			all_t_olds_bak=new(all_t_olds)
			all_t_olds.Sort()
			all_t_olds.Unique()
			if all_t_olds.n>1:
				s_t_olds=new string
				foreach t_old_2 in all_t_olds_bak.ReverseOrder()
					if s_t_olds.n:s_t_olds.push(',')
					s_t_olds.push(dumpType(t_old_2))
			else
				s_t_olds=dumpType(all_t_olds[0])
			s_pe_olds=new string
			foreach pe_old_2 in all_pe_olds.ReverseOrder()
				if s_pe_olds.n:s_pe_olds.push(';')
				s_pe_olds.push(citeexpr(pe_old_2))
		errorAtExpr(ETYPE_ERROR,pe,"variable '@1' was of type '@2' in previous statements '@3', but it becomes '@4' in '@5'".Replace([
			"@1",getIdString(readPool(pobj_var+VAR_OFS_ID)),
			"@2",s_t_olds,
			"@3",s_pe_olds,
			"@4",dumpType(t_new),
			"@5",citeexpr(pe)]))
	else if pe_old==pe_new:
		//panic
		errorAtExpr(ETYPE_ERROR,pe,"panic: the same expression '@1' evaluated into different types '@2' and '@3'".Replace([
			"@1",citeexpr(pe_old),
			"@2",dumpType(t_old),
			"@3",dumpType(t_new)]))
	else
		errorAtExpr(ETYPE_ERROR,pe,"type mismatch between type '@3' operand '@1' and type '@4' operand '@2'".Replace([
			"@1",citeexpr(pe_old),
			"@2",citeexpr(pe_new),
			"@3",dumpType(t_old),
			"@4",dumpType(t_new)]))
	return 0//getStdObject(0,STDTYPE_VARIANT)

auto castConst(TConstValue ca,PCTObject t_result)
	if tisclass(t_result)&&ca.type==CTYPE_POINTER&&!ca.val_bin:
		return TConstValue(){'type':CTYPE_TYPED_NULL,'val_bin':i64(t_result)}
	if !tisbuiltin(t_result):
		return TConstValue(){'type':CTYPE_INVALID}
	ct_result=readPool(t_result+1)
	assert(u32(ct_result)<u32(CTYPE_COUNT))
	if ca.type==ct_result:return ca
	if ca.type==CTYPE_TYPED_NULL||ca.type==CTYPE_INVALID||ca.type==CTYPE_POINTER&&ca.val_bin&&((ct_result&CTYPE_MASK)==CTYPE_FLOAT):
		return TConstValue(){'type':CTYPE_INVALID}
	canorm=ca
	n_bits=((ca.type&~CTYPE_MASK)+1)*8
	if ((ca.type&CTYPE_MASK)==CTYPE_INT):
		mask=(i64(1)<<n_bits)-1
		canorm.val_bin=(ca.val_bin&mask)|-(ca.val_bin&(i64(1)<<(n_bits-1)))
	else if ((ca.type&CTYPE_MASK)==CTYPE_UINT):
		mask=(i64(1)<<(((ca.type&~CTYPE_MASK)+1)*8))-1
		canorm.val_bin=(ca.val_bin&mask)
	if ((ct_result&CTYPE_MASK)!=CTYPE_FLOAT)&&((ca.type&CTYPE_MASK)!=CTYPE_FLOAT):
		canorm.type=ct_result
		return canorm
	//////////////////////
	//source to double
	dval=0.
	if ((canorm.type&CTYPE_MASK)==CTYPE_INT):
		dval=f64(canorm.val_bin)
	else if ((ca.type&CTYPE_MASK)==CTYPE_UINT):
		dval=f64(u64(canorm.val_bin))
	else
		if ca.type==CTYPE_POINTER:
			assert(!ca.val_bin)
			dval=0.
		else
			assert((ca.type&CTYPE_MASK)==CTYPE_FLOAT)
			if ca.type==const_type(CTYPE_FLOAT,32):
				dval=f64(__int_as_float(i32(ca.val_bin)))
			else
				assert(ca.type==const_type(CTYPE_FLOAT,64))
				dval=__longlong_as_double(ca.val_bin)
	////////////////////////////////
	//double to destination
	ret=ca
	ret.type=ct_result
	if ((ct_result&CTYPE_MASK)==CTYPE_INT):
		ret.val_bin=i64(dval)
	else if ((ct_result&CTYPE_MASK)==CTYPE_UINT):
		ret.val_bin=u64(dval)
	else
		if (ct_result&CTYPE_MASK)!=CTYPE_FLOAT:
			return TConstValue(){'type':CTYPE_INVALID}
		if ct_result==const_type(CTYPE_FLOAT,32):
			ret.val_bin=i64(__float_as_int(f32(dval)))
		else
			assert(ct_result==const_type(CTYPE_FLOAT,64))
			ret.val_bin=__double_as_longlong(dval)
	return ret

auto idCastConstI32(int val,PCTObject t_result)
	cval=castConst(TConstValue(){'val_bin':i64(val),'type':const_type(CTYPE_INT,32)},t_result)
	return getid_const(cval.type,cval.val_bin)

USER_FLAG_RC_SLOTID_MASK=0x01ffffff
USER_FLAG_RC_IS_SAFE_STORE=0x04000000
//USER_FLAG_RC_IS_GENERATED_STORE=0x02000000
USER_FLAG_RC_STORE_WITHOUT_ADDREF=0x02000000
VAR_USER_FLAG_RC_SLOTID_MASK=0x03ffffff
VAR_USER_FLAG_RC_SLOT_ALLOCATED=0x04000000
auto ancestorMerge(const is_death,PExpression pe_old0,PExpression pe_new0,function(int):int fgetdepth,function(int):int fgetbirthid)
	//return the merged and whether the new one can be considered as a safe-store
	pe_old=pe_old0
	pe_new=pe_new0
	if !pe_old:return int2(pe_new,1)
	is_store_safe=0
	//Writeln('-------------------------')
	for(;;)
		//Writeln(dumpExpr(pe_old,fcolor_abbrv_blocks)+' vs '+dumpExpr(pe_new,fcolor_abbrv_blocks))
		assert(!!pe_old)
		assert(!!pe_new)
		pecaller_old=readPool(pe_old+EXPR_OFS_CALLER)
		pecaller_new=readPool(pe_new+EXPR_OFS_CALLER)
		slotid_old=(readPool(pe_old+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
		slotid_new=(readPool(pe_new+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
		if pecaller_old==pecaller_new:
			//same level, not safe for stores, return the later one
			if is_death:
				return int2(slotid_old>slotid_new?pe_new:pe_old,is_store_safe)
			else
				slotid_old=fgetbirthid(slotid_old)
				slotid_new=fgetbirthid(slotid_new)
				return int2(slotid_old<slotid_new?pe_new:pe_old,is_store_safe)
		depth_old=fgetdepth(slotid_old)
		depth_new=fgetdepth(slotid_new)
		if depth_old==depth_new:
			pecaller_caller_old=readPool(pecaller_old+EXPR_OFS_CALLER)
			pecaller_caller_new=readPool(pecaller_new+EXPR_OFS_CALLER)
			if pecaller_caller_old==pecaller_caller_new&&isBuiltin(pecaller_caller_old,g_id_if):
				//different branches of the same if, store is safe
				is_store_safe=1
			pe_old=pecaller_old
			pe_new=pecaller_new
		else if depth_old>depth_new:
			pe_old=pecaller_old
		else
			pe_new=pecaller_new

auto removeSCCPJunk()
	fremove_junk=function(PExpression pe){
		if isBuiltin(pe,g_id_assert_ctval):
			//remove the assert_ctval guys
			setnop(pe)
			return 0
		if isBuiltin(pe,g_id_function):
			id_ccnv=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_STR)
			if id_ccnv==g_id_inline||id_ccnv==g_id_inline_loopbody:
				//remove all inline functions
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				insertCallAt(pecaller,pe,function(){return expriptr(0)})
				return 0
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
				if i>=0:
					//simplify the types in function declarations
					val=getExprValue(pe_argi)
					if val.tid==g_vtid_CTVAL&&!isExpr(pe_argi,EFLAG_CTVAL):
						writePool(pe_argi,EFLAG_CTVAL+val.val)
				dfsExpr(pe_argi,fremove_junk)
			if readPool(pe)==EFLAG_FCALL+n_args:
				pe_code=readPool(pe+EXPR_OFS_ARGS+n_args-1)
				if isExpr(pe_code,EFLAG_FCALL):
					//make return explicit
					pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
					pvar_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
					as=new PExpression[]
					if g_enable_debug_instrumentation:
						as.push(call(g_id_callstack,exprctval(pobjfn)))
					as.push(pe_code)
					as.push(pvar_return?call(g_id_C_return,exprvar(pvar_return)):call(g_id_C_return))
					sccpQueueReach(insertCallAt(pe,~(n_args-1),function(){return vcall(g_id_block,as)}))
					sccpProcessReaches()
					//Writeln(">>> "+dumpExpr(pe,fcolor_reach_eval))
			return 0
		if isBuiltin(pe,g_id_store):
			pe_value=readPool(pe+EXPR_OFS_ARGS+1)
			if isBuiltin(pe_value,g_id_aliased)||isBuiltin(pe_value,g_id_uninit):
				//remove the & hacks and the declaration hacks
				setnop(pe)
				return 0
		if !testUserFlag(pe,QUEUE_FLAG_REACH)
			pecaller=readPool(pe+EXPR_OFS_CALLER)
			if isBuiltin(pe,g_id_block):
				if isBuiltin(pecaller,g_id_function):
					//unused function, smash the function
					writePool(pe,EFLAG_STRING+g_empty_id)
				else if isStatementHost(pecaller):
					//unused if branch, smash itself
					writePool(pe,EFLAG_STRING+g_empty_id)
				return 0
		return 1
	}
	dfsExpr(g_pe_top,fremove_junk)

auto getRootNamespaceType()
	assert(isBuiltin(g_pe_top,g_id_export))
	assert(isBuiltin(readPool(g_pe_top+EXPR_OFS_ARGS+1),g_id_function))
	return getExprValueAs(readPool(g_pe_top+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
	
auto fixConstantTypes()
	//it must not be a builtin/imported param
	//but const-to-var stores are an exception
	//we may need to call functions - another round of sccp, but with a switch flagged - types change
	//change the value definition? function-with-this-bounded-to? no
	//const-dotted has to be directly called, or 'this' will be ignored, it's our restriction
	//constify the const calls, then replace the function-ctval at store boundaries - ignore other cases for now
	g_sccp_queue_reach.clear()
	g_sccp_queue_eval.clear()
	ffix_const_types=function(PExpression pe){
		if isExpr(pe,EFLAG_FCALL)&&!testUserFlag(pe,QUEUE_FLAG_REACH):return 0
		//if isExpr(pe,EFLAG_FCALL):
		val=getExprValue(pe)
		pecaller=readPool(pe+EXPR_OFS_CALLER)
		if pecaller:
			if val.tid==g_vtid_CTVAL:
				if readPool(pecaller+EXPR_OFS_FUNCTION)==pe:
					//ordinary function, ignore
					if !isBuiltin(pe,g_id_dot):return 1
					//it's dot-called, check for type matchness
					pobjfn=val.val
					t_obj=getExprType(readPool(pe+EXPR_OFS_ARGS+0))
					t_parent=getOwningFunction(readPool(readPool(pobjfn+FUNCTION_OFS_PEDECL)+EXPR_OFS_CALLER))
					if t_obj==t_parent:
						//good type
						return 1
					else
						//otherwise, we do need to pointerify it
						//Writeln(dumpExpr(pecaller,fcolor_reach_eval))
			if (val.tid==g_vtid_CTVAL&&readPool(val.val)==g_tid_TFunction||val.tid==g_vtid_STR)&&!isBuiltin(pe,g_id_ldparam):
				need_to_translate=0
				ignore_dot=0
				pobjfn_caller=getExprFunction(pecaller)
				if val.tid==g_vtid_CTVAL&&readPool(pecaller+EXPR_OFS_FUNCTION)==pe:
					//dotcall
					need_to_translate=1
					ignore_dot=1
				else if !pobjfn_caller||!(getFFlag(pobjfn_caller)&(FFLAG_BUILTIN|FFLAG_IMPORTED)):
					//normal call, translate
					need_to_translate=1
				else if isBuiltin(pecaller,g_id_dot)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
					//val.tid==g_vtid_STR
					pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
					if readPool(pecaller_caller+EXPR_OFS_FUNCTION)==pecaller:
						//dot caller - str only so no need of sccp test
						//141106: it's no longer str only - functions
						need_to_translate=1
				else if (isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+1)==pe||
				isBuiltin(pecaller,g_id_stdot)&&readPool(pecaller+EXPR_OFS_ARGS+2)==pe):
					//it's stored, test the target
					if isBuiltin(pecaller,g_id_stdot):
						pobj_member=getDotMember(pecaller,1)
						val_var=readPoolTyped(pobj_member,TSCCPValue)
					else
						pe_var=readPool(pecaller+EXPR_OFS_ARGS+0)
						val_var=getExprValue(pe_var)
					if val_var.tid==g_vtid_RTVAR:
						//stored to var, translate
						need_to_translate=1
				if need_to_translate:
					//const -> var link, translate
					//Writeln('>>> '+dumpExpr(pe,fcolor_abbrv_blocks))
					if val.tid==g_vtid_CTVAL:
						//function value, make the struct
						setFFlag(val.val,FFLAG_HAS_FPTR_TAKEN)
						got_this=0
						if isBuiltin(pe,g_id_dot)&&!ignore_dot:
							pe_this=readPool(pe+EXPR_OFS_ARGS+0)
							got_this=1
						else
							t_parent=getOwningFunction(readPool(readPool(val.val+FUNCTION_OFS_PEDECL)+EXPR_OFS_CALLER))
							//we need a lambda context - put a smart g_id_get_lambda_context
							//pe_this=exprcns(getid_const(CTYPE_POINTER,0LL))
							pe_this=call(g_id_get_lambda_context,exprctval(t_parent))
						t=getValueType(val)
						if Platform.BUILD=="debug":
							if !t:
								Writeln('caller: '+dumpExpr(pecaller,fcolor_abbrv_blocks))
								Writeln('function: '+dumpExpr(pe,fcolor_abbrv_blocks))
						assert(!!t)
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						//we have to keep pe in case it's a function decl, but we don't want to ass it that way
						sccpQueueReach(insertCallAt(pecaller,pe,function(PExpression pe){
							auto pe_dummy=(ignore_dot||got_this)?expriptr(0):pe;
							return indcall([exprctval(getStdObject(0,STDFN_MAKE_FUNCTION)),exprctval(t),pe_this,exprctval(val.val),pe_dummy]);
						}))
						return 1
					else
						assert(val.tid==g_vtid_STR)
						pe_new=indcall([exprctval(getStdObject(0,STDFN_MAKE_STRING)),exprstr(val.val),expriptr(getIdString(val.val).n)])
						transformCode(pe,NULL, NULL,pe_new,NULL)
						return 1
			else if val.tid==g_vtid_RTVAR:
				t=val.val
				if tisclass(t):
					pobjfn_caller=getExprFunction(pecaller)
					if pobjfn_caller&&(getFFlag(pobjfn_caller)&FFLAG_IMPORTED):
						//class to C, check method
						if lookupFunctionVariable(t,g_id_C_autocast):
							//we got one, call it
							sccpQueueReach(insertCallAt(pecaller,pe,function(PExpression pe){return indcall([call(g_id_dot,pe,exprstr(g_id_C_autocast))])}))
							return 1
			//Writeln(">>> "+dumpExpr(pecaller,fcolor_abbrv_blocks)+" "+dumpExpr(pe,fcolor_abbrv_blocks)+" "+getIdString(val.tid))
		return 1
	}
	dfsExpr(g_pe_top,ffix_const_types)
	g_ctype_fixed=1
	sccp(0)

//g_dump_eval=0
auto translateLambdas()
	flattenBlocks()
	g_sccp_queue_reach.clear()
	g_sccp_queue_eval.clear()
	//mark the RTTI needs
	//Writeln('--- 0')
	fmark_rtti=function(PExpression pe){
		if isBuiltin(pe,g_id_cast):
			t_target=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
			if t_target==getStdObject(0,STDTYPE_VARIANT):
				t_source=getExprType(readPool(pe+EXPR_OFS_ARGS+1))
				if t_source&&readPool(t_source)==g_tid_TFunction:
					assert(!tisstruct(t_source))
					setFFlag(t_source,FFLAG_LAMBDA_NEEDS_RTTI)
		else if isBuiltin(pe,g_id_get_rtti):
			//object RTTI shouldn't set the flag - it doesn't happen
			t_rtti_source=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
			if t_rtti_source&&readPool(t_rtti_source)==g_tid_TFunction:
				assert(!tisstruct(t_rtti_source))
				setFFlag(t_rtti_source,FFLAG_LAMBDA_NEEDS_RTTI)
		return 1
	}
	dfsExpr(g_pe_top,fmark_rtti)
	setFFlag(getStdObject(0,STDTYPE_VARIANT),FFLAG_LAMBDA_NEEDS_RTTI)
	//label the namespace variables for globalification
	t_root_namespace=getRootNamespaceType()
	g_t_root_namespace=t_root_namespace
	//scan for lambdas
	pobj_local_owner=0
	lambda_stack=new PCTObject[]
	//Writeln('--- 1')
	g_all_lambdas=new PCTObject[]
	fscan_for_lambdas=function(PExpression pe){
		//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&!isExpr(pe,EFLAG_VARIABLE):
		//	return 0
		if isBuiltin(pe,g_id_function):
			pobjfn_bk=pobj_local_owner
			pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
			assert(!!pobjfn)
			pobj_local_owner=pobjfn
			lambda_stack.push(pobjfn)
			for i=0:(readPool(pe)&~EFLAG_MASK)-1
				dfsExpr(readPool(pe+EXPR_OFS_ARGS+i),fscan_for_lambdas)
			//if pobjfn:
			lambda_stack.pop()
			pobj_local_owner=pobjfn_bk
			return 0
		if isBuiltin(pe,g_id_dot)||isBuiltin(pe,g_id_stdot):
			pe_member_name=readPool(pe+EXPR_OFS_ARGS+1)
			if isExpr(pe_member_name,EFLAG_CTVAL):
				//hack for template, don't translate
				val=getExprValueAs(pe_member_name,g_vtid_CTVAL)
				if !isVariable(val):
					return 1
			pobj_member=getDotMember(pe,0)
			if !pobj_member:
				//errored expr
				setnop(pe)
				return 1
			if isBuiltin(pe,g_id_dot):
				tid=readPool(pobj_member)
				if tid!=g_vtid_RTVAR:
					//const case
					if tid==g_vtid_CTVAL:
						//ctval: leave it a dot, but replace it with a ctval-hack-dot
						writePool(pe_member_name,EFLAG_CTVAL+readPool(pobj_member+1))
						return 1
					else if tid==g_vtid_CNS:
						writePool(pe,EFLAG_CONST+readPool(pobj_member+1))
						return 1
					else if tid==g_vtid_STR:
						writePool(pe,EFLAG_STRING+readPool(pobj_member+1))
						return 1
					assert(tid==g_vtid_UNINIT)//in this case, just give an error
				idfn=g_id_ldlambda
			else
				idfn=g_id_stlambda
			//if g_names_resolved:
			pobjfn=g_symbols[idfn].user_slot
			insertCallAt(pe,0,function(){return exprvar(pobjfn)})
			//writePool(pe+EXPR_OFS_NAME_OR_VAR,pobjfn)
			assert(!!pobj_member)
			writePool(pe_member_name,EFLAG_CTVAL+pobj_member)
			return 1
		else if isBuiltin(pe,g_id_get_lambda_context):
			pe_levels=readPool(pe+EXPR_OFS_ARGS+0)
			val_levels=getExprValue(pe_levels)
			is_tentative=0
			if val_levels.tid==g_vtid_CTVAL:
				//only function pointer contexts get here
				//coulddo: this process can be made iterative so that we avoid unnecessary contexts
				//but it's easier to just hack this case
				//convert to # levels
				is_tentative=1
				pfowner=val_levels.val
				their_level=-1
				for j=lambda_stack.n-1:-1:0
					if lambda_stack[j]==pfowner:
						their_level=int(j)
						break
				if their_level==lambda_stack.n-1:
					//nothing
				else if their_level<0:
					errorAtExpr(ETYPE_ERROR,pe,"in '@3', one cannot obtain a pointer to function '@1' defined in non-parent function '@2'".Replace([
						"@1",citeexpr(pe),
						"@2",dumpFunction(pfowner),
						"@3",dumpFunction(pobj_local_owner)]))
					writePool(pe,EFLAG_STRING+g_empty_id)
					writePool(lambda_stack[0]+FUNCTION_OFS_FLAGS,readPool(lambda_stack[0]+FUNCTION_OFS_FLAGS)&~(FFLAG_LAMBDA_NEEDS_PARENT_POINTER|FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG))
					return 0
				else if their_level>0:
					//only flag things if it's not the global scope
					setFFlag(pobj_local_owner,FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)
					for j=lambda_stack.n-2:-1:0
						setFFlag(lambda_stack[j],FFLAG_LAMBDA_NEEDS_CONTEXT)
						if j==their_level:
							break
						setFFlag(lambda_stack[j],FFLAG_LAMBDA_NEEDS_PARENT_POINTER|FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)
				else
					//if it's the global... it's simple
					setFFlag(lambda_stack[0],FFLAG_LAMBDA_NEEDS_CONTEXT)
				d_levels=(lambda_stack.n-1-their_level)
				pe_levels=insertCallAt(pe,~0,function(){return expriptr(their_level==0?0x80000000:d_levels)})
			if getExprValueAs(pe_levels,g_vtid_CNS)==0&&!is_tentative:
				//function pointer contexts are tentative: NULL is a good substitution
				setFFlag(pobj_local_owner,FFLAG_LAMBDA_NEEDS_CONTEXT)
		else if isExpr(pe,EFLAG_VARIABLE):
			pobj_var=getVariable(pe)
			pfowner=readPool(pobj_var+VAR_OFS_OWNER)
			if pfowner!=pobj_local_owner&&pfowner&&readPool(pobj_var)==g_vtid_RTVAR:
				//get their context and mark all outer levels as "outer-lambda-needed"
				their_level=-1
				for j=lambda_stack.n-2:-1:0
					if lambda_stack[j]==pfowner:
						their_level=int(j)
						break
				//here we generate a "get lambda": # parent layers, a name / sth
				if their_level<0:
					errorAtExpr(ETYPE_ERROR,pe,"in '@3', one cannot access '@1' from non-parent function '@2'".Replace([
						"@1",citeexpr(pe),
						"@2",dumpObject(pfowner),
						"@3",dumpObject(pobj_local_owner)]))
					writePool(pe,EFLAG_STRING+g_empty_id)
					writePool(lambda_stack[0]+FUNCTION_OFS_FLAGS,readPool(lambda_stack[0]+FUNCTION_OFS_FLAGS)&~(FFLAG_LAMBDA_NEEDS_PARENT_POINTER|FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG))
					return 0
				if their_level>0:
					//only flag things if it's not the global scope
					setFFlag(pobj_local_owner,FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)
					for j=lambda_stack.n-2:-1:0
						setFFlag(lambda_stack[j],FFLAG_LAMBDA_NEEDS_CONTEXT)
						if j==their_level:
							break
						setFFlag(lambda_stack[j],FFLAG_LAMBDA_NEEDS_PARENT_POINTER|FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)
				else
					//if it's the global... it's simple
					setFFlag(lambda_stack[0],FFLAG_LAMBDA_NEEDS_CONTEXT)
				d_levels=(lambda_stack.n-1-their_level)
				//Writeln('scanned lambda: ',d_levels)
				pecontext=call(g_id_get_lambda_context,expriptr(their_level==0?0x80000000:d_levels))
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if readPool(pobj_var+VAR_OFS_ID)==g_id_this:
					//eliminate lambda references of 'this'
					setUserFlag(pecontext,QUEUE_FLAG_REACH)
					writePool(pecontext+EXPR_OFS_VALUE+0,readPool(pobj_var+0))
					writePool(pecontext+EXPR_OFS_VALUE+1,readPool(pobj_var+1))
					sccpQueueReach(insertCallAt(pecaller,pe,function(){return pecontext}))
				else if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
					//g_id_stlambda
					if getFFlag(pfowner)&FFLAG_IS_PARALLEL:
						errorAtExpr(ETYPE_ERROR,pecaller,"parallel function '@1' must not write external variable '@2'".Replace(["@1",dumpFunction(pfowner),"@2",citeexpr(pe)]))
					pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
					faddstlambda=function(PExpression pestore){
						return call(g_id_stlambda, pecontext, exprctval(pobj_var), readPool(pestore+EXPR_OFS_ARGS+1))
					}
					sccpQueueReach(insertCallAt(pecaller_caller,pecaller,faddstlambda))
				else
					//g_id_ldlambda
					faddldlambda=function(){
						return call(g_id_ldlambda, pecontext, exprctval(pobj_var))
					}
					sccpQueueReach(insertCallAt(pecaller,pe,faddldlambda))
				return 0
		return 1
	}
	dfsExpr(g_pe_top,fscan_for_lambdas)
	///////////////////
	//propagate parent-pointer-needed-ness to callers
	fillNestDepths()
	auto dfsFillParentPointer(PCTObject pobjfn)
		pinv=readPool(pobjfn+FUNCTION_OFS_PINV_CALL_GRAPH_EDGES)
		ninv=readPool(pobjfn+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES)
		my_depth=readPool(pobjfn+FUNCTION_OFS_NEST_DEPTH)
		for i=0:ninv-1
			raw_data=readPool(pinv+i)
			pobjfn_caller=raw_data>>1
			//method calls shouldn't count
			if raw_data&1:continue
			if (!(getFFlag(pobjfn_caller)&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)&&
			readPool(pobjfn_caller+FUNCTION_OFS_NEST_DEPTH)>=my_depth):
				setFFlag(pobjfn_caller,FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG)
				dfsFillParentPointer(pobjfn_caller)
	foreach pobjfn in g_all_functions
		if getFFlag(pobjfn)&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
			//Writeln('^_^ ',dumpObject(pobjfn))
			dfsFillParentPointer(pobjfn)
	///////////////////
	//remove the false dots
	fremove_false_dots=function(PExpression pe){
		if isExpr(pe,EFLAG_FCALL):
			pobjfn=getExprFunction(pe)
			if pobjfn&&!(getFFlag(pobjfn)&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG):
				pe_func=readPool(pe+EXPR_OFS_FUNCTION)
				if isBuiltin(pe_func,g_id_dot)||isBuiltin(pe_func,g_id_ldlambda)
					//remove the false dot
					sccpQueueReach(insertCallAt(pe,0,function(){return exprctval(pobjfn)}))
		return 1
	}
	dfsExpr(g_pe_top,fremove_false_dots)
	//Writeln('--- 2')
	///////////////////
	//list the needed lambdas for each function
	fscan_for_lambda_members=function(PExpression pe){
		//if !testUserFlag(pe,QUEUE_FLAG_REACH):
		//	return 0
		if isBuiltin(pe,g_id_ldlambda)||isBuiltin(pe,g_id_stlambda):
			//avoid the const-valued stuff
			val_pe=getExprValue(pe)
			if !(val_pe.tid==g_vtid_CTVAL||val_pe.tid==g_vtid_CNS||val_pe.tid==g_vtid_STR):
				pobj_var=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
				vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
				if !(vflags&VAR_FLAG_LAMBDAED):
					writePool(pobj_var+VAR_OFS_USER_FLAGS,vflags|VAR_FLAG_LAMBDAED)
					//if getVariableType(pobj_var)==4967736:
					//	Writeln(dumpExpr(pe,NULL))
					//assert(getVariableType(pobj_var)!=4967736)
					g_all_lambdas.push(pobj_var)
		return 1
	}
	dfsExpr(g_pe_top,fscan_for_lambda_members)
	//force function type members to be lambdaed
	foreach pobjfn in g_all_functions
		if tisfunction(pobjfn):
			enableNameLookup(pobjfn)
			p_members=readPool(pobjfn+FUNCTION_OFS_PMEMBER_LIST)
			n_members=readPool(pobjfn+FUNCTION_OFS_NMEMBER_LIST)
			for i=0:n_members-1
				id_member=readPool(p_members+i)
				if id_member==g_id_this||id_member==g_id_return||id_member==g_id_ftype_raw:continue
				pobj_var=lookupFunctionVariable(pobjfn,id_member)
				vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
				if !(vflags&VAR_FLAG_LAMBDAED):
					writePool(pobj_var+VAR_OFS_USER_FLAGS,vflags|VAR_FLAG_LAMBDAED)
					g_all_lambdas.push(pobj_var)
	//replace the local accesses of lambdaed vars
	//store_flagged_vars=new PCTObject[]
	//Writeln('--- 3')
	auto dfs_replace_lambdaed(PExpression pe,PCTObject pf_owner,int in_class)
		if isExpr(pe,EFLAG_VARIABLE):
			pobj_var=getVariable(pe)
			if testUserFlag(pobj_var,VAR_FLAG_LAMBDAED)&&readPool(pobj_var)!=g_vtid_CNS:
				//get their context and mark all outer levels as "outer-lambda-needed"
				pecontext=call(g_id_get_lambda_context,expriptr(0))
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
					auto pe_value=readPool(pecaller+EXPR_OFS_ARGS+1)
					if in_class:
						//if !testUserFlag(pobj_var,VAR_USER_FLAG_STORED):
						//	setUserFlag(pobj_var,VAR_USER_FLAG_STORED)
						//	store_flagged_vars.push(pobj_var)
						if readPool(pobj_var+VAR_OFS_DEFINING_STORE)==pecaller:
							val_value=getExprValue(pe_value)
							if isValueZero(val_value)||isBuiltin(pe_value,g_id_uninit):
								//another empty struct ctor case -- deadelim handled it?
								//first zero assignment, remove it
								setnop(pecaller)
								return
					if isBuiltin(pe_value,g_id_ldparam):
						//need an intermediate variable so that rc gets handled properly
						pv_temp=makevar(pf_owner)
						pe_store_temp=call(g_id_store,exprvar(pv_temp),pe_value)
						writePool(pv_temp+0,readPool(pobj_var+0))
						writePool(pv_temp+1,readPool(pobj_var+1))
						setUserFlag(pv_temp,VAR_FLAG_PARAM)
						writePool(pv_temp+VAR_OFS_DEFINING_STORE,pe_store_temp)
						transformCode(pecaller,NULL, [pe_store_temp],call(g_id_stlambda, pecontext, exprctval(pobj_var), exprvar(pv_temp)),NULL)
					else
						pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
						faddstlambda=function(PExpression pestore){
							return call(g_id_stlambda, pecontext, exprctval(pobj_var), pe_value)
						}
						sccpQueueReach(insertCallAt(pecaller_caller,pecaller,faddstlambda))
				else
					//g_id_ldlambda
					faddldlambda=function(){
						return call(g_id_ldlambda, pecontext, exprctval(pobj_var))
					}
					sccpQueueReach(insertCallAt(pecaller,pe,faddldlambda))
				return
		else if isExpr(pe,EFLAG_FCALL):
			pf_owner_recurse=pf_owner
			in_class_recurse=in_class
			//class_cleanup_to=-1
			if isBuiltin(pe,g_id_function):
				pf_owner_recurse=getExprValueAs(pe,g_vtid_CTVAL)
				in_class_recurse=isFunctionClassOrStruct(pf_owner_recurse)//(getCcnv(pf_owner_recurse)==CCNV_CLASS)
				//if in_class_recurse:
				//	class_cleanup_to=store_flagged_vars.n
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				dfs_replace_lambdaed(readPool(pe+EXPR_OFS_ARGS+i),pf_owner_recurse,in_class_recurse)
			//if class_cleanup_to>=0:
			//	for j=class_cleanup_to:store_flagged_vars.n-1
			//		pobj_var=store_flagged_vars[j]
			//		writePool(pobj_var+VAR_OFS_USER_FLAGS,readPool(pobj_var+VAR_OFS_USER_FLAGS)&~VAR_USER_FLAG_STORED)
			//	store_flagged_vars.resize(class_cleanup_to)
	dfs_replace_lambdaed(g_pe_top,0,0)
	//Writeln('--- 4')
	//generate the context classes
	szptr=Util.bitSize()>>3
	inline sort_sizeof(PCTObject t)
		if tisbuiltin(t):
			ct=readPool(t+1)
			return ((ct&~CTYPE_MASK)+1)
		else if tisstruct(t):
			//hack - put structs first
			return 16
		return szptr
	fmember_compare=function(PCTObject va,PCTObject vb){
		auto pf_owner_a=readPool(va+VAR_OFS_OWNER)
		auto pf_owner_b=readPool(vb+VAR_OFS_OWNER)
		if pf_owner_a<pf_owner_b:return 1
		if pf_owner_a==pf_owner_b:
			auto sza=sort_sizeof(getVariableType(va))
			auto szb=sort_sizeof(getVariableType(vb))
			if sza<szb:return 1
			if sza==szb:return va<vb
		return 0
	}
	g_all_lambdas.Sort(fmember_compare)
	p0=int(g_ctobject_pool.n)
	g_ctobject_pool.push(g_all_lambdas)
	pfowner_cur=-1
	plast=0
	foreach pobj_var,I in g_all_lambdas
		pfowner=readPool(pobj_var+VAR_OFS_OWNER)
		if pfowner!=pfowner_cur:
			if pfowner_cur>=0:
				writePool(pfowner_cur+FUNCTION_OFS_NLAMBDA_VARS,int(I-plast))
				writePool(pfowner_cur+FUNCTION_OFS_PLAMBDA_VARS,p0+plast)
			pfowner_cur=pfowner
			plast=int(I)
	if pfowner_cur>=0:
		writePool(pfowner_cur+FUNCTION_OFS_NLAMBDA_VARS,int(g_all_lambdas.n-plast))
		writePool(pfowner_cur+FUNCTION_OFS_PLAMBDA_VARS,p0+plast)
	//translate struct returns / extra returns
	queue_dfsTranslateStruct=new int3[]
	auto dfsTranslateStruct(PExpression pe,PCTObject pf_owner)
		if !isExpr(pe,EFLAG_FCALL):return
		//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
		//Writeln(dumpExpr(pe,fcolor_abbrv_blocks))
		pf_owner_recurse=pf_owner
		pe_recurse_into=pe
		if isBuiltin(pe,g_id_function):
			pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
			pf_owner_recurse=pobjfn
			t_return=getReturnType(pobjfn)
			if tisstruct(t_return):
				//add a last param
				n_args=getFCallNArgs(pe)
				as=new PExpression[n_args+3]
				for i=-1:n_args-2
					as[i+1]=readPool(pe+EXPR_OFS_ARGS+i)
				as[n_args+0]=exprctval(t_return)
				as[n_args+1]=exprstr(g_id_return)
				as[n_args+2]=readPool(pe+EXPR_OFS_ARGS+n_args-1)
				pe_new=indcall(as)
				writePool(pe_new+EXPR_OFS_VALUE,readPool(pe+EXPR_OFS_VALUE))
				writePool(pe_new+EXPR_OFS_VALUE+1,readPool(pe+EXPR_OFS_VALUE+1))
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				//Writeln(dumpExpr(pecaller,fcolor_abbrv_blocks))
				//Writeln(dumpExpr(pe,fcolor_abbrv_blocks))
				//Writeln(dumpExpr(pe_new,fcolor_abbrv_blocks))
				sccpQueueReach(insertCallAt(pecaller,pe,function(){return pe_new}))
				writePool(pobjfn+FUNCTION_OFS_PEDECL,pe_new)
				//pe_recurse_into=pe_new
				n_funcargs_old=(n_args-2)>>1
				//add a parameter slot
				p_param_values=readPool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
				p_param_values_new=int(g_ctobject_pool.n)
				g_ctobject_pool.addn((n_funcargs_old+1)*3)
				for i=0:n_funcargs_old*3-1
					writePool(p_param_values_new+i,readPool(p_param_values+i))
				writePool(p_param_values_new+n_funcargs_old*3+0,g_vtid_RTVAR)
				writePool(p_param_values_new+n_funcargs_old*3+1,t_return)
				writePool(p_param_values_new+n_funcargs_old*3+2,0)
				writePool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS,p_param_values_new)
				//add the ldparam
				pe_recurse_into=pe_new
				if getCcnv(pobjfn)==g_id_struct:
					//in a struct ctor, translate the getlambdactx in the recursion
					//merely remove the return variable here
					//writePool(pobjfn+FUNCTION_OFS_PVAR_RETURN,0)
					writePool(pobjfn+FUNCTION_OFS_TEMP_SLOT,0)
				else
					//in other struct returners, add a *defining* return=ldparam
					pe_ldparam=call(g_id_ldparam,expriptr(n_funcargs_old),exprctval(t_return),exprstr(g_id_return))
					pvar_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
					pe_store_ldparam=call(g_id_store,exprvar(pvar_return),pe_ldparam)
					writePool(pvar_return+VAR_OFS_DEFINING_STORE,pe_store_ldparam)
					pe_code_new=sccpQueueReach(insertCallAt(pe_new,~(n_args+1),function(PExpression pe_code){
						return call(g_id_block,
							pe_store_ldparam,
							pe_code);
					}))
					writePool(pobjfn+FUNCTION_OFS_CODE,pe_code_new)
					writePool(p_param_values_new+n_funcargs_old*3+2,pe_ldparam)
		else if isBuiltin(pe,g_id_get_lambda_context)&&getCcnv(pf_owner)==g_id_struct:
			//in a struct ctor, translate the getlambdactx into ldparam if it's a this-assignment
			//translate it into the this variable for later calls
			pobjfn=pf_owner
			pecaller=readPool(pe+EXPR_OFS_CALLER)
			pv_this=readPool(pobjfn+FUNCTION_OFS_TEMP_SLOT)
			if !pv_this:
				pe_decl=readPool(pobjfn+FUNCTION_OFS_PEDECL)
				n_args_decl=(readPool(pe_decl)&~EFLAG_MASK)
				n_funcargs_new=(n_args_decl-2)>>1
				t_return=getReturnType(pobjfn)
				//if !t_return:
				//	Writeln(dumpFunction(pobjfn),' ',testUserFlag(pe_decl,QUEUE_FLAG_REACH))
				//	Writeln(dumpExpr(pe_decl,NULL))
				//	Writeln('-------------------')
				//	Writeln(dumpExpr(g_pe_top,NULL))
				pe_ldparam=call(g_id_ldparam,expriptr(n_funcargs_new-1),exprctval(t_return),exprstr(g_id_return))
				assert(isBuiltin(pecaller,g_id_store))
				if isBuiltin(pecaller,g_id_store):
					pv_this=getVariable(readPool(pecaller+EXPR_OFS_ARGS+0))
					writePool(pobjfn+FUNCTION_OFS_TEMP_SLOT,pv_this)
				p_param_values_new=readPool(pobjfn+FUNCTION_OFS_PPARAM_VALUE_SLOTS)
				writePool(p_param_values_new+(n_funcargs_new-1)*3+2,pe_ldparam)
			else
				pe_ldparam=exprvar(pv_this)
			sccpQueueReach(insertCallAt(pecaller,pe,function(){return pe_ldparam}))
			//we don't have to recurse any more
			return
		else
			t_return=0
			pecallee=readPool(pe+EXPR_OFS_FUNCTION+0)
			pobjfn=getExprFunction(pe)
			if pobjfn:
				if !(getFFlag(pobjfn)&FFLAG_BUILTIN):
					t_return=getReturnType(pobjfn)
			else
				tcallee=getExprType(pecallee)
				if tcallee&&tisfunction(tcallee):
					tcallee=getRawFunctionType(tcallee)
					ft=readPoolTyped(tcallee,TFunctionType)
					t_return=ft.t_ret
			if tisstruct(t_return):
				//for normal fcalls, translate a=f(b) into f(a,b)
				//in the replace_caller cases, pe can't be any other child
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				//Write('>>> ',isExpr(pecaller,g_id_stlambda)&&pe==readPool(pecaller+EXPR_OFS_ARGS+2),' ');Writeln(dumpExpr(pecaller,fcolor_abbrv_blocks))
				replace_caller=0
				if isBuiltin(pecaller,g_id_store):
					//directly pass in the target and remove the store
					pe_target=readPool(pecaller+EXPR_OFS_ARGS+0)
					replace_caller=1
				else if isBuiltin(pecaller,g_id_stlambda)&&pe==readPool(pecaller+EXPR_OFS_ARGS+2):
					//pass in the target as ldlambda
					pe_this=readPool(pecaller+EXPR_OFS_ARGS+0)
					pe_member_name=readPool(pecaller+EXPR_OFS_ARGS+1)
					pe_target=call(g_id_ldlambda,pe_this,pe_member_name)
					replace_caller=1
				else
					//temp it
					pv_temp=makevar(pf_owner)
					writePool(pv_temp,g_vtid_RTVAR)
					writePool(pv_temp+1,t_return)
					pe_target=exprvar(pv_temp)
				//add the target, but keep pe_recurse_into: we don't want to recurse into the "target"
				n_args=getFCallNArgs(pe)
				as=new PExpression[n_args+2]
				for i=-1:n_args-1
					as[i+1]=readPool(pe+EXPR_OFS_ARGS+i)
				as[n_args+1]=pe_target
				pe_new=indcall(as)
				writePool(pe_new+EXPR_OFS_VALUE,readPool(pe+EXPR_OFS_VALUE))
				writePool(pe_new+EXPR_OFS_VALUE+1,readPool(pe+EXPR_OFS_VALUE+1))
				//Write('>>> ');Writeln(dumpExpr(pe_new,fcolor_abbrv_blocks))
				if replace_caller:
					pecaller_caller=readPool(pecaller+EXPR_OFS_CALLER)
					sccpQueueReach(insertCallAt(pecaller_caller,pecaller,function(){return pe_new}))
				else
					//'return' the temp var
					transformCode(pe,NULL, [pe_new],exprvar(pv_temp),NULL)
					//sccpQueueReach(insertCallAt(pecaller,pe,function(){return call(g_id_block,pe_new,exprvar(pv_temp))}))
		//recurse
		n_args=getFCallNArgs(pe_recurse_into)
		queue_dfsTranslateStruct.push(int3(pe_recurse_into+EXPR_OFS_FUNCTION,n_args+1,pf_owner_recurse))
		//for i=-1:n_args-1
		//	dfsTranslateStruct(readPool(pe_recurse_into+EXPR_OFS_ARGS+i),pf_owner_recurse)
	dfsTranslateStruct(g_pe_top,0)
	while queue_dfsTranslateStruct.n:
		qitem=queue_dfsTranslateStruct.pop()
		auto pe=readPool(qitem.x)
		auto pf_owner=qitem.z
		qitem.x++
		qitem.y--
		if qitem.y:
			queue_dfsTranslateStruct.push(qitem)
		dfsTranslateStruct(pe,pf_owner)
	//Writeln('>>>>>>>>>>>>>> dfsTranslateStruct')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	//System.IO.stdin.ReadLine()
	//copy-prop: only-one-ass + last-use pass ancestor-merge
	//compute live ranges first
	//Writeln('--- 5')
	struct TStructSlot
		int depth
		int birthid
	str_slots=new TStructSlot[]
	auto dfsAllocSlots(PExpression pe,int depth)
		slotid=int(str_slots.n)
		str_slots.push(TStructSlot(){'depth':depth})
		writePool(pe+EXPR_OFS_USER_FLAGS,slotid|(readPool(pe+EXPR_OFS_USER_FLAGS)&~USER_FLAG_MASK))
		flags=readPool(pe)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
			nargs=(flags&~EFLAG_MASK)
			for i=nargs-1:-1:-1
				dfsAllocSlots(readPool(pe+EXPR_OFS_ARGS+i),depth+1)
			//it's (approximately) the id of the function
			birthid=int(str_slots.n)-1
			assert(birthid>slotid)
			str_slots[slotid].birthid=birthid
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			//clear the user flag of this variable for the subsequent var slot allocation
			pobj=getVariable(pe)
			if pobj:
				writePool(pobj+VAR_OFS_USER_FLAGS,readPool(pobj+VAR_OFS_USER_FLAGS)&~VAR_USER_FLAG_MASK)
	dfsAllocSlots(g_pe_top,0)
	//Writeln('--- 50')
	struct TStructVarSlot
		PCTObject pobj_var
		PCTObject pobj_var_rename_to
		PExpression pe_non_loop_birth
		PExpression pe_non_loop_death
		PExpression pe_birth_before
		PExpression pe_death_after
		int store_count
		////////////////
		int alloced_slot
	str_var_slots=new TStructVarSlot[]
	fgetdepth=function(int slotid){return str_slots[slotid].depth}
	fgetbirthid=function(int slotid){return str_slots[slotid].birthid}
	//Writeln('>>> dfsLiveRange')
	//Writeln(dumpCode(g_pe_top,fcolor_reach_eval))
	auto dfsLiveRange(PExpression pe,PExpression pe_loop)
		auto flags=readPool(pe)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
			pe_loop_recurse=pe_loop
			if !pe_loop_recurse&&isBuiltin(pe,g_id_blockex):
				if getExprValueAs(readPool(pe+EXPR_OFS_ARGS+0),g_vtid_STR)==g_id_for:
					pe_loop_recurse=pe
			else if isBuiltin(pe,g_id_function):
				pe_loop_recurse=0
			nargs=(flags&~EFLAG_MASK)
			for i=-1:nargs-1
				dfsLiveRange(readPool(pe+EXPR_OFS_ARGS+i),pe_loop_recurse)
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			pobj_var=getVariable(pe)
			if pobj_var&&readPool(pobj_var)==g_vtid_RTVAR&&tisstruct(readPool(pobj_var+1)):
				vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
				//merge to live range
				if !(vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED)
					vflags|=VAR_USER_FLAG_RC_SLOT_ALLOCATED+int(str_var_slots.n)
					str_var_slots.push(TStructVarSlot(){'pobj_var':pobj_var,'pobj_var_rename_to':pobj_var})
					writePool(pobj_var+VAR_OFS_USER_FLAGS,vflags)
				vslotid=(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				if isBuiltin(pecaller,g_id_store)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe:
					str_var_slots[vslotid].store_count++
				pe_to_merge=pe_loop?pe_loop:pecaller
				//Writeln('merge birth ',dumpObject(str_var_slots[vslotid].pobj_var),' ',pecaller)
				str_var_slots[vslotid].pe_non_loop_birth=ancestorMerge(0,str_var_slots[vslotid].pe_non_loop_birth,pe_to_merge,fgetdepth,fgetbirthid).x
				str_var_slots[vslotid].pe_non_loop_death=ancestorMerge(1,str_var_slots[vslotid].pe_non_loop_death,pe_to_merge,fgetdepth,NULL).x
				str_var_slots[vslotid].pe_birth_before=ancestorMerge(0,str_var_slots[vslotid].pe_birth_before,pecaller,fgetdepth,fgetbirthid).x
				str_var_slots[vslotid].pe_death_after=ancestorMerge(1,str_var_slots[vslotid].pe_death_after,pecaller,fgetdepth,NULL).x
	dfsLiveRange(g_pe_top,0)
	//Writeln('--- 51')
	//actually do the copy-prop
	did=0
	foreach vslot,I in str_var_slots
		if vslot.store_count==1&&vslot.pe_birth_before:
			//the only store that writes it
			//str_var_slots[vslotid_src].pe_death_after,' ',vslot.pe_birth_before,' ',
			//Writeln('strcopyprop ',dumpObject(vslot.pobj_var),' ',dumpExpr(vslot.pe_birth_before,NULL))
			if isBuiltin(vslot.pe_birth_before,g_id_store)&&getVariable(readPool(vslot.pe_birth_before+EXPR_OFS_ARGS))==vslot.pobj_var:
				pe_value=readPool(vslot.pe_birth_before+EXPR_OFS_ARGS+1)
				if isExpr(pe_value,EFLAG_VARIABLE):
					pv_src=getVariable(pe_value)
					vflags_src=readPool(pv_src+VAR_OFS_USER_FLAGS)
					if vflags_src&VAR_USER_FLAG_RC_SLOT_ALLOCATED:
						vslotid_src=(vflags_src&VAR_USER_FLAG_RC_SLOTID_MASK)
						if str_var_slots[vslotid_src].pe_death_after==vslot.pe_birth_before:
							pe_src_birth=str_var_slots[vslotid_src].pe_birth_before
							//hack the non-propagatables
							if isBuiltin(pe_src_birth,g_id_store)&&isBuiltin(readPool(pe_src_birth+EXPR_OFS_ARGS+1),g_id_cast):
								continue
							//death -> birth, do copyprop... replace all occurances using a dset
							str_var_slots[I].pobj_var_rename_to=pv_src
							str_var_slots[vslotid_src].pe_non_loop_birth=ancestorMerge(0,str_var_slots[vslotid_src].pe_non_loop_birth,str_var_slots[I].pe_non_loop_birth,fgetdepth,fgetbirthid).x
							str_var_slots[vslotid_src].pe_non_loop_death=ancestorMerge(1,str_var_slots[vslotid_src].pe_non_loop_death,str_var_slots[I].pe_non_loop_death,fgetdepth,NULL).x
							str_var_slots[vslotid_src].pe_birth_before=ancestorMerge(0,str_var_slots[vslotid_src].pe_birth_before,str_var_slots[I].pe_birth_before,fgetdepth,fgetbirthid).x
							str_var_slots[vslotid_src].pe_death_after=ancestorMerge(1,str_var_slots[vslotid_src].pe_death_after,str_var_slots[I].pe_death_after,fgetdepth,NULL).x
							did=1
	//Writeln('--- 52')
	if did:
		auto copyPropCollapse(PCTObject pobj_var)
			auto slotid=readPool(pobj_var+VAR_OFS_USER_FLAGS)&VAR_USER_FLAG_RC_SLOTID_MASK
			pv_dad=str_var_slots[slotid].pobj_var_rename_to
			if pobj_var==pv_dad:return pobj_var
			pv_root=copyPropCollapse(pv_dad)
			str_var_slots[slotid].pobj_var_rename_to=pv_root
			return pv_root
		foreach vslot,I in str_var_slots
			copyPropCollapse(vslot.pobj_var)
		auto dfsCopyProp(PExpression pe)
			auto flags=readPool(pe)
			if (flags&EFLAG_MASK)==EFLAG_FCALL:
				//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
				nargs=(flags&~EFLAG_MASK)
				for i=-1:nargs-1
					dfsCopyProp(readPool(pe+EXPR_OFS_ARGS+i))
				//remove the newly created (and pre-existing) self-stores
				if isBuiltin(pe,g_id_store):
					pe_var=readPool(pe+EXPR_OFS_ARGS+0)
					pe_value=readPool(pe+EXPR_OFS_ARGS+1)
					if isExpr(pe_var,EFLAG_VARIABLE)&&isExpr(pe_value,EFLAG_VARIABLE)&&getVariable(pe_var)==getVariable(pe_value):
						setnop(pe)
				else if isBuiltin(pe,g_id_function):
					//need to rename return too
					pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
					pv_return=readPool(pobjfn+FUNCTION_OFS_PVAR_RETURN)
					vflags=readPool(pv_return+VAR_OFS_USER_FLAGS)
					if vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED:
						vslotid=(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
						pv_rename_to=str_var_slots[vslotid].pobj_var_rename_to
						if pv_rename_to!=pv_return:
							writePool(pobjfn+FUNCTION_OFS_PVAR_RETURN,pv_rename_to)
			else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
				pobj_var=getVariable(pe)
				if pobj_var&&readPool(pobj_var)==g_vtid_RTVAR&&tisstruct(readPool(pobj_var+1)):
					//rename to the root variable
					vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
					if vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED:
						vslotid=(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
						pv_rename_to=str_var_slots[vslotid].pobj_var_rename_to
						if pv_rename_to!=pobj_var:
							writePool(pe,EFLAG_VARIABLE+pv_rename_to)
		dfsCopyProp(g_pe_top)
	//Writeln('--- 53')
	//coulddo: a more detailed live range
	//add allocations - need a birth point: pe_non_loop_birth
	str_member_list=new PCTObject[]
	auto implementDestructor(PExpression[] as,PCTObject pv_src,PCTObject t)
		//Writeln('---- ',as.n,' ',dumpType(t))
		p_members=readPool(t+FUNCTION_OFS_PLAMBDA_VARS)
		n_members=readPool(t+FUNCTION_OFS_NLAMBDA_VARS)
		for i=0:n_members-1
			pv_member=readPool(p_members+i)
			if readPool(pv_member)!=g_vtid_RTVAR:continue
			t_member=readPool(pv_member+1)
			if tisstruct(t_member):
				str_member_list.push(pv_member)
				implementDestructor(as,pv_src,t_member)
				str_member_list.pop()
			else if tisclass(t_member):
				pe_var=exprvar(pv_src)
				foreach pv_str_member in str_member_list
					pe_var=call(g_id_ldlambda,pe_var,exprctval(pv_str_member))
				as.push(call(g_id_stlambda,pe_var,exprctval(pv_member),exprcns(getid_const(CTYPE_TYPED_NULL,i64(t_member)))))
	auto processAllocJobs(PExpression pe,int[] vslotids_recurse)
		vslotids_recurse.Sort()
		vslotids_recurse.Unique()
		struct TAllocJob
			PCTObject pobj_var
			PCTObject t
			int is_free
			int vslotid
			PExpression pe_insert_at
		alloc_jobs=new TAllocJob[]
		foreach vslotid in vslotids_recurse
			vslot=str_var_slots[vslotid]
			if vslot.pobj_var_rename_to!=vslot.pobj_var:continue
			//ldparam test - it's always the pe_non_loop_birth
			pe_birth=vslot.pe_non_loop_birth
			pe_defining_store=readPool(vslot.pobj_var+VAR_OFS_DEFINING_STORE)
			if pe_defining_store&&isBuiltin(pe_defining_store,g_id_store):
				pe_birth_value=readPool(pe_defining_store+EXPR_OFS_ARGS+1)
				if isBuiltin(pe_birth_value,g_id_ldparam):continue
				//array uses cast, don't alloc it
				if isBuiltin(pe_birth_value,g_id_cast):continue
				//part-of-another, don't alloc it
				if isBuiltin(pe_birth_value,g_id_ldlambda):continue
			//Writeln(">>alloc slot "+dumpObject(vslot.pobj_var)+" "+dumpExpr(pe_birth,fcolor_abbrv_blocks))
			pe_death=vslot.pe_non_loop_death
			t=getVariableType(vslot.pobj_var)
			alloc_jobs.push(TAllocJob(){'pobj_var':vslot.pobj_var,'vslotid':vslotid,"t":t,'is_free':0,'pe_insert_at':pe_birth})
			alloc_jobs.push(TAllocJob(){'pobj_var':vslot.pobj_var,'vslotid':vslotid,"t":t,'is_free':1,'pe_insert_at':pe_death})
		inline getExprSlotid(PExpression pe)
			return (readPool(pe+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
		inline getEffectiveSlotid(TAllocJob aj0)
			auto pe=aj0.pe_insert_at
			auto slotid=getExprSlotid(pe)
			if !aj0.is_free:
				slotid=fgetbirthid(slotid)
				return slotid*2+1
			else
				return slotid*2
		alloc_jobs.Sort(function(aj0,aj1){return getEffectiveSlotid(aj0)>getEffectiveSlotid(aj1)})
		if !alloc_jobs.n:return
		//generate the local struct/union hybrid
		struct TUnionSlot
			PCTObject[] types
		union_slots=new TUnionSlot[]
		free_slots=new int[]
		if DEBUG_DUMP_RC:
			if alloc_jobs.n:
				Writeln(FormatAsText('=== allocating structs for ',dumpFunction(getExprValueAs(pe,g_vtid_CTVAL)),' ',dumpExpr(pe,fcolor_abbrv_blocks)))
		foreach aj in alloc_jobs
			if DEBUG_DUMP_RC:
				Writeln(FormatAsText(aj.is_free?'free ':'alloc ',dumpType(aj.t),' ',dumpObject(str_var_slots[aj.vslotid].pobj_var),' to vslot-',aj.vslotid,' time=',getEffectiveSlotid(aj),' ',dumpExpr(aj.pe_insert_at,fcolor_abbrv_blocks)))
			if aj.is_free:
				free_slots.push(str_var_slots[aj.vslotid].alloced_slot)
			else
				if !free_slots.n:
					free_slots.push(int(union_slots.n))
					union_slots.push(TUnionSlot(){'types':new PCTObject[]})
				alloced_slot=int(free_slots.pop())
				str_var_slots[aj.vslotid].alloced_slot=alloced_slot
				union_slots[alloced_slot].types.push(aj.t)
		as=new PExpression[]
		as.push(exprstr(g_id_struct))
		foreach us in union_slots
			us.types.Sort()
			us.types.Unique()
			as2=new PExpression[]
			as2.push(exprstr(g_id_C_union))
			foreach t in us.types
				as2.push(exprctval(t))
			as.push(vcall(g_id_C_declare_struct_slots,as2))
		pe_declare=vcall(g_id_C_declare_struct_slots,as)
		///////////
		//actually insert the stuff
		pe_decl=pe
		pobjfn=getExprValueAs(pe_decl,g_vtid_CTVAL)
		n_args_decl=readPool(pe_decl)&~EFLAG_MASK
		pe_new_code=sccpQueueReach(insertCallAt(pe_decl,~(n_args_decl-1),function(PExpression pe_code){
			return call(g_id_block,pe_declare,pe_code);
		}))
		writePool(pobjfn+FUNCTION_OFS_CODE,pe_new_code)
		alloc_jobs.Sort(function(aj0,aj1){return aj0.pe_insert_at<aj1.pe_insert_at})
		//generate the allocations
		pe_insert_at_current=PExpression(0)
		as=new PExpression[]
		auto flushSlotGetters()
			if !pe_insert_at_current||!as.n:return
			transformCode(pe_insert_at_current,NULL,as,0,NULL)
			//pecaller=readPool(pe_insert_at_current+EXPR_OFS_CALLER)
			//sccpQueueReach(insertCallAt(pecaller,pe_insert_at_current,function(PExpression pe_original){as.push(pe_original);return vcall(g_id_block,as)}))
		foreach aj,I in alloc_jobs
			if !aj.is_free:
				if pe_insert_at_current!=aj.pe_insert_at:
					flushSlotGetters()
					pe_insert_at_current=aj.pe_insert_at
					as=new PExpression[]
				as.push(call(g_id_store,exprvar(aj.pobj_var),call(g_id_C_get_struct_slot,expriptr(str_var_slots[aj.vslotid].alloced_slot),exprctval(aj.t))))
		flushSlotGetters()
		//generate the destructions
		//pull out to the block level
		pe_insert_at_current=PExpression(0)
		//as=new PExpression[1]
		as=new PExpression[]
		auto flushStructDestructors()
			if !pe_insert_at_current||!as.n:return
			transformCode(pe_insert_at_current,NULL,NULL,0,as)
			//pecaller=readPool(pe_insert_at_current+EXPR_OFS_CALLER)
			//sccpQueueReach(insertCallAt(pecaller,pe_insert_at_current,function(PExpression pe_original){as[0]=pe_original;return vcall(g_id_block,as)}))
		foreach aj,I in alloc_jobs
			if aj.is_free:
				pe_block_level_point=promoteToRealBlockLevel(aj.pe_insert_at)
				if pe_insert_at_current!=pe_block_level_point:
					flushStructDestructors()
					pe_insert_at_current=pe_block_level_point
					//as=new PExpression[1]
					as=new PExpression[]
				pv_src=aj.pobj_var
				implementDestructor(as,pv_src,aj.t)
		flushStructDestructors()
	auto dfsRealAllocation(PExpression pe,int[] vslotids)
		vslotids_recurse=vslotids
		auto flags=readPool(pe)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
			is_function=0
			if isBuiltin(pe,g_id_function):
				is_function=1
				vslotids_recurse=new int[]
			n_args=(flags&~EFLAG_MASK)
			for i=-1:n_args-1
				dfsRealAllocation(readPool(pe+EXPR_OFS_ARGS+i),vslotids_recurse)
			if is_function&&vslotids_recurse.n:
				processAllocJobs(pe,vslotids_recurse)
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			pobj_var=getVariable(pe)
			vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
			if vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED
				vslotids.push(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
	//Writeln('--- 54')
	dfsRealAllocation(g_pe_top,NULL)
	//generate the explicit destructions... detect copy from NULL
	//Writeln('--- 6')
	ftest_null_copy=function(PExpression pe){
		if isBuiltin(pe,g_id_store):
			auto pe_tar=readPool(pe+EXPR_OFS_ARGS+0)
			auto pe_src=readPool(pe+EXPR_OFS_ARGS+1)
			if getExprValue(pe_src).tid==g_vtid_CNS:
				pv_tar=getVariable(pe_tar)
				if readPool(pv_tar)==g_vtid_RTVAR:
					t=readPool(pv_tar+1)
					if tisstruct(t):
						//struct NULL copy
						as=new PExpression[]
						implementDestructor(as,pv_tar,t)
						transformCode(pe,NULL, as,exprstr(g_empty_id),NULL)
						return 0
			//return 1
		return 1
	}
	dfsExpr(g_pe_top,ftest_null_copy)
	clearUserFlags(g_pe_top,0)
	//Writeln('>>>>>>>>>>> after dfsRealAllocation')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	//System.IO.stdin.ReadLine()
	//translate struct copies
	auto dfsImplementStructCopies(PExpression pe,PCTObject pf_owner)
		auto flags=readPool(pe)
		pf_owner_recurse=pf_owner
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//if !testUserFlag(pe,QUEUE_FLAG_REACH)&&isBuiltin(pe,g_id_block):return
			if isBuiltin(pe,g_id_function):
				pf_owner_recurse=getExprValueAs(pe,g_vtid_CTVAL)
			pv_tar=0
			pe_value=0
			pe_this=0
			if isBuiltin(pe,g_id_store):
				pv_tar=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
				pe_value=readPool(pe+EXPR_OFS_ARGS+1)
			else if isBuiltin(pe,g_id_stlambda):
				pv_tar=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
				pe_value=readPool(pe+EXPR_OFS_ARGS+2)
				pe_this=readPool(pe+EXPR_OFS_ARGS+0)
			if pv_tar&&readPool(pv_tar)==g_vtid_RTVAR&&tisstruct(readPool(pv_tar+1)):
				//struct copy indeed, transform into an inlined clone
				//we shouldn't and couldn't do a temp copy: the allocation pass should have ensured that
				//copy from NULL should have been handled earlier
				if(isBuiltin(pe_value,g_id_ldparam)||
				isBuiltin(pe_value,g_id_C_get_struct_slot)||
				!testUserFlag(pv_tar,VAR_FLAG_FLATTENED_STRUCT_MEMBER)&&(
					isBuiltin(pe_value,g_id_ldlambda)&&isBuiltin(pe,g_id_store)||
					isBuiltin(pe_value,g_id_cast)&&isBuiltin(pe,g_id_store)&&readPool(pv_tar+VAR_OFS_DEFINING_STORE)==pe)
				):return
				if Platform.BUILD=="debug":
					if getExprValue(pe_value).tid==g_vtid_CNS:
						Writeln("bad copy: "+dumpExpr(pe,fcolor_reach_eval))
				assert(getExprValue(pe_value).tid!=g_vtid_CNS)
				//ignore ldparam, ldlambda, defining __cast store, and our own allocation
				//Writeln("copy tran: "+dumpExpr(pe,fcolor_reach_eval))
				t=readPool(pv_tar+1)
				pv_src=rcGetVariableIfExprIsOne(pe_value)
				if !pv_src:
					//isBuiltin(pe,g_id_stlambda)
					//if Platform.BUILD=="debug":
					//	if !(isBuiltin(pe_value,g_id_cast)||isBuiltin(pe_value,g_id_ldlambda)&&isBuiltin(pe,g_id_stlambda)):
					//		Writeln('==== tree status')
					//		Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
					//		Writeln("copy tran error: "+dumpExpr(pe,fcolor_reach_eval))
					//assert(isBuiltin(pe_value,g_id_cast)||isBuiltin(pe_value,g_id_ldlambda)&&isBuiltin(pe,g_id_stlambda))
					pv_src=makevar(getOwningFunction(pe))
					writePool(pv_src+0,g_vtid_RTVAR)
					writePool(pv_src+1,t)
					sccpQueueReach(insertCallAt(pe,isBuiltin(pe,g_id_stlambda)?~2:~1,function(){return exprvar(pv_src)}))
					pe_store_src=call(g_id_store,exprvar(pv_src),pe_value)
					writePool(pv_src+VAR_OFS_DEFINING_STORE,pe_store_src)
					transformCode(pe,NULL, [pe_store_src],0,NULL)
				if Platform.BUILD=="debug":
					if !pv_src:
						Writeln("error: "+dumpExpr(pe_value,fcolor_abbrv_blocks))
				assert(!!pv_src)
				as_memcpy=new PExpression[]
				if isBuiltin(pe_value,g_id_block):
					//flatten the store block
					//Writeln(dumpExpr(pe_value,fcolor_reach_eval))
					n_args_value=(readPool(pe_value)&~EFLAG_MASK)
					for i=0:n_args_value-1
						as_memcpy.push(readPool(pe_value+EXPR_OFS_ARGS+i))
				use_level_this=0
				level_this=0
				pv_this=0
				if pe_this:
					//get a this var
					pv_this=rcGetVariableIfExprIsOne(pe_this)
					if !pv_this:
						if isBuiltin(pe_this,g_id_get_lambda_context):
							use_level_this=1
							level_this=getExprValueAs(readPool(pe_this+EXPR_OFS_ARGS+0),g_vtid_CNS)
						else
							pv_this=makevar(pf_owner)
							t_this=getValueType(getExprValue(pe_this))
							writePool(pv_this,g_vtid_RTVAR)
							writePool(pv_this+1,t_this)
							sccpQueueReach(insertCallAt(pe,~0,function(){return exprvar(pv_this)}))
							as_memcpy.push(call(g_id_store,exprvar(pv_this),pe_this))
							writePool(pv_this+VAR_OFS_DEFINING_STORE,as_memcpy.back())
				str_member_list=new PCTObject[]
				auto implementMemcpy(PCTObject t)
					p_members=readPool(t+FUNCTION_OFS_PLAMBDA_VARS)
					n_members=readPool(t+FUNCTION_OFS_NLAMBDA_VARS)
					for i=0:n_members-1
						pv_member=readPool(p_members+i)
						if readPool(pv_member)!=g_vtid_RTVAR:continue
						t_member=readPool(pv_member+1)
						if tisstruct(t_member):
							str_member_list.push(pv_member)
							implementMemcpy(t_member)
							str_member_list.pop()
						else
							pe_src=exprvar(pv_src)
							if use_level_this:
								pe_tar=call(g_id_ldlambda,call(g_id_get_lambda_context,expriptr(level_this)),exprctval(pv_tar))
							else if pv_this:
								pe_tar=call(g_id_ldlambda,exprvar(pv_this),exprctval(pv_tar))
							else
								pe_tar=exprvar(pv_tar)
							foreach pv_str_member in str_member_list
								pe_src=call(g_id_ldlambda,pe_src,exprctval(pv_str_member))
								pe_tar=call(g_id_ldlambda,pe_tar,exprctval(pv_str_member))
							as_memcpy.push(call(g_id_stlambda,pe_tar,exprctval(pv_member),call(g_id_ldlambda,pe_src,exprctval(pv_member))))
				implementMemcpy(t)
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				sccpQueueReach(insertCallAt(pecaller,pe,function(){return vcall(g_id_block,as_memcpy)}))
				setnop(pe)
				return
			n_args=(flags&~EFLAG_MASK)
			for i=-1:n_args-1
				dfsImplementStructCopies(readPool(pe+EXPR_OFS_ARGS+i),pf_owner_recurse)
	dfsImplementStructCopies(g_pe_top,0)
	//Writeln('>>>>>>>>>>> after dfsImplementStructCopies')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	//System.IO.stdin.ReadLine()
	//coulddo: generate cloners
	//generate finalizers... for each lambdaed function
	sccp(0)
	foreach pobjfn in g_all_functions
		if !(getFFlag(pobjfn)&FFLAG_LAMBDA_NEEDS_CONTEXT):continue
		//Write('>>> ');Writeln(dumpCode(readPool(pobjfn+FUNCTION_OFS_PEDECL),fcolor_reach_eval))
		g_sccp_queue_reach.clear()
		g_sccp_queue_eval.clear()
		g_names_resolved=0
		pe_body=call(g_id_block)
		pe_func=call(g_id_function,exprstr(g_id_function),exprctval(pobjfn),exprstr(g_id_this),pe_body)
		resolveNames(pe_func,0)
		g_names_resolved=1
		sccp(pe_func)
		pobjfn_dtor=getExprValueAs(pe_func,g_vtid_CTVAL)
		pv_this=PCTObject(0)
		flocatevar=function(PExpression pe){
			if pv_this:return 0
			if isBuiltin(pe,g_id_store)
				if isBuiltin(readPool(pe+EXPR_OFS_ARGS+1),g_id_ldparam)
					pv_this=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
					return 0
			return 1
		}
		dfsExpr(pe_func,flocatevar)
		assert(!!pv_this)
		//__done__
		as=new PExpression[]
		pobj_var_done=lookupFunctionVariable(pobjfn,g_id_finalizer)
		if pobj_var_done:
			//set a big refcnt before the dtor
			as.push(call(g_id_addref,exprvar(pv_this),expriptr(0x3fffffff)))
			as.push(indcall([call(g_id_ldlambda,exprvar(pv_this),exprctval(pobj_var_done))]))
		//recurse into structs
		str_member_list=new PCTObject[]
		auto generateDestructor(PCTObject t)
			p_members=readPool(t+FUNCTION_OFS_PLAMBDA_VARS)
			n_members=readPool(t+FUNCTION_OFS_NLAMBDA_VARS)
			for i=0:n_members-1
				pv_member=readPool(p_members+i)
				if readPool(pv_member)!=g_vtid_RTVAR:continue
				t_member=readPool(pv_member+1)
				if tisstruct(t_member):
					str_member_list.push(pv_member)
					generateDestructor(t_member)
					str_member_list.pop()
				else if tneedrc(t_member):
					pe_var=exprvar(pv_this)
					foreach pv_str_member in str_member_list
						pe_var=call(g_id_ldlambda,pe_var,exprctval(pv_str_member))
					pv_temp=makevar(pobjfn_dtor)
					writePool(pv_temp,g_vtid_RTVAR)
					writePool(pv_temp+1,t_member)
					as.push(call(g_id_store,exprvar(pv_temp),call(g_id_ldlambda,pe_var,exprctval(pv_member))))
					writePool(pv_temp+VAR_OFS_DEFINING_STORE,as.back())
					as.push(call(g_id_release,exprvar(pv_temp),expriptr(-1)))
		is_variant=(pobjfn==getStdObject(0,STDTYPE_VARIANT))
		if is_variant:
			//variant dtor, just call the rtti dtor
			as.push(call(g_id_C_free,exprvar(pv_this),exprstr(g_id_variant)))
		else
			generateDestructor(pobjfn)
		if as.n||(getFFlag(pobjfn)&FFLAG_LAMBDA_NEEDS_RTTI)||is_variant:
			//only use the dtor if it's not empty or if we need RTTI
			if !is_variant:
				//todo: pull out the free for future alloca... and allocator specialization
				as.push(call(g_id_C_free,exprvar(pv_this)))
			if g_enable_debug_instrumentation:
				as0=as
				as=new PExpression[]
				as.push(call(g_id_callstack,exprctval(pobjfn_dtor)))
				as.push(as0)
				as.push(call(g_id_callstack,expriptr(0)))
			pe_new_body=replaceBlockArgs(pe_body,as,1)
			writePool(pobjfn+FUNCTION_OFS_FINALIZER,pobjfn_dtor)
			writePool(pobjfn_dtor+FUNCTION_OFS_NAME,g_id_destructor_name)
			g_sccp_queue_reach.clear()
			g_sccp_queue_eval.clear()
			setFunctionUsed(pobjfn_dtor)
			foreach pe in as
				sccpQueueReach(pe)
			//g_dump_eval=1
			pe_decl_t=readPool(pobjfn+FUNCTION_OFS_PEDECL)
			fillepos(pe_new_body,readPool(pe_decl_t+1),readPool(pe_decl_t+2))
			sccp(pe_new_body)
			//Writeln(dumpExpr(pe_func,fcolor_reach_eval))

PCTObject[] g_all_functions
auto createCallGraphDfs(PExpression pe,PCTObject[] edges_caller)
	eflags=readPool(pe)
	if (eflags&EFLAG_MASK)!=EFLAG_FCALL:return
	pobjfn=getExprFunction(pe)
	if !pobjfn:return
	if readPool(pobjfn+FUNCTION_OFS_FLAGS)&FFLAG_NOT_USER_DEFINED:
		//exclude built-in primitives or C imports
	else
		edges_caller.push(pobjfn*2+isBuiltin(readPool(pe+EXPR_OFS_FUNCTION),g_id_dot))
	edges_caller_args=edges_caller
	pobjfn_decled=0
	if isBuiltin(pe,g_id_function):
		pobjfn_decled=getAsFunction(getExprValueAs(pe,g_vtid_CTVAL))
		if pobjfn_decled:
			edges_caller_args=new PCTObject[]
	n_args=(eflags&~EFLAG_MASK)
	for i=-1:n_args-1
		createCallGraphDfs(readPool(pe+EXPR_OFS_ARGS+i),edges_caller_args)
	if pobjfn_decled:
		g_all_functions.push(pobjfn_decled)
		edges_caller_args.Sort()
		edges_caller_args.Unique(function(int a,int b){return (a>>1)==(b>>1)})
		writePool(pobjfn_decled+FUNCTION_OFS_PCALL_GRAPH_EDGES,int(g_ctobject_pool.n))
		writePool(pobjfn_decled+FUNCTION_OFS_NCALL_GRAPH_EDGES,int(edges_caller_args.n))
		g_ctobject_pool.push(edges_caller_args)

auto createCallGraph()
	g_all_functions=new PCTObject[]
	createCallGraphDfs(g_pe_top,PCTObject[].NULL)
	g_all_functions.Sort()
	g_all_functions.Unique()
	//count the inverse edges
	foreach pobjfn in g_all_functions
		p=readPool(pobjfn+FUNCTION_OFS_PCALL_GRAPH_EDGES)
		n=readPool(pobjfn+FUNCTION_OFS_NCALL_GRAPH_EDGES)
		for i=0:n-1
			pobjfn_called=(readPool(p+i)>>1)
			assert(!!pobjfn_called)
			writePool(pobjfn_called+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES,readPool(pobjfn_called+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES)+1)
	//if Platform.BUILD=="debug":
	//	all_recorded_func=new int[int]
	//	foreach pobjfn in g_all_functions
	//		all_recorded_func[pobjfn]=1
	//	foreach pobjfn in g_all_functions
	//		p=readPool(pobjfn+FUNCTION_OFS_PCALL_GRAPH_EDGES)
	//		n=readPool(pobjfn+FUNCTION_OFS_NCALL_GRAPH_EDGES)
	//		for i=0:n-1
	//			pobjfn_called=readPool(p+i)
	//			if !all_recorded_func[pobjfn_called]:
	//				Writeln('bad: ',dumpObject(pobjfn_called))
	//			assert(!!pobjfn_called)
	//			writePool(pobjfn_called+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES,readPool(pobjfn_called+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES)+1)
	//and create them
	n0=int(g_ctobject_pool.n)
	cnt=0
	foreach pobjfn in g_all_functions
		ninv=readPool(pobjfn+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES)
		cnt+=ninv
		writePool(pobjfn+FUNCTION_OFS_PINV_CALL_GRAPH_EDGES,n0+cnt)
	g_ctobject_pool.resize(n0+cnt)
	foreach pobjfn in g_all_functions
		p=readPool(pobjfn+FUNCTION_OFS_PCALL_GRAPH_EDGES)
		n=readPool(pobjfn+FUNCTION_OFS_NCALL_GRAPH_EDGES)
		for i=0:n-1
			raw_data=readPool(p+i)
			pobjfn_called=(raw_data>>1)
			assert(pobjfn_called>0)
			//Writeln(dumpObject(pobjfn_called))
			pinv=readPool(pobjfn_called+FUNCTION_OFS_PINV_CALL_GRAPH_EDGES)-1
			writePool(pobjfn_called+FUNCTION_OFS_PINV_CALL_GRAPH_EDGES,pinv)
			writePool(pinv,pobjfn*2+(raw_data&1))
	
inline tneedrc(PCTObject t)
	return tisrealclass(t)

inline isFunctionClassOrStruct(PCTObject pobjfn)
	//return getReturnType(pobjfn)==pobjfn
	ccnv=getCcnv(pobjfn)
	return ccnv==g_id_class||ccnv==g_id_struct

auto promoteToBlockLevel(PExpression pe)
	if isBuiltin(pe,g_id_block):return pe
	for(pei=pe;;)
		pecaller=readPool(pei+EXPR_OFS_CALLER)
		if !pecaller||isBuiltin(pecaller,g_id_block):
			return pei
		pei=pecaller

inline promoteToRealBlockLevel(PExpression pe)
	return promoteToBlockLevel(pe)
//PExpression promoteToRealBlockLevel(PExpression pe)
//	if isBuiltin(pe,g_id_block)&&isStatementHost(readPool(pe+EXPR_OFS_CALLER)):return pe
//	for(pei=pe;;)
//		pecaller=readPool(pei+EXPR_OFS_CALLER)
//		if !pecaller||isBuiltin(pecaller,g_id_block)&&isStatementHost(readPool(pecaller+EXPR_OFS_CALLER)):
//			return pei
//		pei=pecaller

auto rcGetVariableIfExprIsOne(PExpression pe)
	pei=pe
	//while isBuiltin(pei,g_id_block):
	//	pei=readPool(pei+EXPR_OFS_ARGS+(readPool(pei+0)&~EFLAG_MASK)-1)
	if isExpr(pei,EFLAG_VARIABLE):
		return getVariable(pei)
	return 0

auto genRefcnt()
	flattenBlocks()
	g_sccp_queue_reach.clear()
	g_sccp_queue_eval.clear()
	auto isrcvar(PCTObject pobj_var)
		vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
		return !(vflags&(VAR_FLAG_LAMBDAED|VAR_FLAG_PARAM))&&readPool(pobj_var)==g_vtid_RTVAR&&tneedrc(getVariableType(pobj_var))
	//global function-has-rc-ness from the call graph
	//store in FFLAG_RC_HAS_SIDE_EFFECT
	//the criteria: storing anything strong
	auto rcdfsDetectSideEffect(PExpression pe)
		eflags=readPool(pe)
		if (eflags&EFLAG_MASK)!=EFLAG_FCALL:return 0
		if isBuiltin(pe,g_id_function):return 0
		pobj_var=0
		pe_value=0
		if isBuiltin(pe,g_id_store):
			pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
			pe_value=readPool(pe+EXPR_OFS_ARGS+1)
		else if isBuiltin(pe,g_id_stlambda):
			pobj_var=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
			pe_value=readPool(pe+EXPR_OFS_ARGS+2)
		if pobj_var&&!isBuiltin(pe_value,g_id_ldparam):
			//t=getVariableType(pobj_var)
			if isrcvar(pobj_var):
				return 1
		n_args=(eflags&~EFLAG_MASK)
		for i=-1:n_args-1
			if rcdfsDetectSideEffect(readPool(pe+EXPR_OFS_ARGS+i)):
				return 1
		return 0
	auto rcdfsFlagAsSideEffect(PCTObject pobjfn)
		if (getFFlag(pobjfn)&FFLAG_RC_HAS_SIDE_EFFECT):
			return
		setFFlag(pobjfn,FFLAG_RC_HAS_SIDE_EFFECT)
		pinv=readPool(pobjfn+FUNCTION_OFS_PINV_CALL_GRAPH_EDGES)
		ninv=readPool(pobjfn+FUNCTION_OFS_NINV_CALL_GRAPH_EDGES)
		for i=0:ninv-1
			rcdfsFlagAsSideEffect(readPool(pinv+i)>>1)
	foreach pobjfn in g_all_functions
		if !(getFFlag(pobjfn)&FFLAG_RC_HAS_SIDE_EFFECT)&&rcdfsDetectSideEffect(readPoolTyped(pobjfn,TFunction).code):
			rcdfsFlagAsSideEffect(pobjfn)
	//make sure everything strong is held in a variable
	queue_no_addref=new PExpression[]
	//queue_no_prerelease=new PExpression[]
	auto rcdfsGenrcParams(PExpression pe,PCTObject pf_owner)
		pf_owner_recurse=pf_owner
		pe_recurse_into=pe
		eflags=readPool(pe)
		if isBuiltin(pe,g_id_function):
			pf_owner_recurse=getExprValueAs(pe,g_vtid_CTVAL)
		if (eflags&EFLAG_MASK)==EFLAG_FCALL:
			t_return=0
			is_ldlambda=0
			if isBuiltin(pe,g_id_ldlambda):
				pobj_var=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
				if pobj_var:
					t_return=getVariableType(pobj_var)
					pecaller=readPool(pe+EXPR_OFS_CALLER)
					if (isBuiltin(pecaller,g_id_ldlambda)||
					isBuiltin(pecaller,g_id_stlambda)&&readPool(pecaller+EXPR_OFS_ARGS+0)==pe):
						//always canceled: nested dots
						t_return=0
				is_ldlambda=1
			else
				pecallee=readPool(pe+EXPR_OFS_FUNCTION+0)
				pobjfn=getExprFunction(pe)
				if pobjfn:
					if !(getFFlag(pobjfn)&FFLAG_BUILTIN):
						t_return=getReturnType(pobjfn)
				else
					tcallee=getExprType(pecallee)
					if tisfunction(tcallee):
						tcallee=getRawFunctionType(tcallee)
						ft=readPoolTyped(tcallee,TFunctionType)
						t_return=ft.t_ret
			//avoid pulling out function constants
			if tneedrc(t_return)&&getExprValue(pe).tid!=g_vtid_CTVAL:
				//param temp holding, backup the value and release later... unless it's a direct store, where we release that later for a cancel-out
				//the rc is meant to cancel out the function addref
				pecaller=readPool(pe+EXPR_OFS_CALLER)
				//Writeln('>>> '+dumpExpr(pecaller,fcolor_abbrv_blocks))
				if isBuiltin(pecaller,g_id_store)&&pe==readPool(pecaller+EXPR_OFS_ARGS+1):
					//it's the store source, we have a readily-available variable
					//just remove the store addref
					//Writeln(">>> "+dumpExpr(pecaller,fcolor_abbrv_blocks))
					if !is_ldlambda:
						queue_no_addref.push(pecaller)
				else
					//we need to temp this
					pv_temp=makevar(pf_owner)
					t_temp=t_return
					writePool(pv_temp,g_vtid_RTVAR)
					writePool(pv_temp+1,t_temp)
					pe_recurse_into=pe
					fstore_temp=function(PExpression pe){
						pe_temp_store=call(g_id_store,exprvar(pv_temp),pe);
						writePool(pv_temp+VAR_OFS_DEFINING_STORE,pe_temp_store)
						if !is_ldlambda:
							queue_no_addref.push(pe_temp_store)
						//queue_no_prerelease.push(pe_temp_store)
						return pe_temp_store
					}
					//NULL it immediately afterwards
					//pe_null_store=call(g_id_store,exprvar(pv_temp),exprcns(getid_const(CTYPE_TYPED_NULL,(i64)t_return)))
					//queue_no_addref.push(pe_null_store)
					transformCode(pe,fstore_temp, NULL,exprvar(pv_temp),NULL)
					//transformCode(pe,fstore_temp, NULL,exprvar(pv_temp),[pe_null_store])
					//pe_recurse_into=sccpQueueReach(insertCallAt(pecaller,pe,fstore_temp))
		eflags=readPool(pe_recurse_into)
		if (eflags&EFLAG_MASK)==EFLAG_FCALL:
			n_args=eflags&~EFLAG_MASK
			for i=-1:n_args-1
				rcdfsGenrcParams(readPool(pe_recurse_into+EXPR_OFS_ARGS+i),pf_owner_recurse)
	rcdfsGenrcParams(g_pe_top,0)
	//compute a slot id for each instruction, and merge the rc insertion locations
	struct TRCSlot
		int depth
		char is_rc_atomic_block
	rc_slots=new TRCSlot[]
	rc_slots.push(TRCSlot(){'depth':-1})
	auto rcdfsAllocSlots(PExpression pe,int depth)
		//FFLAG_RC_HAS_SIDE_EFFECT, deadelim needs something else -- pure imports count as deadelim side-effect, but not RC
		//also, all non-special functions count as FFLAG_RC_HAS_SIDE_EFFECT implicitly
		slotid=int(rc_slots.n)
		rc_slots.push(TRCSlot(){'depth':depth})
		writePool(pe+EXPR_OFS_USER_FLAGS,slotid|(readPool(pe+EXPR_OFS_USER_FLAGS)&~USER_FLAG_MASK))
		flags=readPool(pe)
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			n_args=(flags&~EFLAG_MASK)
			for i=n_args-1:-1:-1
				rcdfsAllocSlots(readPool(pe+EXPR_OFS_ARGS+i),depth+1)
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			//clear the user flag of this variable for the subsequent slot allocation
			pobj=getVariable(pe)
			if pobj:
				writePool(pobj+VAR_OFS_USER_FLAGS,readPool(pobj+VAR_OFS_USER_FLAGS)&~VAR_USER_FLAG_MASK)
	rcdfsAllocSlots(g_pe_top,0)
	//now we can set the flags
	foreach pe in queue_no_addref
		setUserFlag(pe,USER_FLAG_RC_STORE_WITHOUT_ADDREF)
	queue_no_addref.discard()
	//identify unbreakable blocks for live range purposes
	auto rcdfsIdentifyAtomicBlocks(PExpression pe,PExpression[int] current_labels)
		if isExpr(pe,EFLAG_FCALL):
			id_word_restore=0
			current_labels_recurse=current_labels
			if isBuiltin(pe,g_id_function):
				current_labels_recurse=new PExpression[int]
				pobjfn=getExprValueAs(pe,g_vtid_CTVAL)
				if pobjfn:
					n_args=getFCallNArgs(pe)
					pe_code=readPool(pe+EXPR_OFS_ARGS+n_args-1)
					if isBuiltin(pe_code,g_id_block)
						current_labels_recurse[getReturnLabel(pobjfn)]=pe_code
			else if isBuiltin(pe,g_id_blockex)
				p_args=0
				id_word=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+p_args),g_vtid_STR)
				if id_word==g_id_for:
					//for is always unbreakable
					slotid=(readPool(pe+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
					if DEBUG_DUMP_RC:
						if !rc_slots[slotid].is_rc_atomic_block:
							Writeln('is_rc_atomic_block: ',dumpExpr(pe,fcolor_abbrv_blocks))
					rc_slots[slotid].is_rc_atomic_block=1
					p_args++
					id_word=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+p_args),g_vtid_STR)
				if id_word==g_id_blockex:
					//it's a host
					p_args++
					id_word=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+p_args),g_vtid_STR)
					current_labels_recurse[id_word]=pe
					id_word_restore=id_word
				else
					pe_block_level=current_labels_recurse[id_word]
					if pe_block_level:
						slotid=(readPool(pe_block_level+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
						if DEBUG_DUMP_RC:
							if !rc_slots[slotid].is_rc_atomic_block:
								Writeln('is_rc_atomic_block: ',slotid,' ',dumpExpr(pe,fcolor_abbrv_blocks),' -> ',dumpExpr(pe_block_level,fcolor_abbrv_blocks))
						rc_slots[slotid].is_rc_atomic_block=1
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				rcdfsIdentifyAtomicBlocks(readPool(pe+EXPR_OFS_ARGS+i),current_labels_recurse)
			if id_word_restore:
				current_labels_recurse[id_word_restore]=0
	rcdfsIdentifyAtomicBlocks(g_pe_top,NULL)
	//allocate per-variable slots and do the merging
	/*
	always-NULL analysis:
		dfs, maintain
			known-NULL list
			known-non-NULL list
		merge branches at the end of if
		just ignore NULL asses and mark the first asses only
	safe-ass merge for a "no-longer-safe-beyond" location
		the same common ancestor merge
		whether the newly added guy is safe depends on the merge process
		ditch the externally-used in the very beginning
		don't even dfs into loops
	*/
	struct TRCVarSlot
		PCTObject pobj_var
		PExpression pe_death_merged
		PExpression pe_store_unsafe_beyond
	rc_var_slots=new TRCVarSlot[]
	fgetdepth=function(int slotid){return rc_slots[slotid].depth}
	auto rcdfsComputeSafeStoreAndVarDeath(PExpression pe,int is_safe_store_possible, PExpression pe_loop)
		auto flags=readPool(pe)
		auto is_safe_store_possible_recurse=is_safe_store_possible
		if (flags&EFLAG_MASK)==EFLAG_FCALL:
			//safe store isn't possible inside loops
			pe_loop_recurse=pe_loop
			slotid=(readPool(pe+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
			if isBuiltin(pe,g_id_function):
				is_safe_store_possible_recurse=1
				pe_loop_recurse=0
			else if rc_slots[slotid].is_rc_atomic_block:
				is_safe_store_possible_recurse=0
				if !pe_loop_recurse:
					pe_loop_recurse=pe
			//else if isBuiltin(pe,g_id_rc_local_holder):
			n_args=(flags&~EFLAG_MASK)
			for i=-1:n_args-1
				rcdfsComputeSafeStoreAndVarDeath(readPool(pe+EXPR_OFS_ARGS+i),is_safe_store_possible_recurse,pe_loop_recurse)
			if isBuiltin(pe,g_id_store):
				pe_store_var=readPool(pe+EXPR_OFS_ARGS+0)
				pobj_var=getVariable(pe_store_var)
				vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
				if isrcvar(pobj_var):
					//we need to merge it even if the current one can't possibly be safe
					if !(vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED)
						vflags|=VAR_USER_FLAG_RC_SLOT_ALLOCATED+int(rc_var_slots.n)
						rc_var_slots.push(TRCVarSlot(){'pobj_var':pobj_var})
						writePool(pobj_var+VAR_OFS_USER_FLAGS,vflags)
					vslotid=(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
					amret=ancestorMerge(1,rc_var_slots[vslotid].pe_store_unsafe_beyond,pe,fgetdepth,NULL)
					(pe_merged,is_safe)=(amret.x,amret.y)
					rc_var_slots[vslotid].pe_store_unsafe_beyond=pe_merged
					if is_safe&&is_safe_store_possible:
						//mark pe as safe
						setUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE)
		else if (flags&EFLAG_MASK)==EFLAG_VARIABLE:
			pobj_var=getVariable(pe)
			if pobj_var:
				pecaller=0
				while pobj_var:
					//merge to death - and do it for all the flattening owners
					if isrcvar(pobj_var):
						if !pecaller:
							//don't mess with dot, do it lazily
							pecaller=readPool(pe+EXPR_OFS_CALLER)
							while isBuiltin(pecaller,g_id_dot):
								pecaller=readPool(pecaller+EXPR_OFS_CALLER)
						vflags=readPool(pobj_var+VAR_OFS_USER_FLAGS)
						if !(vflags&VAR_USER_FLAG_RC_SLOT_ALLOCATED)
							vflags|=VAR_USER_FLAG_RC_SLOT_ALLOCATED+int(rc_var_slots.n)
							rc_var_slots.push(TRCVarSlot(){'pobj_var':pobj_var})
							writePool(pobj_var+VAR_OFS_USER_FLAGS,vflags)
						vslotid=(vflags&VAR_USER_FLAG_RC_SLOTID_MASK)
						pe_merged=ancestorMerge(1,rc_var_slots[vslotid].pe_death_merged,pe_loop?pe_loop:pecaller,fgetdepth,NULL).x
						rc_var_slots[vslotid].pe_death_merged=pe_merged
					pobj_var=readPool(pobj_var+VAR_OFS_FLATTENING_OWNER)
					//if pobj_var:
					//	Writeln('owner: ',dumpObject(pobj_var))
	rcdfsComputeSafeStoreAndVarDeath(g_pe_top,1,0)
	//Writeln(">>> point #1\n"+dumpCode(g_pe_top,fcolor_reach_eval))
	///////////////////////////////////////////////////
	//generate rc
	struct TRefcntLine
		PExpression pe
		PCTObject v
		int delta
		i8 is_cancel_only
		i8 need_null_out
		if Platform.BUILD=="debug":
			int debug_id_source
	all_rcs=new TRefcntLine[]
	null_outs=new TRefcntLine[]
	//Writeln('-------')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	//non-safe store, stlambda: save the previous value, then addref/release after the store location
	queue_rcdfsGenrcStore=new int3[]
	auto rcdfsGenrcStore(PExpression pe,PCTObject pf_owner)
		//Write('.')
		pe_recurse_into=pe
		pf_owner_recurse=pf_owner
		if isBuiltin(pe,g_id_function):
			pf_owner_recurse=getExprValueAs(pe,g_vtid_CTVAL)
		else if isBuiltin(pe,g_id_explicit_rc):
			n_args=getFCallNArgs(pe)
			assert(n_args==2)
			delta=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CNS)
			if delta:
				peobj=readPool(pe+EXPR_OFS_ARGS+0)
				if getExprValue(peobj).tid==g_vtid_RTVAR:
					if isExpr(peobj,EFLAG_VARIABLE):
						pobj_var=getVariable(peobj)
						pe_rcpoint=pe
						setnop(pe)
					else
						pv_temp=makevar(pf_owner)
						writePool(pv_temp,g_vtid_RTVAR)
						writePool(pv_temp+1,getExprType(peobj))
						pobj_var=pv_temp
						pecaller=readPool(pe+EXPR_OFS_CALLER)
						old_user_flags=readPool(pe+EXPR_OFS_USER_FLAGS)
						pe_rcpoint=sccpQueueReach(insertCallAt(pecaller,pe,function(){return call(g_id_store,exprvar(pv_temp),peobj)}))
						writePool(pv_temp+VAR_OFS_DEFINING_STORE,pe_rcpoint)
						writePool(pe_rcpoint+EXPR_OFS_USER_FLAGS,old_user_flags)
					all_rcs.push(TRefcntLine(){'pe':pe_rcpoint,"v":pobj_var,'delta':delta})
					if Platform.BUILD=="debug":
						all_rcs.back().debug_id_source=getid('explicit_rc')
				else
					setnop(pe)
			else
				errorAtExpr(ETYPE_ERROR,readPool(pe+EXPR_OFS_ARGS+1),"explicit rc must have a non-zero, constant delta")
		else if (isBuiltin(pe,g_id_store)||isBuiltin(pe,g_id_stlambda))&&!(testUserFlag(pe,USER_FLAG_RC_STORE_WITHOUT_ADDREF)&&testUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE)):
			if isBuiltin(pe,g_id_store):
				pe_var=readPool(pe+EXPR_OFS_ARGS+0)
				val_expr0=getExprValue(pe_var)
				if val_expr0.tid==g_vtid_RTVAR:
					pobj_var=getVariable(pe_var)
				else
					pobj_var=0
				pe_value=readPool(pe+EXPR_OFS_ARGS+1)
			else
				pobj_var=getExprValueAs(readPool(pe+EXPR_OFS_ARGS+1),g_vtid_CTVAL)
				pe_value=readPool(pe+EXPR_OFS_ARGS+2)
			if pobj_var&&readPool(pobj_var)==g_vtid_RTVAR:
				t=getVariableType(pobj_var)
				if tneedrc(t)&&!isBuiltin(pe_value,g_id_ldparam):
					if !testUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE):
						pv_temp=makevar(pf_owner)
						writePool(pv_temp,g_vtid_RTVAR)
						writePool(pv_temp+1,t)
					//pe_recurse_into=pe_value
					if isBuiltin(pe,g_id_store):
						as_backup=new PExpression[]
						if !testUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE):
							as_backup.push(call(g_id_store,exprvar(pv_temp),exprvar(pobj_var)))
						pv_value=rcGetVariableIfExprIsOne(pe_value)
						if !pv_value:
							pv_value=pobj_var
					else
						as_backup=new PExpression[]
						if !testUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE):
							pe_this=readPool(pe+EXPR_OFS_ARGS+0)
							pv_this=rcGetVariableIfExprIsOne(pe_this)
							if pv_this:
								as_backup.push(call(g_id_store,exprvar(pv_temp),call(g_id_ldlambda,exprvar(pv_this),exprctval(pobj_var))))
							else if isBuiltin(pe_this,g_id_get_lambda_context):
								d_levels=getExprValueAs(readPool(pe_this+EXPR_OFS_ARGS+0),g_vtid_CNS)
								as_backup.push(call(g_id_store,exprvar(pv_temp),
									call(g_id_ldlambda,call(g_id_get_lambda_context,expriptr(d_levels)),
									exprctval(pobj_var))))
							else
								pv_this=makevar(pf_owner)
								t_this=getValueType(getExprValue(pe_this))
								writePool(pv_this,g_vtid_RTVAR)
								writePool(pv_this+1,t_this)
								sccpQueueReach(insertCallAt(pe,~0,function(){return exprvar(pv_this)}))
								as_backup.push(call(g_id_store,exprvar(pv_this),pe_this))
								writePool(pv_this+VAR_OFS_DEFINING_STORE,as_backup.back())
								as_backup.push(call(g_id_store,exprvar(pv_temp),call(g_id_ldlambda,exprvar(pv_this),exprctval(pobj_var))))
						////////
						pe_value=readPool(pe+EXPR_OFS_ARGS+2)
						pv_value=rcGetVariableIfExprIsOne(pe_value)
						if !pv_value&&!isExpr(pe_value,EFLAG_CONST):
							pv_value=makevar(pf_owner)
							t_value=getValueType(getExprValue(pe_value))
							writePool(pv_value,g_vtid_RTVAR)
							writePool(pv_value+1,t_value)
							sccpQueueReach(insertCallAt(pe,~2,function(){return exprvar(pv_value)}))
							as_backup.push(call(g_id_store,exprvar(pv_value),pe_value))
							writePool(pv_value+VAR_OFS_DEFINING_STORE,as_backup.back())
						////////
					//Writeln(">>> "+dumpExpr(pe_recurse_into,fcolor_reach_eval))
					//pe_block=sccpQueueReach(insertCallAt(pecaller,pe,function(PExpression pe){as_backup.push(pe);return vcall(g_id_block,as_backup)}))
					//uninit for this -> getlambdacontext
					tid_value=getExprValue(pe_value).tid
					if (tid_value==g_vtid_RTVAR||tid_value==g_vtid_UNINIT)&&!testUserFlag(pe,USER_FLAG_RC_STORE_WITHOUT_ADDREF):
						all_rcs.push(TRefcntLine(){'pe':pe,"v":pv_value,'delta':1})
						if Platform.BUILD=="debug":
							all_rcs.back().debug_id_source=getid('post_store_addref')
					if !testUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE):
						all_rcs.push(TRefcntLine(){'pe':pe,"v":pv_temp,'delta':-1})
						if Platform.BUILD=="debug":
							all_rcs.back().debug_id_source=getid('pre_store_release')
					foreach pe_added in as_backup
						setUserFlag(pe_added,USER_FLAG_RC_IS_SAFE_STORE|USER_FLAG_RC_STORE_WITHOUT_ADDREF)
					setUserFlag(pe,USER_FLAG_RC_IS_SAFE_STORE|USER_FLAG_RC_STORE_WITHOUT_ADDREF)
					pe_recurse_into=transformCode(pe,NULL, as_backup,0,NULL)
		eflags=readPool(pe_recurse_into)
		if (eflags&EFLAG_MASK)==EFLAG_FCALL:
			n_args=eflags&~EFLAG_MASK
			queue_rcdfsGenrcStore.push(int3(pe_recurse_into+EXPR_OFS_FUNCTION,n_args+1,pf_owner_recurse))
			//for i=-1:n_args-1
			//	rcdfsGenrcStore(readPool(pe_recurse_into+EXPR_OFS_ARGS+i),pf_owner_recurse)
	rcdfsGenrcStore(g_pe_top,0)
	while queue_rcdfsGenrcStore.n:
		qitem=queue_rcdfsGenrcStore.pop()
		auto pe=readPool(qitem.x)
		auto pf_owner=qitem.z
		qitem.x++
		qitem.y--
		if qitem.y:
			queue_rcdfsGenrcStore.push(qitem)
		rcdfsGenrcStore(pe,pf_owner)
	//Writeln(">>> point #2\n"+dumpCode(g_pe_top,fcolor_reach_eval))
	/*
	each non-lambda variable:
		at death
		if it was in a loop, pull out of the loop
			could do it as a part of the mapping process... but others can't be mapped this way
	*/
	foreach vslot in rc_var_slots
		if readPool(vslot.pobj_var+VAR_OFS_ID)==g_id_return:
			//the return value doesn't die
			continue
		assert(vslot.pe_death_merged>=0)
		all_rcs.push(TRefcntLine(){'pe':vslot.pe_death_merged,"v":vslot.pobj_var,'delta':-1})
		if Platform.BUILD=="debug":
			all_rcs.back().debug_id_source=getid('last_use_release')
		//NULL out the supposedly "dead" variable, released or not
		null_outs.push(TRefcntLine(){'pe':vslot.pe_death_merged,"v":vslot.pobj_var,'delta':0x80000000,'need_null_out':1})
		if Platform.BUILD=="debug":
			null_outs.back().debug_id_source=getid('last_use_null_out')
	//function begin/end
	foreach pobjfn in g_all_functions
		if getFFlag(pobjfn)&FFLAG_LAMBDA_NEEDS_CONTEXT:
			fn=readPoolTyped(pobjfn,TFunction)
			if isFunctionClassOrStruct(pobjfn):
				//don't need to do that for classes
				//pobj_var=lookupFunctionVariable(pobjfn,g_id_this)
				continue
			pe_fbody=fn.code
			pe_fhead=pe_fbody
			while isBuiltin(pe_fhead,g_id_block):
				pe_fhead=readPool(pe_fhead+EXPR_OFS_ARGS+0)
			all_rcs.push(TRefcntLine(){'pe':pe_fhead,"v":0,'delta':1})
			if Platform.BUILD=="debug":
				all_rcs.back().debug_id_source=getid('function_begin')
			all_rcs.push(TRefcntLine(){'pe':pe_fbody,"v":0,'delta':-1})
			if Platform.BUILD=="debug":
				all_rcs.back().debug_id_source=getid('function_end')
			rcdfsFlagAsSideEffect(pobjfn)
	if DEBUG_DUMP_RC:
		Writeln('==== DEBUG_DUMP_RC')
		Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	//forward merge pass
	all_rcs.push(null_outs)
	all_rcs.Sort(function(rcia,rcib){return rcia.pe<rcib.pe;})
	p_rc_first=new int[int]
	for i=0:all_rcs.n-1
		if !i||all_rcs[i].pe!=all_rcs[i-1].pe:
			p_rc_first[all_rcs[i].pe]=int(i+1)
	if DEBUG_DUMP_RC:
		foreach rcitem in all_rcs
			Write('original> ')
			if Platform.BUILD=="debug":
				slotid=(readPool(rcitem.pe+EXPR_OFS_USER_FLAGS)&USER_FLAG_RC_SLOTID_MASK)
				Write(getIdString(rcitem.debug_id_source),' #',slotid,' ',)
			if rcitem.v:
				Write(rcitem.delta,' ',dumpObject(rcitem.v),' ');Writeln(dumpExpr(rcitem.pe,function(PExpression pe){if pe==rcitem.pe:return fcolor_reach_eval(pe);return fcolor_abbrv_blocks(pe)}))
			else
				Write(rcitem.delta,' lambda ');Writeln(dumpExpr(rcitem.pe,fcolor_abbrv_blocks))
	var_in_rc=new int[PCTObject]
	auto flushRC(TRefcntLine[] current_rcs0,PExpression pe, int is_after,PCTObject pobj_var)
		if pobj_var:
			current_rcs=new TRefcntLine[]
			n2=0L
			foreach rcitem in current_rcs0
				if rcitem.v==pobj_var:
					current_rcs.push(rcitem)
				else
					current_rcs0[n2]=rcitem
					n2++
			current_rcs0.resize(n2)
			var_in_rc[pobj_var]=0
		else
			current_rcs=current_rcs0
			var_in_rc.clear()
		current_rcs.Sort(function(rcia,rcib){return rcia.v<rcib.v})
		current_rcs_merged=new TRefcntLine[]
		rc_current=TRefcntLine(){'is_cancel_only':1}
		foreach rcitem in current_rcs
			if DEBUG_DUMP_RC:
				Write('    ')
				if Platform.BUILD=="debug":
					Write(getIdString(rcitem.debug_id_source),' ')
				if rcitem.v:
					Write(rcitem.delta,' ',dumpObject(rcitem.v),' ');Writeln(dumpExpr(rcitem.pe,function(PExpression pe){if pe==rcitem.pe:return fcolor_reach_eval(pe);return fcolor_abbrv_blocks(pe)}))
				else
					Write(rcitem.delta,' lambda ');Writeln(dumpExpr(rcitem.pe,fcolor_abbrv_blocks))
			if rcitem.need_null_out:
				current_rcs_merged.push(rcitem)
				continue
			if rc_current.v!=rcitem.v:
				if rc_current.delta||!rc_current.is_cancel_only:
					current_rcs_merged.push(rc_current)
				rc_current=TRefcntLine(){'pe':pe,"v":rcitem.v,'is_cancel_only':1}
			rc_current.delta+=rcitem.delta
			if rcitem.delta<0&&!rcitem.is_cancel_only:
				rc_current.is_cancel_only=0
		if rc_current.delta||!rc_current.is_cancel_only:
			current_rcs_merged.push(rc_current)
		current_rcs_merged.Sort(function(rcia,rcib){return rcia.delta>rcib.delta||rcia.delta==rcib.delta&&rcia.v<rcib.v})
		as_rc_current=new PExpression[]
		foreach rcitem in current_rcs_merged
			pe_var=(rcitem.v?exprvar(rcitem.v):expriptr(0))
			if rcitem.need_null_out:
				assert(rcitem.v)
				t=getVariableType(rcitem.v)
				pe_dorc=call(g_id_store,pe_var,exprcns(getid_const(CTYPE_TYPED_NULL,i64(t))))
			else if rcitem.delta>0||rcitem.is_cancel_only:
				pe_dorc=call(g_id_addref,pe_var,expriptr(rcitem.delta))
			else
				pe_dorc=call(g_id_release,pe_var,expriptr(rcitem.delta))
			as_rc_current.push(pe_dorc)
		if is_after:
			transformCode(pe,NULL, NULL,0,as_rc_current)
		else
			transformCode(pe,NULL, as_rc_current,0,NULL)
		current_rcs.clear()
	auto rcdfsMergeAndGenerateRC(TRefcntLine[] current_rcs,PExpression pe)
		flush_self=0
		if isExpr(pe,EFLAG_FCALL):
			is_blocked=0
			rcs_recurse=current_rcs
			if isStatementHost(pe):
				is_blocked=1
			flush_children=0
			n_args=getFCallNArgs(pe)
			for i=-1:n_args-1
				pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
				if is_blocked:
					rcs_recurse=new TRefcntLine[]
				flush_children|=rcdfsMergeAndGenerateRC(rcs_recurse,pe_argi)
				if is_blocked&&rcs_recurse.n:
					if DEBUG_DUMP_RC:
						Writeln('flushing block tail rc: ',dumpExpr(pe_argi,fcolor_abbrv_blocks),' from ',dumpExpr(pe,fcolor_abbrv_blocks))
					flushRC(rcs_recurse,pe_argi,1, 0)
			if is_blocked&&!isBuiltin(pe,g_id_function):
				//break and friends... should caused a flush above, across simple {} blocks
				//but they should not cause the {} themselves to flush
				//therefore, or flush_children in both places
				flush_self|=flush_children
			if !flush_self:
				pobjfn=getExprFunction(pe)
				if pobjfn:
					flag=getFFlag(pobjfn)
				else
					//true indirect calls may have a side effect
					flag=FFLAG_RC_HAS_SIDE_EFFECT
				if (flag&FFLAG_RC_HAS_SIDE_EFFECT):
					flush_self=1
			if flush_self:
				if DEBUG_DUMP_RC:
					if current_rcs.n:
						Writeln('flushing rc: ',dumpExpr(pe,fcolor_abbrv_blocks))
					else
						Writeln('empty flushing: ',dumpExpr(pe,fcolor_abbrv_blocks))
				flushRC(current_rcs,pe,0, 0)
			else if isBuiltin(pe,g_id_store):
				pobj_var=getVariable(readPool(pe+EXPR_OFS_ARGS+0))
				if pobj_var&&var_in_rc[pobj_var]:
					if DEBUG_DUMP_RC:
						if current_rcs.n:
							Writeln('flushing per-var rc: ',pobj_var,' ',dumpExpr(pe,fcolor_abbrv_blocks))
					flushRC(current_rcs,pe,0, pobj_var)
		p_rc=p_rc_first[pe]-1
		if p_rc>=0:
			while p_rc<all_rcs.n&&all_rcs[p_rc].pe==pe:
				rcitem=all_rcs[p_rc]
				var_in_rc[rcitem.v]=1
				current_rcs.push(rcitem)
				p_rc++
		return flush_self|flush_children
	rcdfsMergeAndGenerateRC(NULL,g_pe_top)
	//Writeln('>>> after flushRC')
	//Writeln(dumpExpr(g_pe_top,fcolor_reach_eval))
	clearUserFlags(g_pe_top,0)
	//sccpProcessReaches()
	sccp(0)

auto instrumentForDebugging()
	////only the branches are explicitly marked
	//auto finstrument(PExpression pe,PExpression pe_block_next)
	//	if isExpr(pe,EFLAG_FCALL):
	//		n_args=getFCallNArgs(pe)
	//		is_block=isBuiltin(pe,g_id_block)
	//		is_flow_control=(isBuiltin(pe,g_id_if)||isBuiltin(pe,g_id_blockex))
	//		if is_flow_control:
	//			transformCode(pe,NULL,
	//				[fillepos(call(g_id_set_callstack),readPool(pe+1),readPool(pe+2))],
	//				0,
	//				[fillepos(call(g_id_set_callstack),readPool(pe_block_next+1),readPool(pe_block_next+2))])
	//		//maintain the next-of-branches
	//		for i=-1:n_args-1
	//			pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
	//			if is_flow_control:
	//				if isBuiltin(pe_argi,g_id_block):
	//					transformCode(pe_argi,NULL,[fillepos(call(g_id_set_callstack),readPool(pe_argi+1),readPool(pe_argi+2))],0,NULL)
	//			if is_block&&i+1<n_args:
	//				pe_argi_next=readPool(pe+EXPR_OFS_ARGS+i+1)
	//			else
	//				pe_argi_next=pe_block_next
	//			finstrument(pe_argi,pe_argi_next)
	//finstrument(g_pe_top,0)
	//tempify crashable call args
	auto ftempify_args(PExpression pe,PCTObject pf_owner){
		if isExpr(pe,EFLAG_FCALL):
			pobjfn=getExprFunction(pe)
			if !pobjfn:return 1
			cbobj_oncgen=readPool(pobjfn+FUNCTION_OFS_ONCGEN)
			if cbobj_oncgen==g_cbobj_cimport_cgen||cbobj_oncgen==g_cbobj_generated_function_oncgen:
				//tempify all args
				as=PExpression[].NULL
				n_args=getFCallNArgs(pe)
				for i=-1:n_args-1
					pe_argi=readPool(pe+EXPR_OFS_ARGS+i)
					if !isExpr(pe_argi,EFLAG_FCALL):continue
					val=getExprValue(pe_argi)
					if val.tid!=g_vtid_RTVAR:continue
					pv_temp=makevar(pf_owner)
					writePool(pv_temp+0,val.tid)
					writePool(pv_temp+1,val.val)
					sccpQueueReach(insertCallAt(pe,~i,function(){return exprvar(pv_temp)}))
					if !as:as=new PExpression[]
					as.push(call(g_id_store,exprvar(pv_temp),pe_argi))
					writePool(pv_temp+VAR_OFS_DEFINING_STORE,as.back())
				if as:
					pe_new=transformCode(pe,NULL, as,0,NULL)
					dfsExprEx(pe_new,pf_owner,ftempify_args)
					return 0
				else
					return 1
		return 1
	}
	dfsExprEx(g_pe_top,0,ftempify_args)

//////////////////////////////////////////////////
struct TCScope
	string outer_code_buffer
	PCTObject[] var_stores
	PExpression[] dbg_slots
g_c_headers=new int[]
g_c_ftypes=new PCTObject[]
g_struct_code_per_type=new string[PCTObject]
g_all_struct_types=new PCTObject[]
g_structs_slots_buffer=new string
g_forward_buffer=new string
g_c_global_buffer=new string
g_local_decl_buffer=new string
g_debug_file_info_buffer=new string
g_debug_line_info_buffer=new string
g_local_return_buffer=new string
g_code_buffer=new string
g_gencode_queue=new PExpression[]
g_c_scope_stack=new TCScope[]
g_current_labels=new int[int]
g_readable_c_code=0
g_enable_debug_instrumentation=0
g_current_line_info_id=0
auto genConst(int cid)
	cns=Util.ctNumber(cid)
	if cns.type==const_type(CTYPE_FLOAT,32):
		g_code_buffer.push(formatNumber(__int_as_float(int(cns.val_bin)),{frac:9,scientific:1}))
		g_code_buffer.push('f')
	else if cns.type==const_type(CTYPE_FLOAT,64):
		g_code_buffer.push(formatNumber(__longlong_as_double(cns.val_bin),{frac:23,scientific:1}))
	else if cns.type==CTYPE_TYPED_NULL:
		g_code_buffer.push('((')
		genType(PCTObject(cns.val_bin))
		g_code_buffer.push(')NULL)')
	else
		if cns.type==CTYPE_POINTER:
			g_code_buffer.push('(void*)')
			n_bits=Util.bitSize()
		else
			n_bits=((cns.type&~CTYPE_MASK)+1)*8
		if n_bits<32:
			g_code_buffer.push('(')
			if ((cns.type&CTYPE_MASK)==CTYPE_UINT):
				g_code_buffer.push('unsigned ')
			if n_bits==8:
				g_code_buffer.push('char ')
			else
				assert(n_bits==16)
				g_code_buffer.push('short ')
			g_code_buffer.push(')')
		if ((cns.type&CTYPE_MASK)==CTYPE_INT)||cns.type==CTYPE_POINTER:
			if n_bits==64:
				mask=-1LL
			else
				mask=(i64(1)<<n_bits)-1
			sval=string((cns.val_bin&mask)|-(cns.val_bin&(mask+1LL)))
			g_code_buffer.push(sval)
		else if ((cns.type&CTYPE_MASK)==CTYPE_UINT):
			if n_bits==64:
				mask=-1LL
			else
				mask=(i64(1)<<n_bits)-1
			sval=string(u64(cns.val_bin&mask))
			g_code_buffer.push(sval)
		if ((cns.type&CTYPE_MASK)==CTYPE_UINT):
			g_code_buffer.push('u')
		if n_bits>32:
			g_code_buffer.push('LL')
auto genCode(PExpression pe,int expr_oplevel)
	flags=readPool(pe)
	switch flags&EFLAG_MASK{
	case EFLAG_FCALL:
		//n_args=flags&~EFLAG_MASK
		pobjfn=getExprFunction(pe)
		cb_oncgen=0
		if pobjfn:
			cb_oncgen=readPool(pobjfn+FUNCTION_OFS_ONCGEN)
			if !cb_oncgen:
				//assert(0)
				if Platform.BUILD=="debug":
					//Writeln(dumpExpr(pe,fcolor_abbrv_blocks))
					Writeln(dumpExpr(pe,NULL))
				errorAtExpr(ETYPE_LOW_LEVEL_ERROR,pe,"unable to generate C code for '@1'".Replace(["@1",citeexpr(pe)]))
				return
			invokeCallbackObject(cb_oncgen,pe,expr_oplevel)
		else
			pecallee=readPool(pe+EXPR_OFS_FUNCTION)
			n_args=getFCallNArgs(pe)
			pftype=getExprType(pecallee)
			if !tisfunction(pftype):
				//todo: improve error message - operator[] case, method case, ...
				//Writeln(dumpType(pftype))
				//Writeln(">>> "+dumpExpr(pe,fcolor_abbrv_blocks))
				errorAtExpr(ETYPE_ERROR,pecallee,"'@1' is not a function and can't be called here, it's currently of type '@2'".Replace(["@1",citeexpr(pecallee),"@2",dumpType(pftype)]))
				return
			t_raw_function_type=getRawFunctionType(pftype)
			//ft=readPoolTyped(t_raw_function_type,TFunctionType)
			g_c_ftypes.push(t_raw_function_type)
			g_code_buffer.push('((s7_TF')
			g_code_buffer.push(toBase32(t_raw_function_type))
			g_code_buffer.push(')')
			genCode(pecallee,LEVEL_POSTFIX)
			g_code_buffer.push('->m_')
			g_code_buffer.push(toBase32(lookupFunctionVariable(pftype,g_id_ptr_fn)))
			g_code_buffer.push(')(')
			//if ft.flags&FFLAG_LAMBDA_NEEDS_PARENT_POINTER_ARG:
			//	g_code_buffer.push('s7_BL,')
			genCode(pecallee,LEVEL_POSTFIX)
			g_code_buffer.push('->m_')
			g_code_buffer.push(toBase32(lookupFunctionVariable(pftype,g_id_ptr_this)))
			for i=0:n_args-1
				g_code_buffer.push(',')
				genCode(readPool(pe+EXPR_OFS_ARGS+i),LEVEL_ASSIGNMENT)
			if g_code_buffer.back()==',':
				g_code_buffer.pop()
			g_code_buffer.push(')')
		break
	case EFLAG_CONST:
		//coulddo: accurate formatting
		genConst(flags&~EFLAG_MASK)
		break
	case EFLAG_CTVAL:
		pobjfn=(readPool(pe)&~EFLAG_MASK)
		if readPool(pobjfn)!=g_tid_TFunction:
			errorAtExpr(ETYPE_ERROR,pe,"unable to generate C code for compile-time only expression '"+citeexpr(pe)+"'")
			g_code_buffer.push('?err?')
		else
			g_code_buffer.push('((void*)')
			genFunctionName(pobjfn)
			g_code_buffer.push(')')
			queueCodeGen(pobjfn)
		break
	case EFLAG_STRING:
		g_code_buffer.push('"')
		g_code_buffer.push(genString(getIdString(flags&~EFLAG_MASK)))
		g_code_buffer.push('"')
		break
	case EFLAG_VARIABLE:
		pobj_var=getVariable(pe)
		if !pobj_var:
			errorAtExpr(ETYPE_LOW_LEVEL_ERROR,pe,"unable to generate C code for undeclared variable '@1'".Replace("@1",citeexpr(pe)))
			g_code_buffer.push('?err?')
		else
			if expr_oplevel==LEVEL_STORE_HACK:
				dat_var=readPoolTyped(pobj_var,TSCCPValue)
				t=getValueType(dat_var)
				if !t:
					errorAtExpr(ETYPE_LOW_LEVEL_ERROR,pe,"failed to deduce the type of variable '@1' (variable '@2')".Replace(["@1",citeexpr(pe),"@2",dumpExpr(pe,NULL)]))
				else
					if Platform.BUILD=="debug":
						if readPool(t)==g_tid_TFunction:
							id_ccnv=getCcnv(t)
							if id_ccnv==g_id_inline||id_ccnv==g_id_inline_loopbody:
								Writeln(dumpExpr(pe,NULL))
								assert(0)
					if !(readPool(pobj_var+VAR_OFS_USER_FLAGS)&VAR_FLAG_LAMBDAED):
						g_c_scope_stack.back().var_stores.push(pobj_var)
			if readPool(pobj_var+VAR_OFS_USER_FLAGS)&VAR_FLAG_LAMBDAED:
				//is-lambda test when generating variables
				assert(0)
				g_code_buffer.push('s7_BL->m_')
				g_code_buffer.push(toBase32(pobj_var))
			else
				genVar(pobj_var)
		break
	}

auto genFilteredName(int id)
	s=getIdString(id)
	foreach ch,I in s
		if !g_c_id_allowed[(int)(u8)(ch)]:
			g_code_buffer.push('_')
		else
			g_code_buffer.push(ch)
		if I>32:break

auto genFunctionName(PCTObject pobjfn)
	fn=readPoolTyped(pobjfn,TFunction)
	if fn.flags&FFLAG_EXPORTED:
		genFilteredName(fn.id_name)
	else
		g_code_buffer.push("s7_f")
		g_code_buffer.push(toBase32(pobjfn))
		if fn.id_name&&g_readable_c_code:
			g_code_buffer.push('_')
			genFilteredName(fn.id_name)

auto genVar(PCTObject pobj_var)
	g_code_buffer.push('s7_v')
	g_code_buffer.push(toBase32(pobj_var))
	if g_readable_c_code:
		id_name=readPool(pobj_var+VAR_OFS_ID)
		if id_name:
			g_code_buffer.push('_')
			genFilteredName(id_name)

auto cgPushScope()
	g_c_scope_stack.push(TCScope(){'outer_code_buffer':g_code_buffer,'var_stores':new PCTObject[],'dbg_slots':new PCTObject[]})
	g_code_buffer=new string
	assert(!g_local_decl_buffer.n)

auto cgPopScope()
	stk=g_c_scope_stack.pop()
	vars=stk.var_stores
	vars.Sort()
	vars.Unique()
	s_inside=g_code_buffer
	g_code_buffer=stk.outer_code_buffer
	g_code_buffer.push(g_local_decl_buffer)
	g_local_decl_buffer=new string
	//g_code_buffer.push('{')
	foreach pobj_var in vars
		dat_var=readPoolTyped(pobj_var,TSCCPValue)
		t=getValueType(dat_var)
		if !t:continue
		//Writeln(dumpObject(pobj_var),' ',t)
		genType(t)
		g_code_buffer.push(' ')
		genVar(pobj_var)
		g_code_buffer.push('=(')
		genType(t)
		g_code_buffer.push(')0')
		g_code_buffer.push(';')
	foreach pecall in stk.dbg_slots
		pobjfn=getExprValueAs(readPool(pecall+EXPR_OFS_ARGS+0),g_vtid_CTVAL)
		g_code_buffer.push('TCallStackItemEx s7_Dd')
		g_code_buffer.push('={NULL,')
		genLIString(g_code_buffer,getLIObjectStringPair(pobjfn).x)
		g_code_buffer.push('};')
	g_code_buffer.push(s_inside)
	//g_code_buffer.push('}')

auto genClassName(PCTObject t)
	g_code_buffer.push("struct s7_TL")
	g_code_buffer.push(toBase32(t))
	if g_readable_c_code:
		id_name=readPool(t+FUNCTION_OFS_NAME)
		if id_name:
			g_code_buffer.push('_')
			genFilteredName(id_name)

auto genType(PCTObject t)
	if tisbuiltin(t):
		ct=readPool(t+1)
		n_bits=((ct&~CTYPE_MASK)+1)*8
		if ct==const_type(CTYPE_FLOAT,32):
			g_code_buffer.push('float')
			return
		else if ct==const_type(CTYPE_FLOAT,64):
			g_code_buffer.push('double')
			return
		if ct==CTYPE_POINTER:
			g_code_buffer.push('void* ')
			return
		if ((ct&CTYPE_MASK)==CTYPE_UINT):
			g_code_buffer.push('unsigned ')
		if n_bits==8:
			g_code_buffer.push('char')
		else if n_bits==16:
			g_code_buffer.push('short')
		else if n_bits==32:
			g_code_buffer.push('int')
		else
			assert(n_bits==64)
			g_code_buffer.push('long long')
		return
	if !t:
		g_code_buffer.push("err!")
		return
	//class / struct / lambda context
	if readPool(t)==g_tid_TFunction:
		genClassName(t)
		g_code_buffer.push("*")
		queueCodeGen(t)
		return
	if Platform.BUILD=="debug":
		Writeln(dumpObject(t))
	assert(0)
	
g_s7_TF_rtti_dtor_used=0
auto genAllCode()
	//don't generate variant ctor - it's useless... but we need its lambda ctx
	//setFFlag(getStdObject(0,STDTYPE_VARIANT),FFLAG_CGEN_QUEUED)
	genCode(g_pe_top,0)
	//it's a function queue
	for(i=0;i<g_gencode_queue.n;i++)
		genCode(g_gencode_queue[i],LEVEL_FUNCTION_HACK)
	/////////
	s_headers=new string
	s_headers.push("#define S7_POINTER_BITS "+string(Util.bitSize())+"\n")
	g_c_headers.push(getid("stdlib.h"))//for malloc
	g_c_headers.push(getid("string.h"))//for memset
	if g_enable_debug_instrumentation:
		g_c_headers.push(getid("spaprt_portable.h"))//for debug
	g_c_headers.Sort()
	g_c_headers.Unique()
	json_headers=g_json_pool[getid("h_files")]
	foreach id_header in g_c_headers
		s_headers.push("#include \"")
		s_headers.push(getIdString(id_header).Replace("\\","/"))
		s_headers.push("\"\n")
		json_headers.push(id_header)
	s_headers.push("typedef "+(Util.bitSize()==64?"long long":"int")+" s7_CT_iptr;")
	//////////
	auto genStructDef(PCTObject t)
		//avoid duplication
		auto s=g_struct_code_per_type[t]
		if !s:return
		g_struct_code_per_type[t]=string.NULL
		//generate depends first
		plambda_vars=readPool(t+FUNCTION_OFS_PLAMBDA_VARS)
		nlambda_vars=readPool(t+FUNCTION_OFS_NLAMBDA_VARS)
		for j=0:nlambda_vars-1
			pobj_var=readPool(plambda_vars+j)
			t_member=getVariableType(pobj_var)
			if t_member:genStructDef(t_member)
		//generate itself last
		s_headers.push(s)
	foreach t in g_all_struct_types
		genStructDef(t)
	//////////
	s_headers.push(g_structs_slots_buffer)
	//generate function types
	sbk=g_code_buffer
	g_code_buffer=new string
	g_c_ftypes.Sort()
	g_c_ftypes.Unique()
	foreach t_raw_function_type in g_c_ftypes
		ft=readPoolTyped(t_raw_function_type,TFunctionType)
		g_code_buffer.push('typedef ')
		if ft.t_ret&&!tisstruct(ft.t_ret):
			genType(ft.t_ret)
		else
			g_code_buffer.push('void')
		g_code_buffer.push('(*s7_TF')
		g_code_buffer.push(toBase32(t_raw_function_type))
		g_code_buffer.push(')(void*')
		for j=0:ft.n_args-1
			g_code_buffer.push(',')
			genType(readPool(ft.p_arg_types+j))
		g_code_buffer.push(');')
	if g_s7_TF_rtti_dtor_used:
		g_code_buffer.push("typedef void(*s7_TF_rtti_dtor)(void*);")
	s_headers.push(g_code_buffer)
	g_code_buffer=sbk
	//
	s_headers.push(g_forward_buffer)
	s_headers.push(g_c_global_buffer)
	if g_enable_debug_instrumentation:
		s_headers.push(g_debug_file_info_buffer)
		s_headers.push('static const TLineInfoItemEx s7_DL[]={')
		s_headers.push(g_debug_line_info_buffer)
		s_headers.push('};')
	s_headers.push(g_code_buffer)
	return s_headers

module:util
import "System.spap"
import System.Algorithm.*
import System.Console.*
const
	DEBUG_ANSI_COLOR_IN_OUTPUT=0

/////////////////////////////
//various specialized hashes
class CUniqueIDProvider(TTraits)
	int[] a
	iptr n
	iptr sz
		%get{return .a?.a.n:0}
	auto clear()
		this.a=NULL
		this.n=0L
	void _grow_to(iptr sz)
		auto a2=new int[sz?sz*2:8]
		auto a=this.a
		mask=a2.n-1
		for i=0:sz-1
			id=a[i]
			if !id:continue
			slot=-1L
			b=TTraits.getHash(id)
			b&=mask
			delta=1L
			for(;;)
				//Write('.')
				if !a2[b]:
					slot=b
					break
				b+=delta++
				b&=mask
			a2[slot]=id
		.a=a2
	iptr _find(const CREATE_NEW,TTraits.TKey key)
		grown=0
		sz=.sz
		if !CREATE_NEW:
			if !sz:return -1
		else
			if !sz:
				._grow_to(sz)
				sz=.sz
				grown=1
		:redo
		slot=-1L
		h=iptr(TTraits.computeHash(key))
		mask=.sz-1
		b=((iptr)h&mask)
		delta=1L
		auto a=this.a;
		for(;;)
			//Write('#')
			pi=a[b]
			if !pi:
				slot=b
				break
			if TTraits.isKeyEqual(pi,key):
				//found
				return pi
			b+=delta++
			b&=mask
		if !CREATE_NEW:
			return -1
		if !grown&&(.n*4+1>=sz*3||sz-.n<sz>>2):
			._grow_to(sz)
			sz=.sz
			grown=1
			goto redo
		.a[slot]=TTraits.createNew(key,h)
		.n++
		return .a[slot]

struct TMemberHashItem
	//oid-member
	int2 key
	int value
	inline int hash()
		return (this.key.x*32)^this.key.y

//note: this is NOT memory efficient!
//linked list of sorted pair arrays... slow lookup
//simple abandoned hashes + freelist
//and the freelist could be put in the same array...
//it's too much, better do an int-heap "mode" or something
class CSharedMemberHash
	TMemberHashItem[] a
	iptr n
	iptr sz
		%get{return .a?.a.n:0}
	void _grow_to(iptr sz)
		auto a2=new TMemberHashItem[sz?sz*2:8]
		auto a=this.a
		mask=a2.n-1
		for i=0:sz-1
			a_i=a[i]
			if !a_i.key.x:continue
			slot=-1L
			b=(iptr)a_i.hash()
			b&=mask
			delta=1L
			for(;;)
				if !a2[b].key.x:
					slot=b
					break
				b+=delta++
				b&=mask
			a2[slot]=a_i
		this.a=a2
	inline iptr _find(const CREATE_NEW,int2 key)
		//assert(key.x>0)
		grown=0
		sz=.sz
		if !CREATE_NEW:
			if !sz:return -1
		else
			if !sz:
				._grow_to(sz)
				sz=.sz
				grown=1
		:redo
		slot=-1L
		//h=iptr(key.hash())
		h=iptr((key.x*32)^key.y)
		mask=.sz-1
		b=(h&mask)
		delta=1L
		auto a=this.a;
		for(;;)
			pi=a[b]
			if !pi.key.x:
				slot=b
				break
			if pi.key.x==key.x&&pi.key.y==key.y:
				//found
				return b
			b+=delta++
			b&=mask
		if !CREATE_NEW:
			return -1
		if !grown&&(.n*4+1>=sz*3||sz-.n<sz>>2):
			._grow_to(sz)
			sz=.sz
			grown=1
			goto redo
		this.a[slot].key=key
		.n++
		return slot

/////////////////////////////
g_bit_size=32
inline int bitSize(){return g_bit_size}

//////////////////////////////////////
//global object id
//g_oid_counter=0
//inline int OID()
//	return ++g_oid_counter

//////////////////////////////////////
//symbol table
struct TSymbol
	iptr p_name,n
	iptr hash
	//int oid
	int user_slot

class TTraitSymbol
	typedef string TKey
	static inline iptr getHash(int id)
		return g_symbols[id].hash
	static inline iptr computeHash(string key)
		return (iptr)key.hash()
	static inline iptr isKeyEqual(int id,string key)
		//could do: __optimize__ rule for this
		return getIdString(id)==key
	static inline int createNew(string key,iptr hash)
		p=g_strings.n
		n=key.n
		g_strings.add(key)
		ret=(int)g_symbols.n
		g_symbols.add(TSymbol{.hash=hash;.p_name=p;.n=n})
		return ret

g_strings=new string
g_symbols=[TSymbol{}]
g_id_provider=new CUniqueIDProvider(TTraitSymbol)

inline int getid(string s)
	return int(g_id_provider._find(1,s))

int catid(int id0,int id1)
	return getid(getIdString(id0)+getIdString(id1))

int gettempid(int id_name)
	ret=(int)g_symbols.n
	n0=g_strings.n
	g_strings.add('$')
	if id_name:
		g_strings.add(new(getIdString(id_name)))
	g_symbols.add(TSymbol{.p_name=n0;.n=(int)g_strings.n-n0})
	return ret

If __ENABLED__('codegen.check'):
	g_id_errored=0
string getIdString(int id)
	If __ENABLED__('codegen.check'):
		if (u32)id>(u32)g_symbols.n:
			g_id_errored=1
			//assert(0)
			return "<invalid>"
	sym=g_symbols[id]
	return g_strings[sym.p_name:sym.p_name+sym.n-1]

inline int isTempId(int id)
	return id&&g_strings[g_symbols[id].p_name]=='$'

//////////////////////////////////////
//const table
const
	CTYPE_INT=0
	CTYPE_UINT=0x10
	CTYPE_FLOAT=0x20
	CTYPE_SPECIAL=0x30
	CTYPE_POINTER=CTYPE_SPECIAL+0
	CTYPE_TYPED_NULL=CTYPE_SPECIAL+1
	CTYPE_MASK=0x30
	CTYPE_COUNT=CTYPE_TYPED_NULL+1
	CTYPE_INVALID=-1
struct TConstValue
	i64 val_bin
	int type
	//int oid
	inline int operator==(TConstValue b)
		return this.val_bin==b.val_bin&&this.type==b.type
	inline int operator!=(TConstValue b)
		return this.val_bin!=b.val_bin||this.type!=b.type
inline int const_type(int t,int bsize)
	return t|((bsize>>3)-1)

class TTraitConstValue
	typedef TConstValue TKey
	static inline iptr getHash(int id)
		key=g_const_values[id]
		return ((iptr)key.val_bin)^(iptr)(key.val_bin>>32)^(iptr)key.type
	static inline iptr computeHash(TConstValue key)
		return ((iptr)key.val_bin)^(iptr)(key.val_bin>>32)^(iptr)key.type
	static inline iptr isKeyEqual(int id,TConstValue key)
		//could do: __optimize__ rule for this
		key0=g_const_values[id]
		return key0.val_bin==key.val_bin&&key0.type==key.type
	static inline int createNew(TConstValue key,iptr hash)
		key2=key
		//key2.oid=OID()
		ret=(int)g_const_values.n
		g_const_values.add(key2)
		return ret

g_const_values=[TConstValue{}]
g_const_provider=new CUniqueIDProvider(TTraitConstValue)

inline int getid_const(int t,i64 val)
	return int(g_const_provider._find(1,TConstValue{.val_bin=val;.type=t}))

//g_ctnumber_freelist=0
//int newCTNumber()
//	t=const_type(CTYPE_INT,32)
//	if g_ctnumber_freelist:
//		ret=g_ctnumber_freelist
//		g_ctnumber_freelist=(int)g_const_values[g_ctnumber_freelist].val_bin
//		g_const_values[ret]=TConstValue{.oid=0;.type=t}
//	else
//		ret=(int)g_const_values.n
//		g_const_values.add(TConstValue{.oid=0;.type=t})
//	return ret

inline TConstValue &ctNumber(int cid)
	inline get{return g_const_values[cid]}
	inline set{g_const_values[cid]=value}

//void freeCTNumber(int cid)
//	g_const_values[cid].val_bin=(i64)g_ctnumber_freelist
//	g_ctnumber_freelist=cid

inline i64 getBitMask(int n_bits)
	if n_bits==64:return -1LL
	return (i64(1)<<n_bits)-1

int isConstZero(TConstValue val)
	if val.type==CTYPE_TYPED_NULL:return 1
	n_bits=((val.type&~CTYPE_MASK)+1)*8
	if val.type==CTYPE_POINTER:
		n_bits=util.bitSize()
	elif (val.type&CTYPE_MASK)==CTYPE_FLOAT:
		n_bits--
	return !(val.val_bin&getBitMask(n_bits))

int isConstNegOne(TConstValue val)
	if val.type==CTYPE_TYPED_NULL||val.type==CTYPE_POINTER:return 0
	n_bits=((val.type&~CTYPE_MASK)+1)*8
	if (val.type&CTYPE_MASK)==CTYPE_FLOAT:
		if val.type==const_type(CTYPE_FLOAT,32):return (int)val.val_bin==0xbf800000
		assert(val.type==const_type(CTYPE_FLOAT,64))
		return val.val_bin==__double_as_longlong(-1.0)
	return !(~val.val_bin&getBitMask(n_bits))

int isConstOne(TConstValue val)
	if val.type==CTYPE_TYPED_NULL||val.type==CTYPE_POINTER:return 0
	n_bits=((val.type&~CTYPE_MASK)+1)*8
	if (val.type&CTYPE_MASK)==CTYPE_FLOAT:
		if val.type==const_type(CTYPE_FLOAT,32):return (int)val.val_bin==0x3f800000
		assert(val.type==const_type(CTYPE_FLOAT,64))
		return val.val_bin==__double_as_longlong(1.0)
	return (val.val_bin&getBitMask(n_bits))==i64(1)

//////////////////////////////////////
//error management
const
	ETYPE_ERROR=0
	ETYPE_WARNING=1
	ETYPE_NOTE=2
	ETYPE_LOW_LEVEL_ERROR=3
struct TErrorRecord
	int type
	int epos0,epos1
	int id_estr
g_errors=new TErrorRecord[]

struct TSourceFile
	int id_fn
	iptr n0,sz
	int[] lines
g_files=new TSourceFile[]
g_feed=new u8[]
iptr loadSourceFile(int id_fn)
	if !g_feed.n:g_feed.add((u8)0)
	n0=g_feed.n
	fn=getIdString(id_fn)
	src=System.IO.ReadAllText(fn)
	if !src:return -1L
	g_feed.add(src[0:].ConvertToAsBinary(u8))
	g_feed.add((u8)0)
	g_feed.add((u8)0)//for safety
	g_files.add(TSourceFile{.id_fn=id_fn;.n0=n0;.sz=src.n})
	return n0
int,int,int getLineInfo(int epos)
	fid=int(g_files.Bisect(function(a){return a.n0<=epos})-1)
	if fid<0:
		//assert(0)
		return 0,0,0
	ccnt=int(epos-g_files[fid].n0)
	lines=g_files[fid].lines
	if !lines:
		lines=[int(i) for i=0:g_files[fid].sz-1 if !i||g_feed[g_files[fid].n0+i-1]==(u8)'\n']
		g_files[fid].lines=lines
	ln=int(lines.Bisect(function(a){return a<=ccnt})-1)
	assert(ln>=0)
	return g_files[fid].id_fn,ln,ccnt-lines[ln]

inline void error(int type,iptr epos0,iptr epos1,string serr)
	g_errors.add(TErrorRecord{.type=type;.epos0=int(epos0);.epos1=int(epos1);.id_estr=getid(serr)})
	If __ENABLED__('codegen.check'):
		id_fn0,ln0,col0=getLineInfo(int(epos0))
		id_fn1,ln1,col1=getLineInfo(int(epos1))
		assert(id_fn0==id_fn1)
		if ln0==ln1:
			Writeln(getIdString(id_fn0),':',ln0+1,',',col0+1,'-',col1+1,': ',serr)//todo
		else
			Writeln(getIdString(id_fn0),':',ln0+1,',',col0+1,'-',ln1+1,',',col1+1,': ',serr)//todo

inline string cite_raw(iptr epos0,iptr epos1)
	assert(epos1>0)
	return g_feed[epos0:epos1-1].ConvertToAsBinary(char)

////////////////////////////
g_enable_timing=0
g_enable_dump=0
timers=new i64[]
timer_names=new string[]
int tnew(string s)
	timers.add(0LL)
	timer_names.add(s)
	return (int)timer_names.n-1
inline void tbegin(int id)
	if g_enable_timing:timers[id]-=System.Time.tick64
inline void tend(int id)
	if g_enable_timing:timers[id]+=System.Time.tick64
void tprint()
	if g_enable_timing:
		foreach sname,I in timer_names
			System.IO.stderr.WriteAsText(sname,'=',string(System.Time.TicksToSeconds(timers[I])*1000.,2),'ms\n')

g_is_console=-1
g_c_id_allowed=[
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//0
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//1
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//2
u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1), u8(1),u8(1),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//3
u8(0),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1), u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),//4
u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1), u8(1),u8(1),u8(1),u8(0),u8(0),u8(0),u8(0),u8(1),//5
u8(0),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1), u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),//6
u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1),u8(1), u8(1),u8(1),u8(1),u8(0),u8(0),u8(0),u8(0),u8(0),//7
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//8
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//9
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//10
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//11
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//12
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//13
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),//14
u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0), u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0),u8(0)
];

string FormatCCode(string feed)
	sret=new string
	indent=0
	nbra=0
	in_str=0
	in_slash=0
	void nextline()
		sret.add('\n')
		for j=0:indent-1
			sret.add('  ')
	foreach ch,I in feed
		if in_str:
			sret.add((char)ch)
			if !in_slash:
				if ch=='\\':
					in_slash=1
				if int(u8(ch))==in_str:
					in_str=0
			else
				in_slash=0
		else
			if ch=='"'||ch=='\'':
				in_str=ch
			if ch=='('||ch=='[':
				nbra++
			if ch==']'||ch==')':
				nbra--
			if ch=='}':
				if sret.n&&sret.back()==' ':sret.pop()
				if sret.n&&sret.back()==' ':sret.pop()
			sret.add((char)ch)
			if ch=='{':
				indent++
				nextline()
			elif ch=='}':
				indent--
				if I<feed.n-2&&feed[I+1]==';':
					//nothing
				else
					nextline()
			elif ch==';'&&!nbra:
				nextline()
	return sret

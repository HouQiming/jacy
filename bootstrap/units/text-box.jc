/*
todo:
	syntax highlighter
*/
import Gui2D.*
import Gui2D.detail.*
import Javascript.*
import System.Algorithm.*
import System.Math.*
import System.Console.*

struct TRenderingInfo
	double2 bb
	iptr seek_ret

///////////////////////////////
//double should be as-ed
class ITextStateHandler
	iptr id
	function():string name
	function():int stateSize
	function():int isLineOnly
	//The "add" function must be associative
	//The result should be written to "a"
	//if AddBlock returns anything... it's considered as a per-block cache
	function(CEditableText caller,i64[] a,string s):i64[] PreprocessBlock
	function(i64[] a,i64[] pp,string s,iptr ofs) AddString
	function(i64[] a,i64[] b) Add
	//For coloring states, we need a colorer
	function(i64[] a,string s):u8[] ComputeCharColorID
	//For rendering states, we need a layouter
	function(JSObject obj) SetTextStyle
	function(i64[] a,i64[] pp,string s, double dx,double dy,float scaling) RenderText
	function(i64[] a,i64[] pp,string s,iptr ofs):float GetCharacterHeightAt
	function():TFont GetDefaultFont
	function(double2 xy,JSObject obj):double SetCaretOverlay
	function():double GetCaretOffset
	//For seeking states, we need comparison and in-block seeking
	function(i64[] a,i64[] b):int Compare
	function(i64[] a,i64[] pp,string s,i64[] b):iptr SeekInBlock
	////////////////////
	//for JS operations
	function(JSObject proto) __JS_prototype

auto combineEditorOffset(double2 bb0,double2 bb1)
	bb=bb0
	if bb1.y:
		bb.x=bb1.x
		bb.y+=bb1.y
	else
		bb.x+=bb1.x
	return bb

inline CharToUtf8(auto s,T)
	return {'forEach':inline(fbody){
		ch0=0;nnxt=0;II=T(0)
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					ch0=(ch&0x1f)
					nnxt=1
					if ch&0x20:
						nnxt++
						if ch&0x10:
							nnxt++
							ch0&=7
				else
					ch0=(ch0<<6)+(ch&63)
					nnxt--
				if nnxt:continue
				ch=ch0
			else
				II=I
			fbody(ch,II)
	}}	

inline CharToUtf8Backward(auto s,T)
	return {'forEach':inline(fbody){
		ch0=0;nshift=0;II=T(0)
		foreach chc,I in s
			ch=int(u8(chc))
			if ch>=128:
				if ch&0x40:
					II=I
					chprefix=(ch&0x1f)
					if ch&0x20:
						if ch&0x10:
							chprefix&=7
					ch=ch0+(chprefix<<nshift)
					ch0=0
					nshift=0
				else
					ch0+=(ch&63)<<nshift
					nshift+=6
					continue
			else
				II=I
			fbody(ch,II)
	}}	

inline Utf8Chars(string s)
	return CharToUtf8(s,iptr)

inline Utf8CodeAt(string s,ofs)
	ret=0
	foreach ch in (CharToUtf8({'forEach':inline(fbody){
				for i=iptr(ofs):s.n-1
					fbody(s[i],i)
			}},iptr))
		ret=ch
		break
	return ret

inline Utf8Length(int ch)
	ret=1
	if ch>=128:ret++
	if ch>=2048:ret++
	if ch>=65536:ret++
	return ret

auto MakeCharSet(string e)
	ok=new u32[8]
	inv=0
	s=0
	if e[0]=='^':
		inv=1;s++
	for(;s<e.n;s++)
		if s+1<e.n&&e[s+1]=='-':
			for(i=u32(u8(e[s]));i<=u32(u8(e[s+2]));i++)
				ok[i>>5]|=(1u<<int(i&31u));
			s+=2
		else
			ok[e[s]>>5]|=(1u<<int(u32(u8(e[s]))&31u));
	if inv:
		for i=0:7
			ok[i]=~ok[i]
	return uint4(ok[0],ok[1],ok[2],ok[3])

inline epsEqual(a,b)
	return abs(__double_as_longlong(double(a))-__double_as_longlong(double(b)))<(1LL<<32)

inline epsUp(a)
	ret=__double_as_longlong(double(a))
	if ret<<1:ret+=(1LL<<32)^(ret>>63)
	return __longlong_as_double(ret)

inline epsDown(a)
	ret=__double_as_longlong(double(a))
	if ret<<1:ret-=(1LL<<32)^(ret>>63)
	return __longlong_as_double(ret)

auto GetStringWidth(TFont m_font,string s)
	w_overlay=0.
	foreach ch,I in Utf8Chars(s)
		w_overlay+=g_renderer.GetCharacterAdvance(m_font,ch)
	return w_overlay

class CLayouter_baseline
	MODE_BB=0
	MODE_SEEK=1
	MODE_RENDER=2
	/////////
	m_wrap_width=0.f
	m_tab_width=8
	m_font=TFont()
	m_color=0xff000000
	m_bgcolor_selection=0xff800000
	CHyphenator m_hyphenator
	/////////////////
	name=function(){return "renderer"}
	stateSize=function(){return 2}
	isLineOnly=function(){return 1}
	/////////////////
	PreprocessBlock=function(CEditableText caller,i64[] a,string s){
		line_breaks=new i64[]
		if m_wrap_width>0.f:
			line_breaksi=DPLayoutText(m_font,s,m_wrap_width, caller.isWordChar,m_hyphenator)
			line_breaks=new i64[line_breaksi.n]
			for i=0:line_breaks.n-1
				line_breaks[i]=i64(line_breaksi[i]&0x7fffffff)|(i64(line_breaksi[i]&0x80000000)<<32)
		else
			//it's the *additional* line_breaks
			line_breaks.push(0LL)
			line_breaks.push(i64(s.n))
		return line_breaks
	}
	AddString=function(i64[] a,i64[] line_breaks,string s,iptr ofs){
		bb=_RenderText(MODE_BB,a,line_breaks,s,ofs, 0.,0.,0.f).bb
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
	}
	Add=function(i64[] a,i64[] b){
		bb=combineEditorOffset(double2(__longlong_as_double(a[0]),__longlong_as_double(a[1])),double2(__longlong_as_double(b[0]),__longlong_as_double(b[1])))
		a[0]=__double_as_longlong(bb.x)
		a[1]=__double_as_longlong(bb.y)
	}
	/////////////////
	//compare known-positive doubles as ints
	Compare=function(i64[] a,i64[] b){
		ret=__C_compare(a[1],b[1])
		if ret==0:ret=__C_compare(a[0],b[0])
		return ret
	}
	SeekInBlock=function(i64[] a,i64[] line_breaks,string s,i64[] b){
		return iptr(_RenderText(MODE_SEEK,a,line_breaks,s,s.n, __longlong_as_double(b[0]),__longlong_as_double(b[1]),0.f).seek_ret)
	}
	/////////////////
	double3 m_caret_overlay
	JSObject m_overlay_obj
	double m_caret_offset
	SetTextStyle=function(JSObject obj){
		m_font=obj["font"].as(TFont)
		m_font.h/=g_renderer.m_pixels_per_unit
		m_color=int(obj["color"].or(u32(m_color)))
		m_bgcolor_selection=int(obj["bgcolor_selection"].or(u32(m_bgcolor_selection)))
		m_tab_width=obj["tab_width"].or(8)
		m_wrap_width=obj["wrap_width"].or(0.f)
		m_hyphenator=obj["hyphenator"].or(g_default_hyphenator)
	}
	SetCaretOverlay=function(double2 xy,JSObject obj){
		m_overlay_obj=obj
		w_overlay=0.
		if obj:
			s=obj["text"].as(string)
			if s:
				w_overlay=GetStringWidth(m_font,s)
		m_caret_overlay=double3(xy.x,xy.y,w_overlay)
		m_caret_offset=0.
		return w_overlay
	}
	GetCaretOffset=function(){
		//Writeln(m_caret_overlay,' ',m_caret_offset)
		//if m_overlay_obj:
		//	Writeln(m_overlay_obj["text"].as(string))
		return m_caret_offset
	}
	_RenderText=function(int mode,i64[] a,i64[] line_breaks,string s,iptr ofs, double dx,double dy,float scaling){
		if mode==MODE_RENDER:
			//Writeln('before fnt_scaled ',m_font.h,' ',scaling)
			fnt_scaled=m_font
			fnt_scaled.h*=scaling
			//smart emboldening for SRGB
			if g_renderer.m_srgb_supported:
				fnt_scaled.embolden+=int((1.f-float(19589*(m_color&0xff)+38470*((m_color>>8)&0xff)+7477*((m_color>>16)&0xff))/float(0xff0000))*3000.f/fnt_scaled.h)
			//Writeln('after fnt_scaled ',m_font.h)
			scalingd=double(scaling)
		w_tab=double(m_tab_width)*double(g_renderer.GetCharacterAdvance(m_font,int(' ')))
		hc=g_renderer.GetCharacterHeight(m_font)
		x=__longlong_as_double(a[0])
		y=__longlong_as_double(a[1])
		if mode==MODE_RENDER:
			if epsEqual(y,m_caret_overlay.y)&&x>m_caret_overlay.x:
				x+=m_caret_overlay.z
		//Writeln('>>> ',dx,' ',dy)
		is_wrapping=(m_wrap_width>0.f)
		w_space=double(g_renderer.GetCharacterAdvance(m_font,int(' ')))
		w_hyphen=double(g_renderer.GetCharacterAdvance(m_font,int('-')))
		for i=0:line_breaks.n-2
			got_newline=0
			//justified wrapping
			space_padding=0.
			has_hyphen=0
			if is_wrapping&&i<line_breaks.n-1:
				nspaces=0
				n_trailing_space=0
				w_total=0.
				if line_breaks[i+1]<0LL:
					//we have a hyphen
					has_hyphen=1
					w_total+=w_hyphen
				for ch,I in Utf8Chars(s[iptr(line_breaks[i]&0x7fffffffffffffffLL):iptr((line_breaks[i+1]&0x7fffffffffffffffLL)-1)])
					if ch=='\r'||ch=='\n':
						//nothing
						if ch=='\n':
							got_newline=1
						continue
					else if ch==' '||ch=='\t':
						nspaces++
						n_trailing_space++
						w_total+=w_space
					else
						n_trailing_space=0
						w_total+=double(g_renderer.GetCharacterAdvance(m_font,ch))
				nspaces-=n_trailing_space
				remaining_space=double(m_wrap_width)-(w_total-w_space*double(n_trailing_space))
				//with paragraph consistency, got_newline should hold for i==line_breaks.n-2 unless we're at eof
				if nspaces>0&&remaining_space>0.f&&!got_newline&&i<line_breaks.n-2:
					space_padding=remaining_space/float(nspaces)
				//Writeln(space_padding,' ',nspaces,' ',space_padding)
			got_newline=0
			///////////////
			for ch,I in Utf8Chars(s[iptr(line_breaks[i]&0x7fffffffffffffffLL):iptr(min(line_breaks[i+1]&0x7fffffffffffffffLL,ofs))-1])
				if mode==MODE_SEEK:
					if y>epsUp(dy)||dy>=epsDown(y)&&dy<epsDown(y+hc)&&x>=dx:
						return TRenderingInfo(){bb:double2(x,y),seek_ret:iptr(line_breaks[i]+I)}
					//mm.push(TMouseMap(){pos:double2(x,y),ccnt:line_breaks[i]+I})
				if mode==MODE_RENDER:
					if epsEqual(x,m_caret_overlay.x)&&epsEqual(y,m_caret_overlay.y):
						if m_overlay_obj["type"].as(string)=="IME":
							s_overlay=m_overlay_obj["text"].as(string)
							if s_overlay:
								cmap=new iptr[]
								foreach chj,J in Utf8Chars(s_overlay)
									cmap.push(J)
								cmap.push(s_overlay.n)
								overlay_sel0=m_overlay_obj["start"].as(iptr)
								overlay_sel1=overlay_sel0+m_overlay_obj["length"].as(iptr)
								overlay_sel0=min(overlay_sel0,cmap.n-1)
								overlay_sel1=min(overlay_sel1,cmap.n-1)
								if uptr(overlay_sel0)<uptr(cmap.n)&&uptr(overlay_sel1)<uptr(cmap.n):
									x_sel0=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel0]-1])
									x_sel1=GetStringWidth(m_font,s_overlay[:cmap[overlay_sel1]-1])
									m_caret_offset=x_sel1
									if x_sel0>x_sel1:
										(x_sel0,x_sel1)=(x_sel1,x_sel0)
									//selection - pre-draw the highlight
									if x_sel0<x_sel1:
										g_renderer.DrawBitmap(0, float((x+x_sel0)*scalingd+dx),float(y*scalingd+dy),float((x_sel1-x_sel0)*scalingd),hc, m_bgcolor_selection)
								else
									assert(0)
								xo=x
								foreach chj,J in Utf8Chars(s_overlay)
									dx_j=double(g_renderer.GetCharacterAdvance(m_font,chj))
									g_renderer.DrawChar(fnt_scaled, float(xo*scalingd+dx),float(y*scalingd+dy),m_color, chj)
									xo+=dx_j
							else
								assert(0)
							//draw the underline
							y_underline=float(y*scalingd+dy)+fnt_scaled.h*(fnt_scaled.pfnt.y_baseline_per_height+0.02f)
							g_renderer.DrawBitmap(0, float(x*scalingd+dx),y_underline,float(m_caret_overlay.z*scalingd),max(fnt_scaled.h*0.05f,1.f), m_color)
						else
							assert(0)
						x+=m_caret_overlay.z
				if ch=='\r'||ch=='\n':
					//nothing
					if ch=='\n':
						got_newline=1
						if !is_wrapping:
							x=0.
							y+=hc
					continue
				else if ch==' ':
					x+=w_space+space_padding
				else if ch=='\t':
					if is_wrapping:
						x+=w_space+space_padding
					else
						x=(floor(x/w_tab)+1.0)*w_tab
				else
					dx_i=double(g_renderer.GetCharacterAdvance(m_font,ch))
					if mode==MODE_RENDER:
						//pt.push(TCharJob(){pos:double2(x,y),ch:ch,color:m_color})
						//Writeln(x,' ',y,' ',m_font.h,' ',fnt_scaled.h,' ',scalingd,' ',ch,' ',m_color)
						g_renderer.DrawChar(fnt_scaled, float(x*scalingd+dx),float(y*scalingd+dy),m_color, ch)
					x+=dx_i
			if (line_breaks[i+1]&0x7fffffffffffffffLL)>ofs:break
			if is_wrapping:
				if mode==MODE_RENDER&&has_hyphen:
					g_renderer.DrawChar(fnt_scaled, float(x*scalingd+dx),float(y*scalingd+dy),m_color, int('-'))
				if got_newline||i<line_breaks.n-2:
					x=0.
					y+=hc
		return TRenderingInfo(){bb:double2(x,y),seek_ret:s.n}
	}
	RenderText=function(i64[] a,i64[] pp,string s, double dx,double dy,float scaling){
		_RenderText(MODE_RENDER,a,pp,s,s.n,dx,dy,scaling)
	}
	GetCharacterHeightAt=function(i64[] a,i64[] pp,string s,iptr ofs){
		return g_renderer.GetCharacterHeight(m_font)
	}
	GetDefaultFont=function(){
		return m_font
	}
	//////////////////////////////
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"m_color")
	}

///////////////////////////////
class CHyphenator
	int[][string] exceptions
	u16[] dfa
	u16[] ops
	int n_char_types
	int[int] char_map
	min_hyphen=6
	auto HyphenateWord(string sword)
		exception=exceptions[sword.ToLower()]
		if exception:return exception
		if sword.n<min_hyphen:return new int[]
		//returns int separation points
		hyp_levels=new u8[]
		hyp_points=new int[]
		n=n_char_types
		local_dfa=dfa
		local_char_map=char_map
		local_ops=ops
		st=0
		inline goDown(int ch)
			st=int(local_dfa[st*n+ch])
			if st>=32768:
				st-=32768
				for(;;)
					op=int(local_ops[st])
					if op>=32768:
						st=op-32768
						break
					//4as. - it *could* try to place a value on pos 0
					addr=int(hyp_levels.n)-(op&0xff)
					if u32(addr)<u32(hyp_levels.n):
						lv0=int(hyp_levels[addr])
						lv1=(op>>8)
						if lv0<lv1:
							hyp_levels[addr]=lv1
					//else
					//	Writeln(int(hyp_levels.n),' ',(op&0xff))
					assert(u32(addr+1)<=u32(hyp_levels.n))
					st++
		goDown(0)
		foreach ch,I in Utf8Chars(sword)
			hyp_points.push(int(I))
			hyp_levels.push(u8(0))
			goDown(local_char_map[ch])
		hyp_points.push(int(sword.n))
		hyp_levels.push(u8(0))
		goDown(0)
		//use -3 to make sure we ignore the word tail
		//Writeln(hyp_levels)
		//Writeln(hyp_points)
		n2=0
		for i=0:hyp_points.n-3
			if int(hyp_levels[i])&1:
				hyp_points[n2++]=hyp_points[i+1]
		hyp_points.resize(n2)
		return hyp_points
	auto debugDumpHyphenation(string sword)
		hyp_points=[0]
		hyp_points.push(HyphenateWord(sword))
		hyp_points.push(int(sword.n))
		s=new string
		for i=0:hyp_points.n-2
			if i:SWrite(s,'-')
			SWrite(s,sword[hyp_points[i]:hyp_points[i+1]-1])
		return s

auto createDefaultHyphenator()
	ret=new CHyphenator
	ret.exceptions=new int[][string]
	ret.dfa=[u16(0)]
	ret.ops=new u16[]
	ret.n_char_types=1
	ret.char_map=new int[int]
	return ret

g_default_hyphenator=createDefaultHyphenator()

auto parseTexHyphenFile(JSContext JS,string sdata)
	//pack ops at the tail as i8
	ret=new CHyphenator
	is_pattern=1
	all_patterns=new string[]
	all_exceptions=new int[][string]
	foreach sline in sdata.Tokenize("\r\n")
		if sline[0]=='%':continue
		if sline[0]=='\\':
			is_pattern=(sline.StartsWith("\\pattern"))
			continue
		if sline.n>=128:
			if Platform.BUILD=="debug":
				Writeln('pattern too long: ',sline)
			return CHyphenator.NULL
		if sline[0]=='{'||sline[0]=='}':continue
		spattern=new string
		if is_pattern:
			//insert into 
			ops=new string
			foreach chc,I in sline
				ch=int(u8(chc))
				if u32(ch-int('0'))<10u:
					ops.push(i8(spattern.n))
					ops.push(i8(ch-int('0')))
				else
					spattern.push(chc)
			spattern.push(i8(0))
			all_patterns.push(spattern+ops)
		else
			opsi=new int[]
			foreach chc,I in sline
				if chc=='-':
					opsi.push(int(spattern.n))
				else
					spattern.push(chc)
			all_exceptions[spattern]=opsi
			//Writeln(spattern,' ',opsi)
	ret.exceptions=all_exceptions
	///////////
	//todo: make this a function
	chappeared=new int[int]
	foreach spattern in all_patterns
		foreach ch,I in Utf8Chars(spattern)
			if !ch:break
			if ch!=char('.'):
				chappeared[ch]=1
	chlist=new int[]
	foreach d,k,I in chappeared
		chlist.push(k)
		chappeared.D(I)=int(chlist.n)
	//do the upper case
	chlist_upper=Utf8ToUnicode32(JS["String"]["prototype"]["toUpperCase"].CallAsMethod(string,Unicode32ToUtf8(chlist)))
	if chlist_upper.n!=chlist.n:
		if Platform.BUILD=="debug":
			Writeln('bad upper case conversion');
			Writeln('  ',Unicode32ToUtf8(chlist))
			Writeln('  ',Unicode32ToUtf8(chlist_upper))
		return CHyphenator.NULL
	for i=0:chlist.n-1
		chappeared[chlist_upper[i]]=chappeared[chlist[i]]
	ret.char_map=chappeared
	n_char_types=int(chlist.n+1)
	ret.n_char_types=n_char_types
	//first-char lists
	//all_patterns.Sort()
	fc_lists=new int[][n_char_types]
	for i=0:fc_lists.n-1
		fc_lists[i]=new int[]
	foreach spattern,I in all_patterns
		ch0=Utf8CodeAt(spattern,0L)
		fc_lists[chappeared[ch0]].push(int(I)|(1<<16))
	//multi-state DFA -> single-state DFA
	if all_patterns.n>=32768:
		if Platform.BUILD=="debug":
			Writeln('too many patterns: ',all_patterns.n)
		return CHyphenator.NULL
	state_map=new int[int[]]
	ops_map=new int[u16[]]
	state_addrs=[0]
	Q=[new int[]]
	dfa=new u16[n_char_types]
	dfa_ops=new u16[]
	for(i=0L;i<Q.n;i++)
		cur_states=Q[i]
		my_addr=i*n_char_types
		tran=new int[][n_char_types]
		for j=0:tran.n-1
			tran[j]=new(fc_lists[j])
		//fc_lists
		foreach stpacked in cur_states
			pid=(stpacked&0xffff)
			pos=(stpacked>>16)
			s_pid=all_patterns[pid]
			ch_utf8=Utf8CodeAt(s_pid,pos)
			ch_std=chappeared[ch_utf8]
			pos+=Utf8Length(ch_utf8)
			if !s_pid[pos]:
				//add action
				tran[ch_std].push(~pid)
			else
				tran[ch_std].push(pid+(pos<<16))
		//Write(cur_states,' ')
		for j=0:tran.n-1
			new_states=tran[j]
			new_states.Sort()
			new_states.Unique()
			actions=u16[].NULL
			if new_states.n&&new_states[0]<0:
				//actions
				actions=new u16[]
				p_states=new_states.n
				for k=0:new_states.n-1
					if new_states[k]>=0:
						p_states=k
						break
					else
						pid=~new_states[k]
						s_pid=all_patterns[pid]
						pzero=s_pid.IndexOf(char(0))
						for paction=pzero+1:2:s_pid.n-2
							action_pos=pzero-int(u8(s_pid[paction]))
							action_value=int(u8(s_pid[paction+1]))
							actions.push(u16(action_value*256+action_pos+1))
				actions.Sort()
				actions.Unique()
				new_states=new_states[p_states:]
			new_stid=state_map[new_states]
			if !new_stid:
				if new_states.n:
					new_stid=int(Q.n)
					Q.push(new_states)
					dfa.resize(dfa.n+n_char_types)
					assert(dfa.n==n_char_types*Q.n)
					state_map[new_states]=new_stid
			if actions:
				//fill dfa
				actions.push(u16(32768+new_stid))
				opid=ops_map[actions]
				if !opid:
					opid=32768+int(dfa_ops.n)
					dfa_ops.push(actions)
					ops_map[actions]=opid
				addr_j=opid
			else
				addr_j=new_stid
			dfa[my_addr+j]=u16(addr_j)
			//Write(' ',new_stid)
		//Writeln()
	ret.dfa=dfa
	if Q.n>=32768:
		if Platform.BUILD=="debug":
			Writeln('dfa too complicated: ',Q.n)
		return CHyphenator.NULL
	if dfa_ops.n>=32767:
		if Platform.BUILD=="debug":
			Writeln('ops too complicated: ',dfa_ops.n)
		return CHyphenator.NULL
	//Writeln('patterns = ',all_patterns.n)
	//Writeln('dfa size = ',dfa.n)
	//Writeln('ops size = ',dfa_ops.n)
	//Writeln('states = ',Q.n)
	//Writeln(dfa)
	//Writeln(dfa_ops)
	ret.ops=dfa_ops
	return ret

auto DPLayoutParagraph(TFont fnt,string s,float w_line, function(int ch):int isWordChar,CHyphenator hyp)
	//ignore tabs
	FLAG_WORD=0x80000000
	FLAG_SPACE=0x40000000
	FLAG_NC=0x3fffffff
	MAX_HYPHENATABLE_WORD=256
	LEADING_SPACE_BADNESS=1e18f
	inline spaceBadness(w){return w*w*w}
	struct TDPAtom
		int nc_flags
		float lg
	atoms=new TDPAtom[]
	w_hyphen=g_renderer.GetCharacterAdvance(fnt,int('-'))
	w_space=g_renderer.GetCharacterAdvance(fnt,int(' '))
	HYPHEN_BADNESS=spaceBadness(w_hyphen*0.5f)
	auto addWord(iptr a,iptr b)
		if b-a<=MAX_HYPHENATABLE_WORD:
			hpoints=hyp.HyphenateWord(s[a:b-1])
		else
			hpoints=new int[]
		//Writeln('hpoints=',hpoints)
		w_current=0.f
		I_last=0L
		ph=0
		foreach ch,I in Utf8Chars(s[a:b-1])
			wc=g_renderer.GetCharacterAdvance(fnt,ch)
			w2=w_current+wc
			if I>I_last&&(w2>w_line-w_hyphen||ph<hpoints.n&&I==hpoints[ph]):
				atoms.push(TDPAtom(){nc_flags:int(I-I_last)+FLAG_WORD,lg:w_current})
				w_current=0.f
				I_last=I
				while ph<hpoints.n&&I>=hpoints[ph]
					ph++
				w2=w_current+wc
			w_current=w2
		if I_last<b-a:
			atoms.push(TDPAtom(){nc_flags:int(b-a-I_last)+FLAG_WORD,lg:w_current})
	p_last_word=0L
	inline isCJK(int ch)
		return ch>=0x2E80&&ch<0xA640||ch>=0xAC00&&ch<0xD7FF||ch>=0xF900&&ch<0xFAFF||ch>=0xFE30&&ch<0xFE4F||ch>=0x20000
	foreach ch,I in Utf8Chars(s)
		if !isWordChar(ch)||isCJK(ch):
			if p_last_word<I:
				addWord(p_last_word,I)
			//////
			lg=g_renderer.GetCharacterAdvance(fnt,ch==int('\t')?int(' '):ch)
			nc_flags=Utf8Length(ch)
			p_last_word=I+nc_flags
			if ch=='\r':
				lg=0.f
			else if ch==' '||ch=='\t':
				nc_flags|=FLAG_SPACE
			atoms.push(TDPAtom(){nc_flags:nc_flags,lg:lg})
	if p_last_word<s.n:
		addWord(p_last_word,s.n)
	//////////////////////////////
	//the real DP
	//start from max-greedy, stop when the current line clearly makes it suboptimal
	n=int(atoms.n)
	best=new float[n+1]
	blast=new int[n+1]
	//todo: need O(n) j_min
	for i=1:n
		best_i=1e18f
		w0=0.f
		base_badness=0.f
		if i<n&&(atoms[i].nc_flags&atoms[i-1].nc_flags&FLAG_WORD):
			//need a hyphen
			w0=w_hyphen
			base_badness=HYPHEN_BADNESS
		if i<n&&(atoms[i].nc_flags&FLAG_SPACE):
			//spaces can't lead a line
			base_badness=LEADING_SPACE_BADNESS
		//greedy first
		w=w0
		j_min=i-1
		for j=i-1:-1:0
			w_j=atoms[j].lg
			if j==i-1&&(atoms[i-1].nc_flags&FLAG_SPACE):
				//trailing space doesn't count
				w_j=0.f
			w2=w+w_j
			if w2>=w_line:break
			w=w2
			j_min=j
		w_tail=max(w_line-w,0.f)
		blast_i=j_min
		for j=j_min:i-1
			if j==i-1&&(atoms[i-1].nc_flags&FLAG_SPACE):
				break
			cost=best[j]
			if i!=n:
				cost_j=spaceBadness(w_tail)
				if cost_j>best_i:
					break
				cost+=cost_j
			if best_i>cost:
				best_i=cost
				blast_i=j
			w_tail+=atoms[j].lg
		best[i]=best_i+base_badness
		blast[i]=blast_i
	lbreaks=new int[]
	p=n
	for(;;)
		lbreaks.push(p)
		if !p:break
		p=blast[p]
	/////
	nc=0
	v0=0
	for i=0:n-1
		v=atoms[i].nc_flags
		nc_i=nc
		if v&v0&FLAG_WORD:
			nc_i|=0x80000000
		v0=v
		atoms[i].nc_flags=nc_i
		nc+=(v&FLAG_NC)
	atoms.push(TDPAtom(){nc_flags:nc})
	lbreaks_fwd=new int[lbreaks.n]
	for i=0:lbreaks.n-1
		lbreaks_fwd[lbreaks.n-1-i]=atoms[lbreaks[i]].nc_flags
	return lbreaks_fwd

auto DPLayoutText(TFont fnt,string s,float w_line, function(int ch):int isWordChar,CHyphenator hyp)
	//\n handling
	lbreaks_ret=new int[]
	foreach sline,I in s.TokenizeEx("\n",s.TOKENIZE_ALLOW_EMPTY|s.TOKENIZE_INCLUDE_SEPARATOR)
		lbreaks_paragraph=DPLayoutParagraph(fnt,sline,w_line, isWordChar,hyp)
		lbreaks_paragraph.pop()
		foreach d in lbreaks_paragraph
			lbreaks_ret.push(d+int(I))
	lbreaks_ret.push(int(s.n))
	//Writeln(s,' ',lbreaks_ret)
	//for i=0:lbreaks_ret.n-2
	//	Write(s[(lbreaks_ret[i]&0x7fffffff):(lbreaks_ret[i+1]&0x7fffffff)-1])
	//	if lbreaks_ret[i+1]<0:Write('-')
	//	Writeln()
	return lbreaks_ret

///////////////////////////////
/*/
hybrid line-size consistency
	rendering breaks
		LTR|RTL
		\n|
	block
		design criteria
			should be O(n/C)
			should have a tight rendering BB
		consistency
			don't break UTF8 chars
			block size must not exceed C+epsilon
			if a block contains one rendering break
				it must be the block tail
			if a block contains more than one rendering breaks
				the block head must also be one
			\n and LTR|RTL are nested
				the break consistencies should be satisfied separately
					with \n taking priority
				e.g. if the block contains more than one line breaks
					the head must be one line break, not a LTR|RTL
			if we have isLineOnly:
				allow block size to exceed C
				but still merge short lines
/*/
struct TBlockOp
	//delete first, add after
	i64 ccnt
	i64 sz
	string[] ss

class CSLNode
	CSLNode pchild
	CSLNode pnext
	//////////
	i64 ccnt
	string s
	i64[] a

struct TSLList
	CSLNode phead
	CSLNode ptail
	inline cat(TSLList b)
		if !phead:return b
		if !b.phead:return TSLList(){phead:phead,ptail:ptail}
		ret=TSLList()
		ret.phead=phead
		ptail.pnext=b.phead
		ret.ptail=b.ptail
		return ret

struct TEditop
	//delete first, add after
	i64 ccnt
	i64 sz
	string s

//this will be directly passed to JS... research class wrapping
class CLocator
	i64 ccnt
	i8 side
	i8 undo_tracked
	i8 discarded
	discard=function(JSContext JS){
		discarded=i8(1)
		return 0
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"ccnt")
		proto.ExportProperty(this,"side")
		proto.ExportProperty(this,"undo_tracked")
		proto.ExportMethod(this,"discard",discard)

class CHLRange
	CLocator p0
	CLocator p1
	int color
	i16 category
	i8 invertible
	i8 discarded
	discard=function(JSContext JS){
		discarded=i8(1)
		return 0
	}
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"p0")
		proto.ExportProperty(this,"p1")
		proto.ExportProperty(this,"color")
		proto.ExportProperty(this,"invertible")
		proto.ExportProperty(this,"category")
		proto.ExportMethod(this,"discard",discard)

struct TLocatorUndoItem
	//test undo_tracked...
	CLocator loc
	i64 ccnt

struct TUndoItem
	TEditop[] ops
	TLocatorUndoItem[] locs

SKIPLIST_PROMOTION_PROBABILITY=0.25f//1.0/2.71828
//the internal methods *should not* validate parameters
g_unicode_wordchars=[170,171,181,182,186,187,192,215,216,247,248,706,710,722,736,741,748,749,750,751,880,885,886,894,895,896,902,903,904,1014,1015,1154,1162,1370,1377,1416,1488,1523,1568,1611,1632,1642,1646,1648,1649,1748,1749,1750,1765,1767,1774,1789,1791,1792,1808,1809,1810,1840,1869,1958,1969,2027,2036,2038,2042,2070,2074,2075,2084,2085,2088,2089,2112,2137,2208,2227,2308,2362,2365,2366,2384,2385,2392,2402,2406,2416,2417,2433,2437,2490,2493,2494,2510,2511,2524,2530,2534,2546,2565,2618,2649,2672,2674,2677,2693,2746,2749,2750,2768,2786,2790,2800,2821,2874,2877,2878,2908,2914,2918,2928,2929,2930,2947,3002,3024,3025,3046,3056,3077,3134,3160,3170,3174,3184,3205,3258,3261,3262,3294,3298,3302,3315,3333,3390,3406,3407,3424,3426,3430,3440,3450,3456,3461,3527,3558,3568,3585,3633,3634,3636,3648,3655,3664,3674,3713,3761,3762,3764,3773,3783,3792,3841,3872,3882,3904,3949,3976,3981,4096,4139,4159,4170,4176,4182,4186,4190,4193,4194,4197,4199,4206,4209,4213,4226,4238,4239,4240,4250,4256,4347,4348,4955,4992,5008,5024,5109,5121,5741,5743,5760,5761,5787,5792,5867,5873,5906,5920,5938,5952,5970,5984,6001,6016,6068,6103,6104,6108,6109,6112,6122,6160,6313,6314,6431,6470,6572,6593,6600,6608,6618,6656,6679,6688,6741,6784,6810,6823,6824,6917,6964,6981,7002,7043,7073,7086,7142,7168,7204,7232,7294,7401,7405,7406,7410,7413,7415,7424,7616,7680,8125,8126,8127,8130,8141,8144,8156,8160,8173,8178,8189,8255,8257,8276,8277,8305,8306,8319,8320,8336,8349,8450,8451,8455,8456,8458,8468,8469,8470,8473,8478,8484,8485,8486,8487,8488,8489,8490,8494,8495,8506,8508,8512,8517,8522,8526,8527,8579,8581,11264,11493,11499,11503,11506,11508,11520,11632,11648,11743,11823,11824,12293,12295,12337,12342,12347,12349,12353,12439,12445,12448,12449,12539,12540,12687,12704,12731,12784,12800,13312,19894,19968,42125,42192,42238,42240,42509,42512,42607,42623,42654,42656,42726,42775,42784,42786,42889,42891,43010,43011,43014,43015,43019,43020,43043,43072,43124,43138,43188,43216,43226,43250,43256,43259,43302,43312,43335,43360,43389,43396,43443,43471,43482,43488,43493,43494,43561,43584,43587,43588,43596,43600,43610,43616,43639,43642,43643,43646,43696,43697,43698,43701,43703,43705,43710,43712,43713,43714,43742,43744,43755,43762,43765,43777,43867,43868,44003,44016,55292,63744,64286,64287,64297,64298,64434,64467,64830,64848,65020,65075,65077,65101,65104,65136,65277,65296,65306,65313,65339,65343,65344,65345,65371,65382,65501,65536,65787,66176,66257,66304,66336,66352,66369,66370,66378,66384,66422,66432,66462,66464,66512,66560,66916,67072,67670,67680,67703,67712,67743,67840,67862,67872,67898,67968,68097,68112,68148,68192,68221,68224,68253,68288,68296,68297,68325,68352,68406,68416,68438,68448,68467,68480,68498,68608,68681,69635,69688,69734,69744,69763,69808,69840,69882,69891,69927,69942,69952,69968,70003,70006,70007,70019,70067,70081,70085,70096,70107,70144,70188,70320,70367,70384,70394,70405,70458,70461,70462,70493,70498,70784,70832,70852,70854,70855,71087,71168,71216,71236,71339,71360,71914,71935,74649,77824,92778,92880,92910,92928,92976,92992,92996,93008,93018,93027,94033,94099,113818,119808,120513,120514,120539,120540,120571,120572,120597,120598,120629,120630,120655,120656,120687,120688,120713,120714,120745,120746,120771,120772,125125,126464,126652,131072,195102]
class CEditableText
	m_skiplist=new CSLNode(){s:new string}
	m_locators=new CLocator[]
	m_highlights=new CHLRange[]
	m_layout_valid_to=0L
	////////////////////
	m_handlers=new ITextStateHandler[]
	m_state_ofs=new iptr[]
	//m_hid_renderer=-1L
	m_is_line_only=0
	m_block_size=1024
	m_js=JSContext.NULL
	m_handler_registration=JSObject.NULL
	//////////
	m_caret_locator=CLocator.NULL
	m_IME_overlay=JSObject.NULL
	m_caret_offset=0.
	//////////
	m_ascii_wordchars=uint4()
	inline AddStateHandler(a)
		m_handlers.push(getInterface(a,ITextStateHandler))
		return m_handlers.n-1
	auto Init(JSObject obj_style)
		//todo: validate the creation - must have ["renderer"]
		m_js=obj_style.m_jsctx
		m_handler_registration=m_js.New()
		ofs=0L
		foreach hstate,I in m_handlers
			hstate.id=I
			if hstate.isLineOnly&&hstate.isLineOnly():
				m_is_line_only=1
			//if hstate.RenderText:
			//	assert(m_hid_renderer==-1L)
			//	m_hid_renderer=I
			m_state_ofs.push(ofs)
			ofs+=hstate.stateSize()
			///////////
			m_handler_registration[hstate.name()]=I
			if hstate.SetTextStyle:
				hstate.SetTextStyle(obj_style)
		//m_handler_registration["m_is_line_only"]=m_is_line_only
		m_state_ofs.push(ofs)
		RecomputeStates(m_skiplist)
		//m_handler_registration["style"]=obj_style
		m_ascii_wordchars=MakeCharSet(obj_style["charset_word"].or("0-9A-Za-z_"))
	auto isWordChar(int ch)
		if ch>=128:
			pt=g_unicode_wordchars.Bisect(function(int c0){return c0<=ch})
			return int(g_unicode_wordchars.Bisect(function(int c0){return c0<ch})&1)
		slot=(ch>>5)
		for i in crange(4)
			if i==slot:return int(m_ascii_wordchars[i]>>(ch&31))&1
		return 0
	auto RecomputeStates(CSLNode nd)
		n=m_state_ofs.back()
		ccnt=0LL
		s=nd.s
		if s:
			a=new i64[n+m_handlers.n]
			ccnt=i64(s.n)
			foreach hstate,I in m_handlers
				a_slice=a[m_state_ofs[I]:m_state_ofs[I+1]-1]
				block_state=i64[].NULL
				if hstate.PreprocessBlock:
					block_state=hstate.PreprocessBlock(this,a_slice,s)
				hstate.AddString(a_slice,block_state,s,s.n)
				a_slice.discard()
				a[n+I]=i64(a.n)
				if block_state:
					a.push(block_state)
		else
			a=new i64[n]
			for(pc=nd.pchild;pc;pc=pc.pnext)
				foreach hstate,I in m_handlers
					hstate.Add(a[m_state_ofs[I]:m_state_ofs[I+1]-1],pc.a[m_state_ofs[I]:m_state_ofs[I+1]-1])
				ccnt+=pc.ccnt
		nd.a=a
		nd.ccnt=ccnt
	auto BlockFromCcnt(i64 ccnt0)
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				nd=nd.pnext
			if nd.s:
				return (nd,ccnt0-ccnt_base)
			assert(!!nd.pchild)
			nd=nd.pchild
	auto GetStateAt(int hid,i64 ccnt0)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		handler=m_handlers[hid]
		///////////
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a)
				nd=nd.pnext
			if nd.s:
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+handler.id]
				ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
				handler.AddString(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,iptr(ccnt0-ccnt_base))
				return acc
			assert(!!nd.pchild)
			nd=nd.pchild
	auto GetCharacterHeightAt(i64 ccnt0)
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		///////////
		nd=m_skiplist
		ccnt_base=0LL
		for(;;)
			while ccnt_base+nd.ccnt<=ccnt0&&nd.pnext:
				ccnt_base+=nd.ccnt
				handler.Add(acc,nd.a)
				nd=nd.pnext
			if nd.s:
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+handler.id]
				ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
				return handler.GetCharacterHeightAt(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,iptr(ccnt0-ccnt_base))
			assert(!!nd.pchild)
			nd=nd.pchild
	auto skipListPromote(TSLList nds_ret0, TSLList nds_child0,TSLList nds_toadd,CSLNode nd_ignore)
		nds_ret=nds_ret0
		nds_child=nds_child0
		pc_pnext=CSLNode.NULL
		for(pc=nds_toadd.phead;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			if iptr(pc)!=iptr(nd_ignore)&&nds_child.phead&&System.Algorithm.Random(float)<SKIPLIST_PROMOTION_PROBABILITY:
				//finish off the dangling chain
				nds_child.ptail.pnext=CSLNode.NULL
				nds_ret.ptail.pchild=nds_child.phead
				RecomputeStates(nds_ret.ptail)
				//actually promote pc
				nd_new=new CSLNode
				nds_ret.ptail.pnext=nd_new
				nds_ret.ptail=nd_new
				nds_child=TSLList(){phead:pc,ptail:pc}
			else
				if !nds_child.phead:
					nds_child.phead=pc
					//nds_child.ptail=pc
				else
					nds_child.ptail.pnext=pc
				nds_child.ptail=pc
		return (nds_ret,nds_child)
	auto skipListPromoteToRoot(TSLList nds_toadd0)
		nds_toadd=nds_toadd0
		for(;;)
			if iptr(nds_toadd.phead)==iptr(nds_toadd.ptail)&&!nds_toadd.phead.s:
				assert(!nds_toadd.phead.pnext)
				return nds_toadd.phead
			//promote the head
			nd_new=new CSLNode
			nds_ret=TSLList(){phead:nd_new,ptail:nd_new}
			nds_child=TSLList(){phead:nds_toadd.phead,ptail:nds_toadd.phead}
			nds_toadd.phead=nds_toadd.phead.pnext
			//add the rest
			(nds_ret,nds_child)=skipListPromote(nds_ret,nds_child,nds_toadd,CSLNode.NULL)
			nds_ret.ptail.pchild=nds_child.phead;nds_child.ptail.pnext=CSLNode.NULL
			RecomputeStates(nds_ret.ptail)
			//recurse one level up
			nds_toadd=nds_ret
	auto BlockEdit(CSLNode nd,i64 ccnt_base0,TBlockOp[] bops)
		assert(!nd.s)
		//for each child -> untouched / new list (on which we apply random growth)
		//so the return value is a list
		p=0L
		ccnt_base=ccnt_base0
		//nds_ret.ptail.pchild is the dangling part represented by nds_child
		nds_ret=TSLList(){phead:nd,ptail:nd}
		nds_child=TSLList()
		pc_pnext=CSLNode.NULL
		for(pc=nd.pchild;pc;pc=pc_pnext)
			pc_pnext=pc.pnext
			pc_ccnt=pc.ccnt
			//intersect cut bops with the child
			p0=p
			while p<bops.n&&bops[p].ccnt<ccnt_base+pc.ccnt:
				p++
			//assert(p==bops.n||bops[p].ccnt==ccnt_base+pc.ccnt)
			//each bop could cover *multiple* children... need to test it
			//Writeln('>>> ',formatNumber(iptr(pc),{base:16,align:8}),' ',formatNumber(iptr(pc_pnext),{base:16,align:8}),' ',p0,' ',p,' ',ccnt_base,' ',pc.ccnt)
			if p0<p:
				bk=bops[p-1]
				bk2=bops[p0]
				bops[p-1].sz=min(ccnt_base+pc.ccnt-bops[p-1].ccnt,bops[p-1].sz)
				if bops[p-1].sz<bk.sz:
					bops[p-1].ss=string[].NULL
				bops[p0].sz+=bops[p0].ccnt
				bops[p0].ccnt=max(ccnt_base,bops[p0].ccnt)
				bops[p0].sz-=bops[p0].ccnt
				assert(bops[p-1].sz>0LL)
				assert(bops[p0].sz>0LL)
				if p0==p-1&&(!bops[p0].ss||ccnt_base+pc.ccnt<bops[p0].ccnt+bops[p0].sz)&&bops[p0].ccnt==ccnt_base&&bops[p0].sz==pc.ccnt:
					//completely deleted, discard the child
					//do nothing here but continue on with the loop code
				else
					if pc.s:
						assert(p0==p-1)
						assert(!!bops[p0].ss)
						assert(bops[p0].ccnt==ccnt_base)
						nds_pc=TSLList()
						foreach s in bops[p0].ss
							nd_new=new CSLNode(){s:s,ccnt:s.n}
							RecomputeStates(nd_new)
							if !nds_pc.phead:
								nds_pc.phead=nd_new
							else
								nds_pc.ptail.pnext=nd_new
							nds_pc.ptail=nd_new
						//Writeln(formatNumber(iptr(nds_pc.phead),{base:16,align:8}),' ',formatNumber(iptr(nds_pc.ptail),{base:16,align:8}))
						if bops[p0].sz:
							//throw away pc
							assert(bops[p0].sz==pc.ccnt)
						else
							//keep it
							nds_pc=nds_pc.cat(TSLList(){phead:pc,ptail:pc})
					else
						nds_pc=BlockEdit(pc,ccnt_base,bops[p0:p-1])
					(nds_ret,nds_child)=skipListPromote(nds_ret, nds_child,nds_pc,pc)
				bops[p0]=bk2
				bops[p-1]=bk
				//the last bop covers multiple segments
				if ccnt_base+pc_ccnt<bops[p-1].ccnt+bops[p-1].sz:
					p--
			else
				pc.pnext=CSLNode.NULL
				nds_child=nds_child.cat(TSLList(){phead:pc,ptail:pc})
			ccnt_base+=pc_ccnt
		//coulddo: removing nd itself
		nds_ret.ptail.pchild=nds_child.phead;
		if nds_child.ptail:nds_child.ptail.pnext=CSLNode.NULL
		RecomputeStates(nds_ret.ptail)
		return nds_ret
	auto SortLocators()
		n2=0L
		foreach loc,I in m_locators
			if !loc.discarded:
				m_locators[n2++]=loc
		m_locators.resize(n2)
		m_locators.Sortby(inline(loc){return loc.ccnt})
	auto RawEdit(TEditop[] ops)
		//editop -> block replace: mainly take-the-next-and-merge
		//do the locators here
		pb=CSLNode.NULL
		ccnt_base=0LL
		ofs=0LL
		//////////
		SortLocators()
		ploc=0L
		pops=0L
		lside_tar=0LL
		rside_tar=0LL
		delta=0LL
		while ploc<m_locators.n&&pops<ops.n:
			ccnt0=ops[pops].ccnt
			ccnt1=ccnt0+ops[pops].sz
			loc=m_locators[ploc]
			ccnt_loc=loc.ccnt
			if ccnt_loc<ccnt0:
				//it didn't overlap anything
				loc.ccnt+=delta
				ploc++
				continue
			lside_tar=ccnt0+delta
			rside_tar=ccnt0+delta
			if ops[pops].s:rside_tar+=ops[pops].s.n
			if ccnt_loc<=ccnt1:
				//it overlapped the deletion
				if loc.side<1||ccnt_loc<ccnt1:
					//push left
					loc.ccnt=lside_tar
				else
					//push right
					loc.ccnt=rside_tar
				ploc++
				continue
			else
				//we're still to the left of the locator
				if ops[pops].s:delta+=ops[pops].s.n
				delta+=ccnt0-ccnt1
				pops++
		//////////
		bops=new TBlockOp[]
		bop_current=TBlockOp()
		s_pool=new string
		s_pool_last_newline=0L
		//s_pool_has_bidi_bound=0
		auto poolString(string s)
			if !s.n:return
			auto p_last_flush=0L
			auto p_last_newline=s_pool_last_newline
			auto p=s_pool.n
			auto addBlock(iptr p0,iptr p1)
				p_last_flush=p1
				//Writeln('addBlock: ',p0,' ',p1)
				//virtual string access
				auto s_block=string.NULL
				if p1<=s_pool.n:
					s_block=new(s_pool[p0:p1-1])
				else if p0>=s_pool.n:
					s_block=new(s[p0-s_pool.n:p1-s_pool.n-1])
				else
					s_block=s_pool[p0:]+s[:p1-s_pool.n-1]
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
			foreach chc,I in s
				ch=int(u8(chc))
				if (ch&0xc0)!=0x80&&!(s_pool.n&&s_pool.back()=='\r'&&ch=='\n'):
					//check for block breaking, but do not break UTF-8 chars or \r\n
					if p-p_last_newline>=m_block_size&&(!m_is_line_only||p_last_newline>p_last_flush):
						//need a break...
						if p_last_newline>p_last_flush:
							//we got newlines in the block, we can only break at s_pool_last_newline
							addBlock(p_last_flush,p_last_newline)
						else
							//it's a single-line block...
							addBlock(p_last_flush,p)
				p++//s_pool.push(chc)
				if ch=='\n':
					p_last_newline=p
			//virtual -> real
			if p_last_flush<s_pool.n:
				s_pool=s_pool[p_last_flush:]+s
			else
				s_pool=new(s[p_last_flush-s_pool.n:])
			s_pool_last_newline=max(p_last_newline-p_last_flush,0L)
		auto flush()
			if pb&&pb.s.n:
				if ofs<pb.s.n:
					poolString(pb.s[iptr(ofs):])
					bop_current.sz+=i64(pb.s.n)-ofs
				else
					//assert last block
			if s_pool_last_newline:
				s_block=new(s_pool[:s_pool_last_newline-1])
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_block)
				s_pool=new(s_pool[s_pool_last_newline:])
			if s_pool.n:
				//assert(!m_is_line_only)//or end of text... which is untestable here
				if !bop_current.ss:
					bop_current.ss=new string[]
				bop_current.ss.push(s_pool)
			if bop_current.sz||bop_current.ss:
				bops.push(bop_current)
				bop_current=TBlockOp()
		foreach op in ops
			if !pb||ccnt_base+pb.ccnt<op.ccnt:
				//we've left the current block, need to reseek
				flush()
				(pb,ofs)=BlockFromCcnt(op.ccnt)
				ccnt_base=op.ccnt-ofs
				bop_current.ccnt=ccnt_base
				ofs=0LL
			ofs_new=i64(op.ccnt-ccnt_base)
			if ofs_new>ofs:
				poolString(pb.s[iptr(ofs):iptr(ofs_new)-1])
				ofs=ofs_new
				assert(ofs<=pb.ccnt)
				if ofs==pb.ccnt:
					//merge with the next block - it's mandatory for line-only guys
					ccnt_base+=ofs
					(pb,ofs)=BlockFromCcnt(ccnt_base)
					if ofs==pb.ccnt:
						//do nothing, it's the tail
					else
						assert(!ofs)
						ofs=0LL
			//move by sz
			if op.sz:
				ofs+=op.sz
				if ofs>=pb.ccnt:
					(pb,ofs)=BlockFromCcnt(op.ccnt+op.sz)
			bop_current.sz=op.ccnt+op.sz-bop_current.ccnt
			if op.s:poolString(op.s)
		flush()
		//Writeln(ops)
		//Writeln('---------------------------------------------------------')
		//Writeln(bops)
		//block replace -> skiplist edit
		if m_skiplist.ccnt:
			nds_pc=BlockEdit(m_skiplist,0LL,bops)
		else
			nds_pc=TSLList()
			foreach bop in bops
				foreach s in bop.ss
					nd_new=new CSLNode(){s:s,ccnt:s.n}
					RecomputeStates(nd_new)
					if !nds_pc.phead:
						nds_pc.phead=nd_new
					else
						nds_pc.ptail.pnext=nd_new
					nds_pc.ptail=nd_new
		m_skiplist=skipListPromoteToRoot(nds_pc)
		assert(!m_skiplist.pnext)
		if !m_skiplist.ccnt:
			m_skiplist=new CSLNode(){s:new string}
			RecomputeStates(m_skiplist)
		//debugDumpSL()
	auto _GetText(string buf,iptr ofs, CSLNode nd,i64 ccnt0,i64 ccnt1)
		if nd.s:
			copy(buf[ofs:],nd.s[iptr(ccnt0):iptr(ccnt1-1LL)])
		else
			ccnt_base=0LL
			for(pc=nd.pchild;pc;pc=pc.pnext)
				p0=max(ccnt0-ccnt_base,0LL)
				p1=min(ccnt1-ccnt_base,pc.ccnt)
				if p1>p0:
					_GetText(buf,ofs+iptr(max(ccnt_base-ccnt0,0LL)), pc,p0,p1)
				ccnt_base+=pc.ccnt
	auto GetText(i64 ccnt,i64 sz)
		buf=new char[sz]
		_GetText(buf,0L, m_skiplist,ccnt,ccnt+sz)
		return buf
	inline GetTextSize()
		return m_skiplist.ccnt
	////////////////////////////////////
	//undo/redo enabled editing
	m_undo_queue=new TUndoItem[]
	m_redo_queue=new TUndoItem[]
	auto InvertEditops(TEditop[] ops)
		//Here we assume ops is sorted
		ops2=new TEditop[ops.n]
		delta=0LL
		foreach op,I in ops
			op2=op
			op2.ccnt+=delta
			if op.sz:
				op2.s=GetText(op.ccnt,op.sz)
				delta-=op.sz
			else
				op2.s=string.NULL
			if op.s:
				op2.sz=i64(op.s.n)
				delta+=i64(op.s.n)
			else
				op2.sz=0LL
			ops2[I]=op2
		return ops2
	auto UndoableEdit(TEditop[] ops,TUndoItem[] queue)
		locs=new TLocatorUndoItem[]
		foreach loc,I in m_locators
			if loc.undo_tracked:
				locs.push(TLocatorUndoItem(){loc:loc,ccnt:loc.ccnt})
		queue.push(TUndoItem(){ops:InvertEditops(ops),locs:locs})
		RawEdit(ops)
	auto Edit(TEditop[] ops)
		m_redo_queue.discard()
		UndoableEdit(ops,m_undo_queue)
	auto RawUndo(TUndoItem[] queue_in,TUndoItem[] queue_out)
		uitem=queue_in.pop()
		UndoableEdit(uitem.ops,queue_out)
		foreach loci in uitem.locs
			loci.loc.ccnt=loci.ccnt
		//single-insert special case: return the info in the API, select it in js code
		ret=long2(0LL,0LL)
		if uitem.ops.n==1:
			if !uitem.ops[0].sz&&uitem.ops[0].s&&uitem.ops[0].s.n:
				ret=long2(uitem.ops[0].ccnt,i64(uitem.ops[0].s.n))
		return ret
	inline Undo()
		return RawUndo(m_undo_queue,m_redo_queue)
	inline Redo()
		return RawUndo(m_redo_queue,m_undo_queue)
	////////////////////////////////////
	/*
	how exactly do we do a backward bracket lookup? the thing is state-dependent and *not* monotone!
		--
		start-from-zero min/count evaluation
			evaluate front-to-back
			or we could evaluate and Compare front-to-back
				then search back-to-front for the last 1
		and a contexted per-char version
			SeekInBlock
				the ccnt anchor / search type could be included in b
		it's a non-bisect search using an "or" hierarchy
		--
	*/
	auto _Bisect(i64[] acc, ITextStateHandler handler,i64 ccnt_base0,CSLNode nd,i64[] b)
		if nd.s:
			n0=m_state_ofs.back()
			ofspp=nd.a[n0+handler.id]
			ofspp2=(handler.id==m_handlers.n-1?i64(nd.a.n):nd.a[n0+handler.id+1])
			return ccnt_base0+i64(handler.SeekInBlock(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s,b))
		else
			ccnt_base=ccnt_base0
			acc2=new(acc)
			for(pc=nd.pchild;pc;pc=pc.pnext)
				copy(acc2,acc)
				handler.Add(acc2,pc.a)
				if handler.Compare(acc2,b)>0:
					acc2=i64[].NULL
					return _Bisect(acc, handler,ccnt_base,pc,b)
				copy(acc,acc2)
				ccnt_base+=pc.ccnt
			return ccnt_base
	auto Bisect(int hid,i64[] b)
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		return _Bisect(acc,m_handlers[hid],0LL,m_skiplist,b)
	auto SeekXY(double x,double y)
		hid=m_handler_registration["renderer"].as(int)
		//ccnt0=Bisect(hid,[__double_as_longlong(x),__double_as_longlong(y)])
		//xy=XYFromCcnt(ccnt0)
		//return Bisect(hid,[__double_as_longlong(x),__double_as_longlong(xy.y)])
		ccnt0=Bisect(hid,[__double_as_longlong(x),__double_as_longlong(max(y,0.0))])
		xy=XYFromCcnt(ccnt0)
		if xy.y>y&&ccnt0>0LL&&GetText(ccnt0-1,1LL)=="\n":
			ccnt0--
		return ccnt0
	auto Render(double x,double y,double w,double h, float scr_x,float scr_y,float scale)
		//x,y,w,h refer to the world space window
		g_renderer.PushCliprect(scr_x,scr_y,float(w)*scale,float(h)*scale)
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		wnd_ccnt0=SeekXY(x,y)
		wnd_ccnt1=SeekXY(x+w,y+h)
		rendering_started=0
		scaled=double(scale)
		dx=double(scr_x)-x*scaled
		dy=double(scr_y)-y*scaled
		//////////////////////////////
		//prepare the achint
		caret_overlay=double3(-1.,-1.,0.)
		inline testOverlay(double2 xy)
			if epsEqual(xy.y,caret_overlay.y)&&xy.x>=caret_overlay.x:
				return xy+double2(caret_overlay.z,0.)
			else
				return xy
		if m_IME_overlay:
			m_IME_overlay["type"]="IME"
			xy_overlay=XYFromCcnt(m_caret_locator.ccnt)
			caret_overlay=double3(xy_overlay.x,xy_overlay.y,handler.SetCaretOverlay(xy_overlay,m_IME_overlay))
		else
			handler.SetCaretOverlay(double2(-1.,-1.),JSObject.NULL)
		//pre-draw the highlights
		//coulddo: text color inversion for high contrast highlight
		n2=0L
		foreach hl in m_highlights
			if hl.discarded||hl.p0.discarded||hl.p1.discarded:continue
			m_highlights[n2++]=hl
			ccnt0=hl.p0.ccnt
			ccnt1=hl.p1.ccnt
			if ccnt1==ccnt0:continue
			if ccnt1<ccnt0:
				if !hl.invertible:continue
				(ccnt0,ccnt1)=(ccnt1,ccnt0)
			if ccnt1<=wnd_ccnt0||ccnt0>=wnd_ccnt1:continue
			xy0=(testOverlay(XYFromCcnt(ccnt0))*scaled+double2(dx,dy)).as(float)
			xy1=(testOverlay(XYFromCcnt(ccnt1))*scaled+double2(dx,dy)).as(float)
			//Writeln(xy0,' ',xy1,' ',ccnt0,' ',ccnt1)
			//Writeln(__double_as_longlong(xy0.y)-__double_as_longlong(xy1.y))
			//Writeln(abs(__double_as_longlong(xy0.y)-__double_as_longlong(xy1.y)))
			//Writeln('epsEqual')
			if epsEqual(xy0.y,xy1.y):
				hc=GetCharacterHeightAt(ccnt1)*scale
				g_renderer.DrawBitmap(0, xy0.x,xy0.y,xy1.x-xy0.x,hc, hl.color)
			else
				//draw 3 rects, we have a cliprect, don't worry
				hc=GetCharacterHeightAt(ccnt0)*scale
				g_renderer.DrawBitmap(0, xy0.x,xy0.y,max(scr_x+float(w)*scale-xy0.x,0.f),hc, hl.color)
				g_renderer.DrawBitmap(0, scr_x,xy0.y+hc,float(w)*scale,max(xy1.y-(xy0.y+hc),0.f), hl.color)
				hc=GetCharacterHeightAt(ccnt1)*scale
				g_renderer.DrawBitmap(0, scr_x,xy1.y,max(xy1.x-scr_x,0.f),hc, hl.color)
		m_highlights.resize(n2)
		//////////////////////////////
		//really draw the blocks
		acc=new i64[m_state_ofs[hid+1]-m_state_ofs[hid]]
		auto dfsRender(CSLNode nd,i64 ccnt0,i64 ccnt1)
			if nd.s:
				rendering_started=1
				n0=m_state_ofs.back()
				ofspp=nd.a[n0+hid]
				ofspp2=(hid==m_handlers.n-1?i64(nd.a.n):nd.a[n0+hid+1])
				handler.RenderText(acc,nd.a[iptr(ofspp):iptr(ofspp2)-1],nd.s, dx,dy,scale)
				handler.Add(acc,nd.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
			else
				ccnt_base=0LL
				for(pc=nd.pchild;pc;pc=pc.pnext)
					p0=max(ccnt0-ccnt_base,0LL)
					p1=min(ccnt1-ccnt_base,pc.ccnt)
					if p1>p0:
						dfsRender(pc,p0,p1)
					else if !rendering_started:
						handler.Add(acc,pc.a[m_state_ofs[hid]:m_state_ofs[hid+1]-1])
					ccnt_base+=pc.ccnt
		dfsRender(m_skiplist,wnd_ccnt0,wnd_ccnt1)
		g_renderer.PopCliprect()
		m_caret_offset=handler.GetCaretOffset()
	/////////////////////////////////////////////////
	//just record classes and ccnts - restoring ccnt for discarded locators is OK
	auto CreateLocator(i64 ccnt,int side)
		ret=new CLocator(){ccnt:ccnt,side:i8(side)}
		m_locators.push(ret)
		return ret
	auto CreateHighlight(CLocator p0,CLocator p1)
		ret=new CHLRange(){p0:p0,p1:p1}
		m_highlights.push(ret)
		return ret
	auto XYFromCcnt(i64 ccnt)
		hid=m_handler_registration["renderer"].as(int)
		a=GetStateAt(hid,ccnt)
		return double2(__longlong_as_double(a[0]),__longlong_as_double(a[1]))
	//todo: style changing
	/////////////////
	inline enumCharsForward(i64 ccnt0)
		return {'forEach':inline(fbody){
			ccnt=ccnt0
			ccnt_tot=GetTextSize()
			for(;;)
				if ccnt>=ccnt_tot:break
				(pb,ofs)=BlockFromCcnt(ccnt)
				s=pb.s
				ccnt_base=ccnt-ofs
				n=s.n
				for(i=ofs;i<n;i++)
					fbody(s[i],ccnt_base+i64(i))
				if i<n:break
				ccnt=ccnt_base+i64(s.n)
		}}
	inline enumUtf8Forward(i64 ccnt)
		return CharToUtf8(enumCharsForward(ccnt),i64)
	inline enumCharsBackward(i64 ccnt0)
		return {'forEach':inline(fbody){
			ccnt=ccnt0-1LL
			for(;;)
				if ccnt<0LL:break
				(pb,ofs)=BlockFromCcnt(ccnt)
				s=pb.s
				ccnt_base=ccnt-ofs
				for(i=ofs;i>=0L;i--)
					fbody(s[i],ccnt_base+i64(i))
				if i>=0L:break
				ccnt=ccnt_base-1LL
		}}
	inline enumUtf8Backward(i64 ccnt)
		return CharToUtf8Backward(enumCharsBackward(ccnt),i64)
	auto GetUtf8CharNeighborhood(i64 ccnt0)
		ch0=int('\n');ch1=int('\n')
		foreach ch,I in enumUtf8Backward(ccnt0)
			ch0=ch
			break
		foreach ch,I in enumUtf8Forward(ccnt0)
			ch1=ch
			break
		return (ch0,ch1)
	auto GetCharNeighborhood(i64 ccnt0)
		ch0=int('\n');ch1=int('\n')
		foreach ch,I in enumCharsBackward(ccnt0)
			ch0=int(u8(ch))
			break
		foreach ch,I in enumCharsForward(ccnt0)
			ch1=int(u8(ch))
			break
		return (ch0,ch1)
	/////////////////
	JS_Edit=function(JSContext JS){
		is_raw=JS.Param(1).or(0)
		native_ops=JS.Param(0).as(TEditop[])
		if native_ops:
			if is_raw:
				RawEdit(native_ops)
			else
				Edit(native_ops)
			return 0
		js_ops=JS.Param(0).as(JSObject)
		if !js_ops:return 0
		n=iptr(js_ops["length"].as(double))
		if !(n>0)||(n%3):
			return JS.ReturnError("bad operation array length @1".Replace(["@1",string(n)]))
		//one array with even-odd packing
		range0=0LL
		range1=GetTextSize()
		ops=new TEditop[]
		for i=0:3:n-3
			op=TEditop(){ccnt:i64(js_ops[i].as(double)),sz:i64(js_ops[i+1].as(double)),s:js_ops[i+2].as(string)}
			if u64(op.ccnt)<u64(range0)||u64(op.ccnt+op.sz)>u64(range1)||u64(op.ccnt+op.sz)<u64(op.ccnt):
				return JS.ReturnError("invalid operation #@1".Replace(["@1",string(i)]))
			range0=op.ccnt+op.sz
			ops.push(op)
		if is_raw:
			RawEdit(ops)
		else
			Edit(ops)
		return 0
	}
	JS_Undo=function(JSContext JS){
		sside=JS.Param(0).or("undo")
		if sside=="undo":
			if !m_undo_queue.n:return 0
			ret=Undo()
		else
			if !m_redo_queue.n:return 0
			ret=Redo()
		jsret=JS.New()
		jsret["ccnt"]=ret.x
		jsret["sz"]=ret.y
		return JS.Return(jsret)
	}
	JS_GetText=function(JSContext JS){
		ed=this
		range0=0LL
		range1=ed.GetTextSize()
		ccnt=JS.Param(0).or(range0)
		sz=JS.Param(1).or(range1)
		if u64(ccnt)<u64(range0)||u64(ccnt+sz)>u64(range1)||u64(ccnt+sz)<u64(ccnt):
			return 0//JS.ReturnError("invalid range")
		return JS.Return(ed.GetText(ccnt,sz))
	}
	JS_GetTextSize=function(JSContext JS){
		return JS.Return(GetTextSize())
	}
	JS_Render=function(JSContext JS){
		ed=this
		params=JS.Param(0).as(JSObject)
		if !params:return 0
		param_x=params["x"].or(0.)
		param_y=params["y"].or(0.)
		param_w=params["w"].or(0.)
		param_h=params["h"].or(0.)
		param_scr_x=params["scr_x"].or(0.f)
		param_scr_y=params["scr_y"].or(0.f)
		param_scale=params["scale"].or(1.f)
		ed.Render(
			param_x,
			param_y,
			param_w,
			param_h,
			param_scr_x*g_renderer.m_pixels_per_unit,
			param_scr_y*g_renderer.m_pixels_per_unit,
			param_scale*g_renderer.m_pixels_per_unit)
		return 0
	}
	JS_CreateLocator=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		side=JS.Param(1).or(0)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			return 0
		else
			return JS.Return(CreateLocator(ccnt,side))
	}
	JS_CreateHighlight=function(JSContext JS){
		auto p0=JS.Param(0).as(CLocator)
		auto p1=JS.Param(1).as(CLocator)
		if !p0||!p1:
			return 0
		else
			return JS.Return(CreateHighlight(p0,p1))
	}
	JS_XYFromCcnt=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):
			//debugDumpSL()
			return 0
		xy=XYFromCcnt(ccnt)
		ret=JS.New()
		ret["x"]=xy[0]
		ret["y"]=xy[1]
		return JS.Return(ret)
	}
	//only need to support "l" and "d"
	EncodeStateArray=function(JSContext JS,JSObject js_array,string stypes){
		if !stypes||!js_array:return i64[].NULL
		n=js_array["length"].as(iptr)
		if n!=stypes.n:return i64[].NULL
		ret=new i64[n]
		for i=0:n-1
			d=js_array[i].as(double)
			if stypes[i]=='l':
				l=i64(d)
			else if stypes[i]=='d':
				l=__double_as_longlong(d)
			else
				return i64[].NULL
			ret[i]=l
		return ret
	}
	DecodeStateArray=function(JSContext JS,i64[] a,string stypes){
		if !stypes||!a:return JSObject.NULL
		n=a.n
		if n!=stypes.n:return JSObject.NULL
		ret=JS.NewArray()
		for i=0:n-1
			l=a[i]
			if stypes[i]=='l':
				d=double(l)
			else if stypes[i]=='d':
				d=__longlong_as_double(l)
			else
				return JSObject.NULL
			ret[i]=d
		return ret
	}
	JS_Bisect=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		b=EncodeStateArray(JS,JS.Param(1).as(JSObject),JS.Param(2).as(string))
		if !b:return JS.ReturnError("invalid type description")
		n_std=m_state_ofs[hid+1]-m_state_ofs[hid]
		if b.n!=n_std:return JS.ReturnError("invalid state array length @1, should be @2".Replace(["@1",string(b.n),"@2",string(n_std)]))
		return JS.Return(Bisect(hid,b))
	}
	JS_GetStateAt=function(JSContext JS){
		hid=JS.Param(0).as(int)
		if uptr(hid)>=uptr(m_handlers.n):return JS.ReturnError("invalid handler id")
		ccnt0=JS.Param(1).as(i64)
		range1=GetTextSize()
		if u64(ccnt0)>u64(range1):return JS.ReturnError("invalid location")
		stypes=JS.Param(2).as(string)
		a=GetStateAt(hid,ccnt0)
		ret=DecodeStateArray(JS,a,stypes)
		if !ret:
			return JS.ReturnError("invalid type description")
		else
			return JS.Return(ret)
	}
	JS_SeekXY=function(JSContext JS){
		x=JS.Param(0).as(double)
		y=JS.Param(1).as(double)
		return JS.Return(SeekXY(x,y))
	}
	JS_GetCharacterHeightAt=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		return JS.Return(GetCharacterHeightAt(ccnt))
	}
	JS_GetDefaultFont=function(JSContext JS){
		hid=m_handler_registration["renderer"].as(int)
		handler=m_handlers[hid]
		return JS.Return(handler.GetDefaultFont())
	}
	JS_SnapToCharBoundary=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		for(;;)
			if !ccnt||ccnt==range1:break
			(ch0,ch1)=GetCharNeighborhood(ccnt)
			//ch=GetText(ccnt,1LL)[0]
			if (ch1&0xc0)==0x80||ch1=='\n'&&ccnt&&ch1==int('\n')&&ch0==int('\r'):
				direction=JS.Param(1).or(1)
				if direction<1:
					if ccnt:
						ccnt--
					else
						break
				else
					if ccnt<range1:
						ccnt++
					else
						break
			else
				break
		return JS.Return(ccnt)
	}
	JS_MoveToBoundary=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		direction=JS.Param(1).or(1)
		stype=JS.Param(2).or("space")
		limit=JS.Param(3).or(65536)
		if stype=="space":
			fcheck=function(int c0,int c1){return c1!=' '&&c1!='\t'}
		else if stype=="word_boundary":
			fcheck=function(int c0,int c1){return this.isWordChar(c0)!=this.isWordChar(c1)}
		else if stype=="ctrl_lr_stop":
			fcheck=function(int c0,int c1){return !this.isWordChar(c0)&&this.isWordChar(c1)}
		else
			return 0
		//boundary types: word, space, ctrl-lr
		(ch0,ch1)=GetUtf8CharNeighborhood(ccnt)
		if direction<0:
			ch0=ch1
			ccnti_previous=ccnt
			foreach ch,ccnti in enumUtf8Backward(ccnt)
				ch1=ch0
				ch0=ch
				if fcheck(ch0,ch1):return JS.Return(ccnti_previous)
				limit--
				if limit<=0:return JS.Return(ccnti_previous)
				ccnti_previous=ccnti
			return JS.Return(0LL)
		else
			ch1=ch0
			foreach ch,ccnti in enumUtf8Forward(ccnt)
				ch0=ch1
				ch1=ch
				if fcheck(ch0,ch1):return JS.Return(ccnti)
				limit--
				if limit<=0:return JS.Return(ccnti)
			return JS.Return(GetTextSize())
	}
	JS_GetUtf8CharNeighborhood=function(JSContext JS){
		ccnt=JS.Param(0).or(0LL)
		range1=GetTextSize()
		if u64(ccnt)>u64(range1):return 0
		(ch0,ch1)=GetUtf8CharNeighborhood(ccnt)
		ret=JS.NewArray()
		ret[0]=ch0
		ret[1]=ch1
		return JS.Return(ret)
	}
	///////////////////////////
	auto debugDumpSL()
		levels=new string[]
		auto _debugDumpSL(int level,CSLNode nd0)
			if levels.n<=level*2:
				levels.push(new string)
				levels.push(new string)
			for(nd=nd0;nd;nd=nd.pnext)
				sname=levels[level*2+0]
				sdash=levels[level*2+1]
				if nd.s:
					sdash.push(nd.s.Replace(["\r",".", "\t",".", "\n","."]))
					assert(nd.s.n==nd.ccnt)
				else
					if nd.ccnt:sdash.push('+')
					for i=1:int(nd.ccnt)-1
						sdash.push('-')
				sname.push(formatNumber(iptr(nd),{base:16,align:8}))
				sname.resize(sdash.n)
				if nd.pchild:
					_debugDumpSL(level+1,nd.pchild)
		_debugDumpSL(0,m_skiplist)
		foreach s in levels
			Writeln(s.Replace(["\0","."]))
		Writeln()
	///////////////////////////
	auto __JS_prototype(JSObject proto)
		proto.ExportProperty(this,"m_handler_registration")
		proto.ExportProperty(this,"m_caret_locator")
		proto.ExportProperty(this,"m_IME_overlay")
		proto.ExportProperty(this,"m_caret_offset")
		proto.ExportMethod(this,"Edit",JS_Edit)
		proto.ExportMethod(this,"GetText",JS_GetText)
		proto.ExportMethod(this,"GetTextSize",JS_GetTextSize)
		proto.ExportMethod(this,"Render",JS_Render)
		proto.ExportMethod(this,"CreateLocator",JS_CreateLocator)
		proto.ExportMethod(this,"CreateHighlight",JS_CreateHighlight)
		proto.ExportMethod(this,"XYFromCcnt",JS_XYFromCcnt)
		proto.ExportMethod(this,"SeekXY",JS_SeekXY)
		proto.ExportMethod(this,"Bisect",JS_Bisect)
		proto.ExportMethod(this,"GetStateAt",JS_GetStateAt)
		proto.ExportMethod(this,"GetCharacterHeightAt",JS_GetCharacterHeightAt)
		proto.ExportMethod(this,"GetDefaultFont",JS_GetDefaultFont)
		proto.ExportMethod(this,"SnapToCharBoundary",JS_SnapToCharBoundary)
		proto.ExportMethod(this,"MoveToBoundary",JS_MoveToBoundary)
		proto.ExportMethod(this,"Undo",JS_Undo)
		proto.ExportMethod(this,"GetUtf8CharNeighborhood",JS_GetUtf8CharNeighborhood)

jsNewEditorBaseline=function(JSContext JS){
	obj_style=JS.Param(0).as(JSObject)
	if !obj_style:return 0
	ret=new CEditableText
	ret.AddStateHandler(new CLayouter_baseline)
	ret.Init(obj_style)
	return JS.Return(ret)
}
